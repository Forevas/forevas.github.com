<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>厚德载物，追求卓越</title>
  <subtitle>我的征途是星辰大海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://forevas.github.io/"/>
  <updated>2018-05-21T15:25:08.156Z</updated>
  <id>https://forevas.github.io/</id>
  
  <author>
    <name>Forevas</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RxJava学习总结</title>
    <link href="https://forevas.github.io/2017/11/03/RxJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://forevas.github.io/2017/11/03/RxJava学习总结/</id>
    <published>2017-11-03T15:09:51.000Z</published>
    <updated>2018-05-21T15:25:08.156Z</updated>
    
    <content type="html"><![CDATA[<p>RxJava+Retrofit+OkHttp是最佳的网络请求实践，之前的项目中一直是使用Callback的方式进行网络请求，最近得空，引入了RxJava和Retrofit，重新封装了下项目的网络请求模块，不得不说，使用RxJava的响应式编程思想，面向数据流的编程方式，写出来的代码十分优美。<br><a id="more"></a></p>
<h2 id="编程范式概述"><a href="#编程范式概述" class="headerlink" title="编程范式概述"></a>编程范式概述</h2><p>响应式编程: 响应式编程是一种面向数据流和变化传播的编程范式。实践:Rxjava</p>
<p>函数式编程: 或称函数程序设计，又称泛函编程，是一种编程典范，它将电脑运算视为数学上的函数计算，并且避免使用程序状态以及易变对象。函数编程语言最重要的基础是λ演算（lambda calculus）。而且λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。比起命令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。特征:函数作为基本单元,无状态,高阶函数等.</p>
<p>函数响应式编程:响应式编程思想为体，函数式编程思想为用。</p>
<p>命令式编程:是一种描述电脑所需作出的行为的编程典范。几乎所有电脑的硬件工作都是指令式的；几乎所有电脑的硬件都是设计来运行机器码，使用指令式的风格来写的。较高级的指令式编程语言使用变量和更复杂的语句，但仍依从相同的典范。菜谱和行动清单，虽非计算机程序，但与命令式编程有相似的风格：每步都是指令，有形的世界控制情况。因为命令式编程的基础观念，不但概念上比较熟悉，而且较容易具体表现于硬件，所以大部分的编程语言都是指令式的。实践:汇编和机器码.</p>
<p>面向对象编程:把构成问题的事物分解成一个个对象,建立对象的目的不是为了完成某一个步骤,而是为了描述某个事物在整个问题中的行为.</p>
<p>面向过程编程:分析出解决问题所需要的步骤,然后用函数把这些步骤一步步实现,使用的时候一个个依次调用就可以了.</p>
<p>以上编程范式并不互斥,可以相互结合使用,总而言之,编程范式本质就是为了更合理的解决问题而存在的.不要拘泥于概念而被已有的框架所束缚.</p>
<h2 id="RxJava基本概念"><a href="#RxJava基本概念" class="headerlink" title="RxJava基本概念"></a>RxJava基本概念</h2><p>Observable: 可被观察的对象<br>Observer: 观察者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123;</div><div class="line">                emitter.onNext(1);</div><div class="line">                emitter.onNext(2);</div><div class="line">                emitter.onNext(3);</div><div class="line">                emitter.onComplete();</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Observer&lt;Integer&gt;() &#123;//注意: 只有当上游和下游建立连接之后, 上游才会开始发送事件. 也就是调用了subscribe() 方法之后才开始发送事件.</div><div class="line">            @Override</div><div class="line">            public void onSubscribe(Disposable d) &#123;//注意Disposable在这里</div><div class="line">                Log.d(TAG, &quot;subscribe&quot;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onNext(Integer value) &#123;</div><div class="line">                Log.d(TAG, &quot;&quot; + value);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onError(Throwable e) &#123;</div><div class="line">                Log.d(TAG, &quot;error&quot;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onComplete() &#123;</div><div class="line">                Log.d(TAG, &quot;complete&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>ObservableEmitter： 数据发射器 onNext(T value)、onComplete()和onError(Throwable error)。</p>
<ul>
<li>上游可以发送无限个onNext, 下游也可以接收无限个onNext.</li>
<li>当上游发送了一个onComplete后, 上游onComplete之后的事件将会继续发送, 而下游收到onComplete事件之后将不再继续接收事件.</li>
<li>当上游发送了一个onError后, 上游onError之后的事件将继续发送, 而下游收到onError事件之后将不再继续接收事件.</li>
<li>上游可以不发送onComplete或onError.</li>
<li>最为关键的是onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError, 反之亦然</li>
</ul>
<p>Disposable: 调用它的dispose()方法时, 它就会将两根管道切断, 从而导致下游收不到事件.</p>
<p>subscribe()有多个重载的方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public final Disposable subscribe() &#123;&#125;</div><div class="line">    public final Disposable subscribe(Consumer&lt;? super T&gt; onNext) &#123;&#125;</div><div class="line">    public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError) &#123;&#125;</div><div class="line">    public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete) &#123;&#125;</div><div class="line">    public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Consumer&lt;? super Disposable&gt; onSubscribe) &#123;&#125;</div><div class="line">    public final void subscribe(Observer&lt;? super T&gt; observer) &#123;&#125;</div></pre></td></tr></table></figure>
<p>不带任何参数的subscribe() 表示下游不关心任何事件,带有一个Consumer参数的方法表示下游只关心onNext事件.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123;</div><div class="line">                Log.d(TAG, &quot;emit 1&quot;);</div><div class="line">                emitter.onNext(1);</div><div class="line">                Log.d(TAG, &quot;emit 2&quot;);</div><div class="line">                emitter.onNext(2);</div><div class="line">                Log.d(TAG, &quot;emit 3&quot;);</div><div class="line">                emitter.onNext(3);</div><div class="line">                Log.d(TAG, &quot;emit complete&quot;);</div><div class="line">                emitter.onComplete();</div><div class="line">                Log.d(TAG, &quot;emit 4&quot;);</div><div class="line">                emitter.onNext(4);</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void accept(Integer integer) throws Exception &#123;</div><div class="line">                Log.d(TAG, &quot;onNext: &quot; + integer);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>Rxjava默认上下游在同一个线程。</p>
<h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p>subscribeOn：控制在哪个线程发送事件，只有第一次指定有用，后续的都忽视<br>observeOn：控制在哪个线程接收事件，每次指定后接下来的操作都会在指定的线程，可多次指定</p>
<p>Rxjava内置线程选择:</p>
<ul>
<li>Schedulers.io() 代表io操作的线程, 通常用于网络,读写文件等io密集型的操作</li>
<li>Schedulers.computation() 代表CPU计算密集型的操作, 例如需要大量计算的操作</li>
<li>Schedulers.newThread() 代表一个常规的新线程</li>
<li>AndroidSchedulers.mainThread() 代表Android的主线程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">observable.subscribeOn(Schedulers.newThread())</div><div class="line">                .subscribeOn(Schedulers.io())</div><div class="line">                .observeOn(AndroidSchedulers.mainThread())</div><div class="line">                .doOnNext(new Consumer&lt;Integer&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void accept(Integer integer) throws Exception &#123;</div><div class="line">                        Log.d(TAG, &quot;After observeOn(mainThread), current thread is: &quot; + Thread.currentThread().getName());</div><div class="line">                    &#125;</div><div class="line">                &#125;)</div><div class="line">                .observeOn(Schedulers.io())</div><div class="line">                .doOnNext(new Consumer&lt;Integer&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void accept(Integer integer) throws Exception &#123;</div><div class="line">                        Log.d(TAG, &quot;After observeOn(io), current thread is : &quot; + Thread.currentThread().getName());</div><div class="line">                    &#125;</div><div class="line">                &#125;)</div><div class="line">                .subscribe(consumer);</div></pre></td></tr></table></figure>
<h3 id="配合Retrofit"><a href="#配合Retrofit" class="headerlink" title="配合Retrofit"></a>配合Retrofit</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public interface Api &#123;</div><div class="line">    @GET</div><div class="line">    Observable&lt;LoginResponse&gt; login(@Body LoginRequest request);</div><div class="line"></div><div class="line">    @GET</div><div class="line">    Observable&lt;RegisterResponse&gt; register(@Body RegisterRequest request);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Api api = retrofit.create(Api.class);</div><div class="line">        api.login(request)</div><div class="line">             .subscribeOn(Schedulers.io())               //在IO线程进行网络请求</div><div class="line">             .observeOn(AndroidSchedulers.mainThread())  //回到主线程去处理请求结果</div><div class="line">            .subscribe(new Observer&lt;LoginResponse&gt;() &#123;</div><div class="line">                @Override</div><div class="line">                public void onSubscribe(Disposable d) &#123;&#125;</div><div class="line"></div><div class="line">                @Override</div><div class="line">                public void onNext(LoginResponse value) &#123;&#125;</div><div class="line"></div><div class="line">                @Override</div><div class="line">                public void onError(Throwable e) &#123;</div><div class="line">                    Toast.makeText(mContext, &quot;登录失败&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                @Override</div><div class="line">                public void onComplete() &#123;</div><div class="line">                    Toast.makeText(mContext, &quot;登录成功&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div></pre></td></tr></table></figure>
<p>CompositeDisposable: Disposable的容器,用于Activity或者Fragment退出时销毁所有Disposable</p>
<h2 id="变换操作符"><a href="#变换操作符" class="headerlink" title="变换操作符"></a>变换操作符</h2><p>map: 对上游发送的每一个事件应用一个函数, 使得每一个事件都按照指定的函数去变化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123;</div><div class="line">                emitter.onNext(1);</div><div class="line">                emitter.onNext(2);</div><div class="line">                emitter.onNext(3);</div><div class="line">            &#125;</div><div class="line">        &#125;).map(new Function&lt;Integer, String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public String apply(Integer integer) throws Exception &#123;</div><div class="line">                return &quot;This is result &quot; + integer;</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Consumer&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void accept(String s) throws Exception &#123;</div><div class="line">                Log.d(TAG, s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>flatMap: 将一个发送事件的上游Observable变换为多个发送事件的Observables，然后将它们发射的事件合并后放进一个单独的Observable里,flatMap并不保证事件的顺序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123;</div><div class="line">                emitter.onNext(1);</div><div class="line">                emitter.onNext(2);</div><div class="line">                emitter.onNext(3);</div><div class="line">            &#125;</div><div class="line">        &#125;).flatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public ObservableSource&lt;String&gt; apply(Integer integer) throws Exception &#123;</div><div class="line">                final List&lt;String&gt; list = new ArrayList&lt;&gt;();</div><div class="line">                for (int i = 0; i &lt; 3; i++) &#123;</div><div class="line">                    list.add(&quot;I am value &quot; + integer);</div><div class="line">                &#125;</div><div class="line">                return Observable.fromIterable(list).delay(10,TimeUnit.MILLISECONDS);</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Consumer&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void accept(String s) throws Exception &#123;</div><div class="line">                Log.d(TAG, s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>concatMap: 和flatMap一样,但是保证事件的先后顺序</p>
<p>多个网络请求嵌套:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">api.register(new RegisterRequest())            //发起注册请求</div><div class="line">                .subscribeOn(Schedulers.io())               //在IO线程进行网络请求</div><div class="line">                .observeOn(AndroidSchedulers.mainThread())  //回到主线程去处理请求注册结果</div><div class="line">                .doOnNext(new Consumer&lt;RegisterResponse&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void accept(RegisterResponse registerResponse) throws Exception &#123;</div><div class="line">                        //先根据注册的响应结果去做一些操作</div><div class="line">                    &#125;</div><div class="line">                &#125;)</div><div class="line">                .observeOn(Schedulers.io())                 //回到IO线程去发起登录请求</div><div class="line">                .flatMap(new Function&lt;RegisterResponse, ObservableSource&lt;LoginResponse&gt;&gt;() &#123;//这里用map也可以实现</div><div class="line">                    @Override</div><div class="line">                    public ObservableSource&lt;LoginResponse&gt; apply(RegisterResponse registerResponse) throws Exception &#123;</div><div class="line">                        return api.login(new LoginRequest());</div><div class="line">                    &#125;</div><div class="line">                &#125;)</div><div class="line">                .observeOn(AndroidSchedulers.mainThread())  //回到主线程去处理请求登录的结果</div><div class="line">                .subscribe(new Consumer&lt;LoginResponse&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void accept(LoginResponse loginResponse) throws Exception &#123;</div><div class="line">                        Toast.makeText(MainActivity.this, &quot;登录成功&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">                    &#125;</div><div class="line">                &#125;, new Consumer&lt;Throwable&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void accept(Throwable throwable) throws Exception &#123;</div><div class="line">                        Toast.makeText(MainActivity.this, &quot;登录失败&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div></pre></td></tr></table></figure></p>
<p>map和flatMap的区别在于,map是1对1关系,而flatmap是1对多关系</p>
<h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><p>zip操作符用于将多个Observable发送的事件进行合并,它按照严格的顺序应用这个函数,它只发射与发射数据项最少的那个Observable一样多的数据.</p>
<p>异步进行合并:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Integer&gt; observable1 = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;         </div><div class="line">    @Override                                                                                      </div><div class="line">    public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123;                   </div><div class="line">        Log.d(TAG, &quot;emit 1&quot;);                                                                      </div><div class="line">        emitter.onNext(1);                                                                         </div><div class="line">        Thread.sleep(1000);                                                                        </div><div class="line"></div><div class="line">        Log.d(TAG, &quot;emit 2&quot;);                                                                      </div><div class="line">        emitter.onNext(2);                                                                         </div><div class="line">        Thread.sleep(1000);                                                                        </div><div class="line"></div><div class="line">        Log.d(TAG, &quot;emit 3&quot;);                                                                      </div><div class="line">        emitter.onNext(3);                                                                         </div><div class="line">        Thread.sleep(1000);                                                                        </div><div class="line"></div><div class="line">        Log.d(TAG, &quot;emit 4&quot;);                                                                      </div><div class="line">        emitter.onNext(4);                                                                         </div><div class="line">        Thread.sleep(1000);                                                                        </div><div class="line"></div><div class="line">        Log.d(TAG, &quot;emit complete1&quot;);                                                              </div><div class="line">        emitter.onComplete();                                                                      </div><div class="line">    &#125;                                                                                              </div><div class="line">&#125;).subscribeOn(Schedulers.io());                                                                   </div><div class="line"></div><div class="line">Observable&lt;String&gt; observable2 = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;           </div><div class="line">    @Override                                                                                      </div><div class="line">    public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123;                    </div><div class="line">        Log.d(TAG, &quot;emit A&quot;);                                                                      </div><div class="line">        emitter.onNext(&quot;A&quot;);                                                                       </div><div class="line">        Thread.sleep(1000);                                                                        </div><div class="line"></div><div class="line">        Log.d(TAG, &quot;emit B&quot;);                                                                      </div><div class="line">        emitter.onNext(&quot;B&quot;);                                                                       </div><div class="line">        Thread.sleep(1000);                                                                        </div><div class="line"></div><div class="line">        Log.d(TAG, &quot;emit C&quot;);                                                                      </div><div class="line">        emitter.onNext(&quot;C&quot;);                                                                       </div><div class="line">        Thread.sleep(1000);                                                                        </div><div class="line"></div><div class="line">        Log.d(TAG, &quot;emit complete2&quot;);                                                              </div><div class="line">        emitter.onComplete();                                                                      </div><div class="line">    &#125;                                                                                              </div><div class="line">&#125;).subscribeOn(Schedulers.io());                                                                   </div><div class="line"></div><div class="line">Observable.zip(observable1, observable2, new BiFunction&lt;Integer, String, String&gt;() &#123;               </div><div class="line">    @Override                                                                                      </div><div class="line">    public String apply(Integer integer, String s) throws Exception &#123;                              </div><div class="line">        return integer + s;                                                                        </div><div class="line">    &#125;                                                                                              </div><div class="line">&#125;).subscribe(new Observer&lt;String&gt;() &#123;                    </div><div class="line">    @Override                                                                                      </div><div class="line">    public void onSubscribe(Disposable d) &#123;                                                        </div><div class="line">        Log.d(TAG, &quot;onSubscribe&quot;);                                                                 </div><div class="line">    &#125;                                                                                              </div><div class="line"></div><div class="line">    @Override                                                                                      </div><div class="line">    public void onNext(String value) &#123;                                                             </div><div class="line">        Log.d(TAG, &quot;onNext: &quot; + value);                                                            </div><div class="line">    &#125;                                                                                              </div><div class="line"></div><div class="line">    @Override                                                                                      </div><div class="line">    public void onError(Throwable e) &#123;                                                             </div><div class="line">        Log.d(TAG, &quot;onError&quot;);                                                                     </div><div class="line">    &#125;                                                                                              </div><div class="line"></div><div class="line">    @Override                                                                                      </div><div class="line">    public void onComplete() &#123;                                                                     </div><div class="line">        Log.d(TAG, &quot;onComplete&quot;);                                                                  </div><div class="line">    &#125;                                                                                              </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>zip发送的事件数量跟上游中发送事件最少的那一根水管的事件数量是有关的, 在这个例子里我们第二根水管只发送了三个事件然后就发送了Complete, 这个时候尽管第一根水管还有事件4 和事件Complete 没有发送, 但是它们发不发送还有什么意义呢? 所以本着节约是美德的思想, 就不让它发了.</p>
<p>如果不发送Complete呢？ 答案是显然的, 上游会继续发送事件, 但是下游仍然收不到那些多余的事件.</p>
<p>如果在同一线程中,则不受这个条件约束,会发完一个Obervable的数据再去发另一个.</p>
<h2 id="Backpressure"><a href="#Backpressure" class="headerlink" title="Backpressure"></a>Backpressure</h2><p>Backpressure是1.0的概念,用于发送数据和接收数据速率不统一的问题,2.0之后是没有这个概念的,大数据流用Flowable+Subscriber，小数据流用Observable+Observer.</p>
<p>当上下游处于不同线程,且上游速度远大于下游,可能会OOM,可以采用filter,sample,或者降低发送速度来避免这个问题.当然这是在使用Observable+Observer时的情况.</p>
<h3 id="Flowable"><a href="#Flowable" class="headerlink" title="Flowable"></a>Flowable</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123;</div><div class="line">                Log.d(TAG, &quot;emit 1&quot;);</div><div class="line">                emitter.onNext(1);</div><div class="line">                Log.d(TAG, &quot;emit 2&quot;);</div><div class="line">                emitter.onNext(2);</div><div class="line">                Log.d(TAG, &quot;emit 3&quot;);</div><div class="line">                emitter.onNext(3);</div><div class="line">                Log.d(TAG, &quot;emit complete&quot;);</div><div class="line">                emitter.onComplete();</div><div class="line">            &#125;</div><div class="line">        &#125;, BackpressureStrategy.ERROR).subscribe(new Subscriber&lt;Integer&gt;() &#123;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onSubscribe(Subscription s) &#123;</div><div class="line">                s.request(Long.MAX_VALUE);  //注意这句代码,同一个线程中,不request会报MissingBackpressureException异常</div><div class="line">                Log.d(TAG, &quot;onSubscribe&quot;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onNext(Integer integer) &#123;</div><div class="line">                Log.d(TAG, &quot;onNext: &quot; + integer);</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onError(Throwable t) &#123;</div><div class="line">                Log.w(TAG, &quot;onError: &quot;, t);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onComplete() &#123;</div><div class="line">                Log.d(TAG, &quot;onComplete&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>使用Flowable时,下游的onSubscribe方法中传给我们的不再是Disposable了, 而是Subscription, 它俩有什么区别呢, 首先它们都是上下游中间的一个开关, 之前我们说调用Disposable.dispose()方法可以切断水管, 同样的调用Subscription.cancel()也可以切断水管, 不同的地方在于Subscription增加了一个void request(long n)方法,不管在不在同一个线程,只有调用request才能收到数据.</p>
<p>使用Flowable时,如果上下游在同一个线程中,那么必须要调用request,否则会报MissingBackpressureException异常</p>
<p>如果不在同一个线程,那么发送数据会有一个缓冲区,大小为128,若存满后继续发送数据</p>
<p>这个时候要看设置Backpressure的strategy:</p>
<ul>
<li>BackpressureStrategy.ERROR 直接报错MissingBackpressureException</li>
<li>BackpressureStrategy.BUFFER 和Observable表现一致,可能会OOM</li>
<li>BackpressureStrategy.DROP 存不下的数据都丢了</li>
<li>BackpressureStrategy.LATEST 存满之后,一直会刷新最新的一个的数据</li>
</ul>
<p>如果不是自己创建的Flowable,可以通过以下方法设置策略:<br>onBackpressureBuffer()<br>onBackpressureDrop()<br>onBackpressureLatest()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">Flowable.interval(1, TimeUnit.MICROSECONDS)</div><div class="line">                .onBackpressureDrop()  //加上背压策略</div><div class="line">                .observeOn(AndroidSchedulers.mainThread())</div><div class="line">                .subscribe(new Subscriber&lt;Long&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void onSubscribe(Subscription s) &#123;</div><div class="line">                        Log.d(TAG, &quot;onSubscribe&quot;);</div><div class="line">                        mSubscription = s;</div><div class="line">                        s.request(Long.MAX_VALUE);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    @Override</div><div class="line">                    public void onNext(Long aLong) &#123;</div><div class="line">                        Log.d(TAG, &quot;onNext: &quot; + aLong);</div><div class="line">                        try &#123;</div><div class="line">                            Thread.sleep(1000);</div><div class="line">                        &#125; catch (InterruptedException e) &#123;</div><div class="line">                            e.printStackTrace();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    @Override</div><div class="line">                    public void onError(Throwable t) &#123;</div><div class="line">                        Log.w(TAG, &quot;onError: &quot;, t);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    @Override</div><div class="line">                    public void onComplete() &#123;</div><div class="line">                        Log.d(TAG, &quot;onComplete&quot;);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div></pre></td></tr></table></figure></p>
<p>Flowable本质是为了响应式拉取,同一个线程中上游可以拿到下游request的数量,request的值可以累加,每次发送事件之后request数量自动减少,当为0时,说明下游没有消耗事件的能力了,这个时候就不要发了,<br>再发就要报MissingBackpressureException异常了.</p>
<p>而在不同线程中,不管下游request多少个,上游拿到的都是128,我们在上游做判断,如果拿到的request值等于0时,证明缓冲区满了不能发了,当下游消耗掉第96个数据后,上游又可以拿到request值了,等于96,然后继续发.<br>至于为什么是96,源码就是这样写的.</p>
<p>用于验证的demo:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">public static void request() &#123;</div><div class="line">        mSubscription.request(96); //请求96个事件</div><div class="line">    &#125;</div><div class="line"></div><div class="line">public static void demo4() &#123;</div><div class="line">        Flowable</div><div class="line">                .create(new FlowableOnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123;</div><div class="line">                        Log.d(TAG, &quot;First requested = &quot; + emitter.requested());</div><div class="line">                        boolean flag;</div><div class="line">                        for (int i = 0; ; i++) &#123;</div><div class="line">                            flag = false;</div><div class="line">                            while (emitter.requested() == 0) &#123;</div><div class="line">                                if (!flag) &#123;</div><div class="line">                                    Log.d(TAG, &quot;Oh no! I can&apos;t emit value!&quot;);</div><div class="line">                                    flag = true;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                            emitter.onNext(i);</div><div class="line">                            Log.d(TAG, &quot;emit &quot; + i + &quot; , requested = &quot; + emitter.requested());</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;, BackpressureStrategy.ERROR)</div><div class="line">                .subscribeOn(Schedulers.io())</div><div class="line">                .observeOn(AndroidSchedulers.mainThread())</div><div class="line">                .subscribe(new Subscriber&lt;Integer&gt;() &#123;</div><div class="line"></div><div class="line">                    @Override</div><div class="line">                    public void onSubscribe(Subscription s) &#123;</div><div class="line">                        Log.d(TAG, &quot;onSubscribe&quot;);</div><div class="line">                        mSubscription = s;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    @Override</div><div class="line">                    public void onNext(Integer integer) &#123;</div><div class="line">                        Log.d(TAG, &quot;onNext: &quot; + integer);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    @Override</div><div class="line">                    public void onError(Throwable t) &#123;</div><div class="line">                        Log.w(TAG, &quot;onError: &quot;, t);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    @Override</div><div class="line">                    public void onComplete() &#123;</div><div class="line">                        Log.d(TAG, &quot;onComplete&quot;);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="RxJava实践搭配"><a href="#RxJava实践搭配" class="headerlink" title="RxJava实践搭配"></a>RxJava实践搭配</h2><p>Rxlifecycle 可以避免不当的使用导致的内存泄漏,基础Activity和Fragment可以继承于Rxlifecycle组件</p>
<p>经过观察发现,Rxlifecycle只是在Activity等退出后,发消息阻断数据向下的传递,并不能解决内存泄漏问题,要解决这个,还是要从源头上解决,在退出后要停止发送数据,这样才能释放内存.</p>
<p>Rxlifecycle在View退出后,会回调onComplete.</p>
<p>内存泄漏本质上是因为长周期的组件引用了短周期的组件,在短周期的组件结束后还没有释放,就产生了内存泄漏,关键点在于引用,跟Rxjava关系不大,因为在创建Observer或者其它类时,经常会采用匿名内部类的方式创建,而匿名内部类默认持有对外部类的引用(所以我们才能在匿名内部类中访问外部类的成员变量(应该是在编译期自动生成了getter和setter方法)),所以会导致内存泄漏.而在MVP模式中,一般在Presenter中进行Rxjava的使用,但是MVP也会持有Activity的引用,所以在Activity退出时一定要与Presenter解绑,这个时候引用就被切断了,但是Presenter本身也会内存泄漏啊,不要以为内存泄漏只存在于Activity等组件中,所以这个时候还是要切断发送数据源,这样才可以,而Rxlifecycle的作用仅仅只是在Activity退出后让发送出的数据不往下传递了而已,功能仅限于此(这样我们就不用手动View判空了,因为View被回收后这边消息已经传递不下来了,哈哈).</p>
<p>总结,什么是内存泄漏?一切对象该被回收的时候,由于各种意外状况导致该对象仍然被引用,就是内存泄漏.多么精辟的一句话啊!</p>
<p>并不是每一个订阅都要手动解除,当onComplete或onError时会自动解除订阅关系,说是解除订阅关系,其实只是消息阻断而已,中间加了判断,确定要不要继续将消息传递下去</p>
<p>Rxbinding帮助我们将View的行为转化为Observable数据源</p>
<p>ReplaySubject （释放接收到的所有数据）<br>BehaviorSubject （释放订阅前最后一个数据和订阅后接收到的所有数据）<br>PublishSubject （释放订阅后接收到的数据）<br>AsyncSubject （仅释放接收到的最后一个数据）<br>SerializedSubject（串行Subject）<br>UnicastSubject (仅支持订阅一次的Subject)<br>TestSubject（已废弃，在2.x中被TestScheduler和TestObserver替代）</p>
<p>takeUntil操作符:当第二个Observable发射了一项数据或者终止时，丢弃原Observable发射的任何数据。</p>
<p>takeUntil本质上第二个Observable发送了数据之后,会调用第一个Observable中的dispose和onComplete方法.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RxJava+Retrofit+OkHttp是最佳的网络请求实践，之前的项目中一直是使用Callback的方式进行网络请求，最近得空，引入了RxJava和Retrofit，重新封装了下项目的网络请求模块，不得不说，使用RxJava的响应式编程思想，面向数据流的编程方式，写出来的代码十分优美。&lt;br&gt;
    
    </summary>
    
    
      <category term="RxJava" scheme="https://forevas.github.io/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="https://forevas.github.io/2017/10/21/ThreadLocal/"/>
    <id>https://forevas.github.io/2017/10/21/ThreadLocal/</id>
    <published>2017-10-21T15:06:50.000Z</published>
    <updated>2018-05-21T15:14:01.312Z</updated>
    
    <content type="html"><![CDATA[<p>ThreadLocal实际上相当于一个工具类，我们使用ThreadLocal类就是和它打交道，本身并不存储什么，真正起作用的是内部类ThreadLocalMap。<br>ThreadLocal类作为Key存储在ThreadLocalMap中，通过ThreadLocal可以拿到存储的value值。<br><a id="more"></a></p>
<h4 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h4><p>ThreadLocal的静态内部类，每个Thread内部都有ThreadLocalMap的成员变量，我们在调用ThreadLocal.set()方法时，实际上会拿到当前线程的ThreadLocalMap成员变量，如果为空则去创建，不为空则进行变量保存。</p>
<p>ThreadLocalMap才是真正用来存储的工具，内部维持一个使用<strong>线性探测法</strong>实现的<strong>哈希表</strong>(不是拉链法)，初始数组长度为16，当数据达到2/3时进行扩容，每次增加一倍。</p>
<p>ThreadLocal的hash值在生成的过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private final int threadLocalHashCode = nextHashCode();</div><div class="line"></div><div class="line">/**</div><div class="line"> * The next hash code to be given out. Updated atomically. Starts at</div><div class="line"> * zero.</div><div class="line"> */</div><div class="line">private static AtomicInteger nextHashCode = new AtomicInteger();</div><div class="line"></div><div class="line">/**</div><div class="line"> * The difference between successively generated hash codes - turns</div><div class="line"> * implicit sequential thread-local IDs into near-optimally spread</div><div class="line"> * multiplicative hash values for power-of-two-sized tables.</div><div class="line"> */</div><div class="line">private static final int HASH_INCREMENT = 0x61c88647;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Returns the next hash code.</div><div class="line"> */</div><div class="line">private static int nextHashCode() &#123;</div><div class="line">    return nextHashCode.getAndAdd(HASH_INCREMENT);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述算法中使用0x61c88647可以让hash的结果在2的n次方内尽可能均匀分布，减少冲突的概率。</p>
<p>ThreadLocalMap的作用域是单个线程内，所以不存在线程间共享数据的问题，也不用考虑线程同步。</p>
<p>不要拿synchronized和ThreadLocal比，两者没有可比性，因为原理和用途完全不一致。</p>
<h4 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h4><p>存储的实体类，继承于WeakReference，对ThreadLocal进行弱引用，同时存储value。Entry实例被存在哈希表中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ThreadLocal实际上相当于一个工具类，我们使用ThreadLocal类就是和它打交道，本身并不存储什么，真正起作用的是内部类ThreadLocalMap。&lt;br&gt;ThreadLocal类作为Key存储在ThreadLocalMap中，通过ThreadLocal可以拿到存储的value值。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://forevas.github.io/tags/Java/"/>
    
      <category term="ThreadLocal" scheme="https://forevas.github.io/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>String原理解析</title>
    <link href="https://forevas.github.io/2017/10/15/String%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>https://forevas.github.io/2017/10/15/String原理解析/</id>
    <published>2017-10-15T15:03:42.000Z</published>
    <updated>2018-05-21T15:13:57.463Z</updated>
    
    <content type="html"><![CDATA[<p>String并不属于基本类型之一，其本质是字符数组。<br>String在java1.7之前底层是java的字符数组，1.8开始在native层进行处理。<br>String不可变，对外提供的方法最后会创建新的String对象，不会对原来的String本身造成影响。1.7以前可以通过反射修改String本身，1.8之后不可以。<br><a id="more"></a></p>
<h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p>为了减少在JVM中创建的字符串的数量，字符串类维护了一个字符串常量池，每当以字面值形式创建一个字符串时，JVM会首先检查字符串常量池：如果字符串已经存在池中，就返回池中的实例引用；如果字符串不在池中，就会实例化一个字符串并放到池中。Java能够进行这样的优化是因为字符串是不可 变的，可以不用担心数据冲突进行共享。</p>
<h5 id="手动入池"><a href="#手动入池" class="headerlink" title="手动入池"></a>手动入池</h5><p>使用intern方法可以进行手动入池操作，当调用 intern 方法时，如果池已经包含一个等于此 String 对象的字符串（用 equals(Object) 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并返回此 String 对象的引用。</p>
<p>对于任意两个字符串 s 和 t ，当且仅当 s.equals(t) 为 true 时，s.intern() == t.intern() 才为 true 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">String str1 = &quot;abc&quot;;</div><div class="line">String str2 = new String(&quot;abc&quot;);</div><div class="line">String str3 = s2.intern();</div><div class="line"></div><div class="line">System.out.println( str1 == str2 );   //false</div><div class="line">System.out.println( str1 == str3 );   //true</div></pre></td></tr></table></figure></p>
<h4 id="String创建方式的区别"><a href="#String创建方式的区别" class="headerlink" title="String创建方式的区别"></a>String创建方式的区别</h4><h5 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h5><p>以字面值方式创建一个String时，会先检查字符串常量池中是否有这个String，如有，则直接返回引用，如果没有，就实例化一个字符串放入池中。</p>
<h5 id="new-String-“”"><a href="#new-String-“”" class="headerlink" title="new String(“”)"></a>new String(“”)</h5><p>通过 new String(“…”) 来创建字符串时，在该构造函数的参数值为字符串字面值的前提下，若该字面值不在字符串常量池中，那么会创建两个对象：一个在字符串常量池中，一个在堆中；否则，只会在堆中创建一个对象。</p>
<h5 id="连接符-“-”"><a href="#连接符-“-”" class="headerlink" title="连接符 “+”"></a>连接符 “+”</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String str2 = &quot;ab&quot;;  //1个对象  </div><div class="line">String str3 = &quot;cd&quot;;  //1个对象                                         </div><div class="line">String str4 = str2+str3;                                        </div><div class="line">String str5 = &quot;abcd&quot;;    </div><div class="line">System.out.println(&quot;str4 = str5 : &quot; + (str4==str5)); // false</div></pre></td></tr></table></figure>
<p>在运行时，第三行代码(str2+str3)实质上会被分解成五个步骤，分别是：</p>
<p>　(1). 调用 String 类的静态方法 String.valueOf() 将 str2 转换为字符串表示；</p>
<p>　(2). JVM 在堆中创建一个 StringBuilder对象，同时用str2指向转换后的字符串对象进行初始化；　</p>
<p>　(3). 调用StringBuilder对象的append方法完成与str3所指向的字符串对象的合并；</p>
<p>　(4). 调用 StringBuilder 的 toString() 方法在堆中创建一个 String对象；</p>
<p>　(5). 将刚刚生成的String对象的堆地址存赋给局部变量引用str4。</p>
<p>使用连接符 “+” 循环连接大量字符串时，因为会默认创建大量的StringBuilder和String对象，所以会导致性能大幅度下降。</p>
<h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public boolean equals(Object anObject) &#123;</div><div class="line">        if (this == anObject) &#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        if (anObject instanceof String) &#123;</div><div class="line">            String anotherString = (String) anObject;</div><div class="line">            int n = length();</div><div class="line">            if (n == anotherString.length()) &#123;</div><div class="line">                int i = 0;</div><div class="line">                while (n-- != 0) &#123;</div><div class="line">                    if (charAt(i) != anotherString.charAt(i))</div><div class="line">                            return false;</div><div class="line">                    i++;</div><div class="line">                &#125;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h4><p>这两者区别在于StringBuffer默认线程同步，StringBuilder不是。</p>
<p>StringBuilder在创建时会创建一个字符数组，append方法会对数组进行扩容，然后将要append的String字符拷贝至数组的末尾，因此不会大量创建String方法，性能较高。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public AbstractStringBuilder append(String str) &#123;</div><div class="line">    if (str == null)</div><div class="line">        return appendNull();</div><div class="line">    int len = str.length();</div><div class="line">    ensureCapacityInternal(count + len);</div><div class="line">    str.getChars(0, len, value, count);</div><div class="line">    count += len;</div><div class="line">    return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="String与克隆"><a href="#String与克隆" class="headerlink" title="String与克隆"></a>String与克隆</h4><p>在克隆一个类时，其成员变量若是有String，则将String作为基本数据类型看待就好了，因为String本身是不可变的。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol>
<li>使用字面值形式创建的字符串与通过 new 创建的字符串一定是不同的，因为二者的存储位置不同：前者在方法区，后者在堆；</li>
<li>Java 编译器对 “常量+字面值” 的组合 是当成常量表达式直接求值来优化的；对于含有“String引用”的组合，其在编译期不能被确定，会在运行期创建新对象。</li>
<li>字符串常量池的理念是 《享元模式》；</li>
<li>Java 编译器对于类似“常量+字面值”的组合，其值在编译的时候就能够被确定了。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;String并不属于基本类型之一，其本质是字符数组。&lt;br&gt;String在java1.7之前底层是java的字符数组，1.8开始在native层进行处理。&lt;br&gt;String不可变，对外提供的方法最后会创建新的String对象，不会对原来的String本身造成影响。1.7以前可以通过反射修改String本身，1.8之后不可以。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://forevas.github.io/tags/Java/"/>
    
      <category term="String" scheme="https://forevas.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Java垃圾回收机制</title>
    <link href="https://forevas.github.io/2017/10/07/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>https://forevas.github.io/2017/10/07/Java垃圾回收机制/</id>
    <published>2017-10-07T14:55:45.000Z</published>
    <updated>2018-05-21T15:02:44.229Z</updated>
    
    <content type="html"><![CDATA[<p>Java相比于C++，其最显著的特点就是不需要我们手动去回收内存，一切交给GC线程在后台自动完成，我们可以专心于代码的逻辑设计，而不用在意内存回收的细节。那么Java是如何进行内存回收的？下面对于堆内存结构和垃圾回收的算法进行总结。<br><a id="more"></a></p>
<h3 id="Stop-the-world"><a href="#Stop-the-world" class="headerlink" title="Stop-the-world"></a>Stop-the-world</h3><p>除了GC线程之外的其它线程都停止执行，直到GC完成。GC优化很多时候就是指减少Stop-the-world发生的时间，从而使系统具有 高吞吐 、低停顿 的特点。</p>
<h3 id="如何判断对象是否可以回收"><a href="#如何判断对象是否可以回收" class="headerlink" title="如何判断对象是否可以回收"></a>如何判断对象是否可以回收</h3><h4 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1.引用计数法"></a>1.引用计数法</h4><p>通过判断一个对象的引用数量来决定对象是否可以被回收。</p>
<p>引用计数法很难解决对象之间循环引用问题。</p>
<h4 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2.可达性分析算法"></a>2.可达性分析算法</h4><p>通过判断对象的引用链是否可达来判断对象是否可以被回收。</p>
<p>当一个对象到GC Roots没有任何引用链相连(从GC Roots出发到这个对象不可达)，则说明这个对象是不可用的。</p>
<p>可作为GC Roots的对象有以下几种：</p>
<ol>
<li>虚拟机栈(栈帧中的局部变量表)中引用的对象；</li>
<li>方法区中类静态属性引用的对象；</li>
<li>方法区中常量引用的对象；</li>
<li>本地方法栈中Native方法引用的对象；</li>
</ol>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>从根集合进行扫描，将存活的对象标记，标记完毕后，扫描整个空间中未标记的对象进行清除。</p>
<p>缺点：</p>
<ol>
<li>效率低下：标记和清除两个过程效率都不高。</li>
<li>空间问题：不进行对象移动，产生大量不连续的内存碎片，空间利用率低。</li>
</ol>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>将内存划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p>这种算法适用于对象存活率低的场景，现在商用的虚拟机都使用这种方法来回收新生代，因为研究发现，新生代每次回收之后基本只有10%的对象存活。</p>
<p>实践中，新生代区域一般分为 <strong>eden</strong> 和两块 <strong>survivor(s0和s1)</strong> 区域。</p>
<p>每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。</p>
<p>Eden和s0,s1的比例为：8：1：1.</p>
<h4 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h4><p>老年代对象存活率较高，使用复制算法效率比较低，而且还浪费空间，因此需要使用标记整理算法。</p>
<p>标记整理算法第一阶段和标记清除算法类似，第二阶段则不同，标记整理算法会将存活的对象向内存的一端移动，然后清除掉边界以外的所有内存，类似于磁盘整理。</p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>不通对象的生命周期是不一样的，而不同生命周期的对象位于堆中不同的区域，对于不同区域采用不同的回收策略可以提高JVM的执行效率。</p>
<h5 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h5><p>新生代的目标就是尽可能快速的收集掉那些生命周期短的对象，一般情况下，所有新生成的对象首先都是放在新生代的，而且大部分对象在Eden区中生成。</p>
<p>新生代分为eden，s0,s1,比例为8:1:1，采用复制算法。每次GC，eden和一个survivor区域生存的对象会进入另一个survivor区域，当survivor区域满了之后，存活的对象会进入老年代。</p>
<p>如果老年代也满了，就会触发一次FullGC，也就是新生代、老年代都进行回收。注意，新生代发生的GC也叫做MinorGC，MinorGC发生频率比较高，不一定等Eden区满了才触发。</p>
<h5 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h5><p>老年代存放的都是一些生命周期较长的对象，在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。此外，老年代的内存也比新生代大很多(大概比例是1:2)，当老年代满时会触发Major GC(Full GC)，老年代对象存活时间比较长，因此FullGC发生的频率比较低。</p>
<p>老年代采用标记整理算法。</p>
<p>由于Full GC需要对整个堆进行回收，所以比Minor GC要慢，因此应该尽可能减少Full GC的次数，导致Full GC的原因包括：老年代被写满、永久代（Perm）被写满和System.gc()被显式调用等。</p>
<h5 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h5><p>永久代主要用于存放静态文件，如Java类、方法等。永久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如使用反射、动态代理、CGLib等bytecode框架时，在这种时候需要设置一个比较大的永久代空间来存放这些运行过程中新增的类。</p>
<p>永久代是Hotspot虚拟机特有的概念，是方法区的一种实现，别的JVM都没有这个东西。</p>
<p>在Java 8中，永久代被彻底移除，取而代之的是另一块与堆不相连的本地内存——元空间（Metaspace）,‑XX:MaxPermSize参数失去了意义，取而代之的是-XX:MaxMetaspaceSize。</p>
<p>方法区（method area）只是JVM规范中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，具体放在哪里，不同的实现可以放在不同的地方。</p>
<h4 id="垃圾处理器"><a href="#垃圾处理器" class="headerlink" title="垃圾处理器"></a>垃圾处理器</h4><p>Serial收集器（复制算法): 新生代单线程收集器</p>
<p>Serial Old收集器 (标记-整理算法): 老年代单线程收集器</p>
<p>ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</p>
<p>Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量</p>
<p>Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先</p>
<p>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</p>
<p>G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</p>
<h4 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h4><ol>
<li><p>对象优先在Eden分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC</p>
</li>
<li><p>大对象直接进入老年代</p>
</li>
<li><p>长期存活的对象将进入老年代</p>
</li>
<li><p>动态对象年龄判定</p>
</li>
</ol>
<h4 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h4><p>方法区的内存回收目标主要是针对 常量池的回收 和 对类型的卸载。</p>
<p>回收废弃常量与回收Java堆中的对象非常类似，通过引用判定即可。</p>
<p>判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”：</p>
<ul>
<li><p>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；</p>
</li>
<li><p>加载该类的ClassLoader已经被回收；</p>
</li>
<li><p>该类对应的 java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
</li>
</ul>
<p>虚拟机可以对满足上述3个条件的无用类进行回收(卸载)，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java相比于C++，其最显著的特点就是不需要我们手动去回收内存，一切交给GC线程在后台自动完成，我们可以专心于代码的逻辑设计，而不用在意内存回收的细节。那么Java是如何进行内存回收的？下面对于堆内存结构和垃圾回收的算法进行总结。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://forevas.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://forevas.github.io/tags/JVM/"/>
    
      <category term="GC" scheme="https://forevas.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存模型</title>
    <link href="https://forevas.github.io/2017/09/29/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://forevas.github.io/2017/09/29/JVM内存模型/</id>
    <published>2017-09-29T12:10:31.000Z</published>
    <updated>2018-05-21T14:56:17.957Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来，对于JVM的内部结构不是很清楚，最近看了一篇博客，写的很好，这里简单总结下。<br><a id="more"></a></p>
<h3 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h3><p>JVM内存可以划分为线程共享的区域和线程私有的区域。</p>
<p>共享区域有 <strong>方法区</strong> 和 <strong>堆</strong> ，私有区域有 <strong>虚拟机栈</strong> 、<strong>本地方法栈</strong> 和 <strong>程序计数器</strong>。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/852D185478C24971B0D3A17D930F399F?method=download&amp;shareKey=0dd3183138a5773fd7d8065c2eaec3b3" alt="JVM内存模型"></p>
<h4 id="线程私有的数据区"><a href="#线程私有的数据区" class="headerlink" title="线程私有的数据区"></a>线程私有的数据区</h4><h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h5><p>为解决线程切换后能恢复到正确的执行位置的问题，每条线程都需要一个独立的程序计数器去记录正在执行的字节码指令地址。</p>
<p>程序计数器是线程私有的一块较小的内存空间，可以看做当前线程所执行的字节码的行号指示器。</p>
<p>如果正在执行java代码，则记录的是正在执行的字节码指令的地址，如果是Native方法，计数器的值为空。</p>
<p>程序计数器是唯一一个没有规定任何 OutOfMemoryError 的区域。</p>
<h5 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h5><p>虚拟机栈描述的是Java方法执行的内存模型，每个方法在执行的时候都会创建一个栈帧，栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p>
<p>每个方法从调用直至完成的过程，对应一个栈帧在虚拟机栈中入栈到出栈的过程。其中，局部变量表主要存放一些基本类型的变量（int, short, long, byte, float, double, boolean, char）和 对象句柄，它们可以是方法参数，也可以是方法的局部变量。</p>
<h6 id="StackOverflowError"><a href="#StackOverflowError" class="headerlink" title="StackOverflowError"></a>StackOverflowError</h6><p>一个线程拥有一个自己的栈，这个栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法，-Xss参数可以设置虚拟机栈大小），若线程请求的栈深度大于虚拟机允许的深度，则抛出 StackOverFlowError 异常。</p>
<h6 id="OutofMemoryError"><a href="#OutofMemoryError" class="headerlink" title="OutofMemoryError"></a>OutofMemoryError</h6><p>栈的大小可以是固定的，也可以是动态扩展的，若虚拟机栈可以动态扩展（大多数虚拟机都可以），但扩展时无法申请到足够的内存(比如没有足够的内存为一个新创建的线程分配栈空间时)，则抛出 OutofMemoryError 异常。下图为栈帧结构图：<br><img src="https://note.youdao.com/yws/api/personal/file/9915DABBF48E4016A2C20B8D00279548?method=download&amp;shareKey=5a6407200b93ab521ea17f2681a83b2b" alt="栈帧"></p>
<h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h5><p>本地方法栈与Java虚拟机栈非常相似，也是线程私有的，区别是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈为虚拟机执行Native方法服务。与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常。</p>
<h4 id="线程共享的数据区"><a href="#线程共享的数据区" class="headerlink" title="线程共享的数据区"></a>线程共享的数据区</h4><h5 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h5><p>也可以称为GC堆，我们new的对象都在这个区域，所有线程共享此区域。<br><img src="https://note.youdao.com/yws/api/personal/file/09EFE46F567C4E08B56863700FB4D1EE?method=download&amp;shareKey=5975b0e2070e3bd7cbf993dda98beb3f" alt="堆结构"></p>
<p>Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。而且，Java堆在实现时，既可以是固定大小的，也可以是可拓展的，并且主流虚拟机都是按可扩展来实现的（通过-Xmx(最大堆容量) 和 -Xms(最小堆容量)控制）。如果在堆中没有内存完成实例分配，并且堆也无法再拓展时，将会抛出 OutOfMemoryError 异常。</p>
<h6 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h6><p>TLAB可以提升内存分配效率，每个线程都要一块独立的空间TLAB，在TLAB上分配对象时不需要加锁(相对于CAS配上失败重试方式)，因此JVM在给线程的对象分配内存时会尽量的在TLAB上分配，在这种情况下JVM中分配对象内存的性能和C基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配。</p>
<p>虚拟机为新生对象分配内存时，需要考虑修改指针(该指针用于划分内存使用空间和空闲空间)时的线程安全问题，因为存在可能出现正在给对象A分配内存，指针还未修改，对象B又同时使用原来的指针分配内存的情况。TLAB的存在就是为了解决这个问题：每个线程在Java堆中预先分配一小块内存TLAB，哪个线程需要分配内存就在自己的TLAB上进行分配，若TLAB用完并分配新的TLAB时，再加同步锁定，这样就大大提升了对象内存分配的效率。</p>
<h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><p>方法区与Java堆一样，也是线程共享的并且不需要连续的内存，其用于存储已被虚拟机加载的 类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<h6 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h6><p>运行时常量池（RuntimeConstantPool）是方法区的一部分，用于存放编译期生成的各种 字面量 和 符号引用。</p>
<h5 id="Java堆-与-方法区的区别"><a href="#Java堆-与-方法区的区别" class="headerlink" title="Java堆 与 方法区的区别"></a>Java堆 与 方法区的区别</h5><p>Java堆是 Java代码可及的内存，是留给开发人员使用的；而非堆（Non-Heap）是JVM留给自己用的。</p>
<p>方法区、JVM内部处理或优化所需的内存 (如JIT编译后的代码缓存)、每个类结构 (如运行时常量池、字段和方法数据)以及方法和构造方法的代码都在非堆内存中。</p>
<h5 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h5><p>常量池的回收 和 对类型的卸载。</p>
<h4 id="对象在虚拟机中的创建过程"><a href="#对象在虚拟机中的创建过程" class="headerlink" title="对象在虚拟机中的创建过程"></a>对象在虚拟机中的创建过程</h4><h5 id="1-检查虚拟机是否加载了所要new的类，若没加载，则首先执行相应的类加载过程"><a href="#1-检查虚拟机是否加载了所要new的类，若没加载，则首先执行相应的类加载过程" class="headerlink" title="1.检查虚拟机是否加载了所要new的类，若没加载，则首先执行相应的类加载过程"></a>1.检查虚拟机是否加载了所要new的类，若没加载，则首先执行相应的类加载过程</h5><h5 id="2-在类加载检查通过后，对象所需内存的大小在类加载完成后便可完全确定，虚拟机就会为新生对象分配内存。"><a href="#2-在类加载检查通过后，对象所需内存的大小在类加载完成后便可完全确定，虚拟机就会为新生对象分配内存。" class="headerlink" title="2.在类加载检查通过后，对象所需内存的大小在类加载完成后便可完全确定，虚拟机就会为新生对象分配内存。"></a>2.在类加载检查通过后，对象所需内存的大小在类加载完成后便可完全确定，虚拟机就会为新生对象分配内存。</h5><p>内存的分配有两种方式：</p>
<ul>
<li>指针碰撞：如果Java堆中内存绝对规整</li>
<li>空闲列表：如果Java堆中内存并不规整</li>
</ul>
<p>修改指针 (该指针用于划分内存使用空间和空闲空间)时的线程安全问题：</p>
<ul>
<li>对分配内存空间的动作进行同步处理：采用CAS+失败重试的方式保证更新操作的原子性；</li>
<li>把内存分配的动作按照线程划分的不同的空间中：每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），哪个线程要分配内存，就在自己的TLAB上分配，如果TLAB用完并分配新的TLAB时，再加同步锁定。</li>
</ul>
<h5 id="3-内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值"><a href="#3-内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值" class="headerlink" title="3.内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值"></a>3.内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值</h5><h5 id="4-在上面的工作完成之后，从虚拟机的角度来看，一个新的对象已经产生了，但从Java程序的视角来看，对象的创建才刚刚开始，此时会执行方法把对象按照程序员的意愿进行初始化，从而产生一个真正可用的对象。"><a href="#4-在上面的工作完成之后，从虚拟机的角度来看，一个新的对象已经产生了，但从Java程序的视角来看，对象的创建才刚刚开始，此时会执行方法把对象按照程序员的意愿进行初始化，从而产生一个真正可用的对象。" class="headerlink" title="4.在上面的工作完成之后，从虚拟机的角度来看，一个新的对象已经产生了，但从Java程序的视角来看，对象的创建才刚刚开始，此时会执行方法把对象按照程序员的意愿进行初始化，从而产生一个真正可用的对象。"></a>4.在上面的工作完成之后，从虚拟机的角度来看，一个新的对象已经产生了，但从Java程序的视角来看，对象的创建才刚刚开始，此时会执行<init>方法把对象按照程序员的意愿进行初始化，从而产生一个真正可用的对象。</init></h5><h4 id="对象在虚拟机中的访问定位"><a href="#对象在虚拟机中的访问定位" class="headerlink" title="对象在虚拟机中的访问定位"></a>对象在虚拟机中的访问定位</h4><p>句柄访问和直接指针访问</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://blog.csdn.net/justloveyou_/article/details/71189093" target="_blank" rel="external">https://blog.csdn.net/justloveyou_/article/details/71189093</a><br>——文中图片引用自CSDN</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直以来，对于JVM的内部结构不是很清楚，最近看了一篇博客，写的很好，这里简单总结下。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://forevas.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://forevas.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java Throwable体系</title>
    <link href="https://forevas.github.io/2017/09/23/Java-Throwable%E4%BD%93%E7%B3%BB/"/>
    <id>https://forevas.github.io/2017/09/23/Java-Throwable体系/</id>
    <published>2017-09-23T13:15:32.000Z</published>
    <updated>2018-05-21T14:45:54.110Z</updated>
    
    <content type="html"><![CDATA[<p>本篇对Java Throwable体系进行梳理，同时讨论下try-catch和return的执行顺序。<br><a id="more"></a></p>
<h4 id="Throwable体系"><a href="#Throwable体系" class="headerlink" title="Throwable体系"></a>Throwable体系</h4><p><img src="https://note.youdao.com/yws/api/personal/file/A443DD2D046B433A9DBCFDC58A9703F0?method=download&amp;shareKey=2aac7db38a07017748777c3be7bdccfe" alt="Throwable体系"></p>
<h4 id="Exception和Error"><a href="#Exception和Error" class="headerlink" title="Exception和Error"></a>Exception和Error</h4><p>因为在java中，能通过代码处理的我们叫做Exception，而我们不能处理的叫做Error。</p>
<p>Error指的是那些例如：JVM运行错误，栈空间用尽，类定义错误等等非常严重的问题。一旦出现错误，我们不能通过代码进行处理，所以编码要注意避免Error。</p>
<p>Exception我们是可以通过try-catch处理的，即使发生了Exception我们也可以通过适当的处理来保持程序正常的运行。</p>
<h4 id="运行时异常-RuntimeException-和非运行时异常"><a href="#运行时异常-RuntimeException-和非运行时异常" class="headerlink" title="运行时异常(RuntimeException)和非运行时异常"></a>运行时异常(RuntimeException)和非运行时异常</h4><p>运行时异常是没办法预料的，例如NullPointerException，IndexOutOfBoundsException,ClassCastException,OutOfMemoryException,IllegalArgumentException 等等，编译器发现不了也不会提醒，只有在运行期才会出现，不过我们可以主动try-catch来处理异常。</p>
<p>非运行时时显而易见可能会出错的，编译器会提前提醒我们要对非运行时异常进行处理，try-catch或者声明throws都可以，例如IOException，FileNotFoundExcetion，SQLException，NoSuchMethodException ，InvocationTargetException等等。</p>
<p>我们在throw Exception的时候，如果throw的是RuntimeExcepiton，那么编译器不会提醒我们进行任何处理，但若是非运行时异常则会提醒我们try-catch或者声明throws。</p>
<h4 id="try-catch和return"><a href="#try-catch和return" class="headerlink" title="try-catch和return"></a>try-catch和return</h4><p>不管是在try中return，还是在catch中return，都会在return之前执行finally的代码。</p>
<p>return要是返回一个表达式，则会在表达式运算完成之后才执行finally的代码。</p>
<p>若在finally之中有return，则直接return。</p>
<p>注意throw Exception的时候是直接返回，其它什么代码都不会执行的。</p>
<p>还有System.exit(0)也是什么都不执行的，虚拟机都退出了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇对Java Throwable体系进行梳理，同时讨论下try-catch和return的执行顺序。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://forevas.github.io/tags/Java/"/>
    
      <category term="Throwable" scheme="https://forevas.github.io/tags/Throwable/"/>
    
  </entry>
  
  <entry>
    <title>Java注解</title>
    <link href="https://forevas.github.io/2017/09/21/Java%E6%B3%A8%E8%A7%A3/"/>
    <id>https://forevas.github.io/2017/09/21/Java注解/</id>
    <published>2017-09-21T14:34:29.000Z</published>
    <updated>2018-05-21T14:44:17.079Z</updated>
    
    <content type="html"><![CDATA[<p>Java注解平时使用的较少，不过可以看到，很多三方库中大量的使用Java注解进行代码的解耦。这里总结下Java注解的用法，以后在代码中还是要多多使用，增加熟练度。<br><a id="more"></a></p>
<h3 id="元注解-meta-annotation"><a href="#元注解-meta-annotation" class="headerlink" title="元注解(meta-annotation)"></a>元注解(meta-annotation)</h3><p>注解的注解,可以用来注解普通注解,常用于自定义注解</p>
<h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p>这个元注解用于声明注解的适用范围,使用方法为@Target(ElementType.TYPE)<br>type共有七种:</p>
<ol>
<li>ElemenetType.CONSTRUCTOR 构造器声明</li>
<li>ElemenetType.FIELD 域声明(包括 enum 实例)</li>
<li>ElemenetType.LOCAL_VARIABLE 局部变量声明</li>
<li>ElemenetType.METHOD 方法声明</li>
<li>ElemenetType.PACKAGE 包声明</li>
<li>ElemenetType.PARAMETER 参数声明</li>
<li>ElemenetType.TYPE 类，接口(包括注解类型)或enum声明</li>
</ol>
<h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p>这个注解用来描述注解保留的时间,使用方法为@Retention(RetentionPolicy.RUNTIME)</p>
<ol>
<li>SOURCE:  Annotation只保留在原代码中，当编译器编译的时候就会抛弃它。（即源文件保留）</li>
<li>CLASS:   编译器将把Annotation记录在Class文件中，不过当java程序执行的时候，JVM将抛弃它。（即class保留）</li>
<li>RUNTIME: 在Retationpolicy.CLASS的基础上，JVM执行的时候也不会抛弃它，所以我们一般在程序中可以通过反射来获得这个注解，然后进行处理。</li>
</ol>
<h4 id="Document"><a href="#Document" class="headerlink" title="@Document"></a>@Document</h4><p>Document标记这个注解应该被javadoc工具记录。默认情况下，Javadoc是不包括注解的。</p>
<h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>Inherited译为可继承的，如果一个使用了@Inherited 修饰的 annotation类型 被用于一个 class，则这个 annotation 将被用于该class的子类。</p>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>注解不能继承或者实现其它注解或者接口.<br>@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法名称为参数名称,返回值类型就是参数类型.可使用default指定参数的默认值.</p>
<p>注解可以定义多个方法,传入多个参数时可以这样,例如:</p>
<p>@Field(value = “tags”,encoded = false)</p>
<h5 id="Retention-SOURCE"><a href="#Retention-SOURCE" class="headerlink" title="@Retention(SOURCE)"></a>@Retention(SOURCE)</h5><p>源码注解(RetentionPolicy.SOURCE)的生命周期只存在Java源文件这一阶段，是3种生命周期中最短的注解。基本无需刻意去做处理，如@InDef、@StringDef等</p>
<h5 id="Retention-Class"><a href="#Retention-Class" class="headerlink" title="@Retention(Class)"></a>@Retention(Class)</h5><p>使用APT去处理注解</p>
<h5 id="Retention-RunTime"><a href="#Retention-RunTime" class="headerlink" title="@Retention(RunTime)"></a>@Retention(RunTime)</h5><p>生命周期最长通常可以使用反射，也可以使用自定义注解器</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java注解平时使用的较少，不过可以看到，很多三方库中大量的使用Java注解进行代码的解耦。这里总结下Java注解的用法，以后在代码中还是要多多使用，增加熟练度。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://forevas.github.io/tags/Java/"/>
    
      <category term="Annotation" scheme="https://forevas.github.io/tags/Annotation/"/>
    
  </entry>
  
  <entry>
    <title>开发技巧</title>
    <link href="https://forevas.github.io/2017/09/15/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    <id>https://forevas.github.io/2017/09/15/开发技巧/</id>
    <published>2017-09-15T14:29:06.000Z</published>
    <updated>2018-05-21T14:31:16.824Z</updated>
    
    <content type="html"><![CDATA[<p>在Android开发的过程中，有很多开源库或者小工具很实用，能大大的提高开发效率，这里总结下。<br><a id="more"></a></p>
<h4 id="接口调试"><a href="#接口调试" class="headerlink" title="接口调试"></a>接口调试</h4><h5 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h5><p>可以使用Postman工具测试接口，模拟发送请求，灵活度很高，缺点是要手动配置参数，不太方便。</p>
<h5 id="stetho"><a href="#stetho" class="headerlink" title="stetho"></a>stetho</h5><p>也可以使用OkHttp+stetho+Chrome调试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">compile &apos;com.facebook.stetho:stetho:1.5.0&apos;</div><div class="line">compile &apos;com.facebook.stetho:stetho-okhttp3:1.5.0&apos;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stetho.initializeWithDefaults(this);//在Application中配置</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.addNetworkInterceptor(new StethoInterceptor()) //在OkHttpClient初始化的时候配置</div></pre></td></tr></table></figure>
<p>然后在Chrome中打开<strong>chrome://inspect</strong>即可监听到所有的网络请求。</p>
<p>这种方式比较便捷，但是暂时只能用于监听，且必须连接USB，上线的时候要去掉这些配置。</p>
<h5 id="fidder"><a href="#fidder" class="headerlink" title="fidder"></a>fidder</h5><p>还有一种就是通过电脑端的fidder进行代理，然后抓包查看数据，fidder可以模拟弱网环境。</p>
<h4 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h4><p>findViewById，setOnClickListener这种操作可用ButterKnife一键完成<br>JavaBean，序列化，getter，setter，toString等操作都可通过android studio自带的工具一键生成</p>
<h4 id="Json格式化"><a href="#Json格式化" class="headerlink" title="Json格式化"></a>Json格式化</h4><p>chrome插件JSON-handle很好用</p>
<h4 id="性能优化工具"><a href="#性能优化工具" class="headerlink" title="性能优化工具"></a>性能优化工具</h4><p>打开android studio-&gt;tools-&gt;android-&gt;android device monitor<br>可使用:dumpsys、Systrace、TraceView、Update Threads（更新线程）、Update Heap（更新堆）、Allocation Tracker（分配跟踪器）等工具</p>
<p>关于Systrace,TraceView</p>
<p>参考链接:<a href="http://blog.csdn.net/xiyangyang8/article/details/50545707" target="_blank" rel="external">http://blog.csdn.net/xiyangyang8/article/details/50545707</a></p>
<p>android device monitor:<br>Update Heap 查看堆分配信息</p>
<p>Dump HPROF file和Allocation Tracker的功能可直接在android studio的Android Monitor中使用,分别是Dump Java Heap和Start Allocation Tracing.</p>
<p>Update Thread 查看所有线程的状态</p>
<p>Start Method Profiling 点击开始,再次点击结束,查看分析结果(TraceView)</p>
<p>dump View Hierarchy for UI automator 可查看界面的布局层次结构(连第三方应用也可查看,很叼)</p>
<p>Capture system wide trace using android systrace 生成分析结果,通过chrome查看(Systrace)</p>
<p>Trace OpenGL calls:暂未清楚用途</p>
<p>lint工具可以进行代码的扫描和分析,帮助我们发现代码结构/质量问题.</p>
<p>Lint 会根据预先配置的检测标准检查我们 Android 项目的源文件，发现潜在的 bug 或者可以优化的地方，优化的内容主要包括以下几方面：</p>
<p>Correctness：不够完美的编码，比如硬编码、使用过时 API 等</p>
<p>Performance：对性能有影响的编码，比如：静态引用，循环引用等</p>
<p>Internationalization：国际化，直接使用汉字，没有使用资源引用等</p>
<p>Security：不安全的编码，比如在 WebView 中允许使用 JavaScriptInterface 等<br>…</p>
<p>查找无用的资源文件,android studio在Analyze栏下使用lint工具.</p>
<p>例如常用的查找无用的资源文件可通过,Analyze-&gt;Run Inspection by Name-&gt;unused resources.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Android开发的过程中，有很多开源库或者小工具很实用，能大大的提高开发效率，这里总结下。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://forevas.github.io/tags/Android/"/>
    
      <category term="小技巧" scheme="https://forevas.github.io/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>模块化,组件化,插件化</title>
    <link href="https://forevas.github.io/2017/09/01/%E6%A8%A1%E5%9D%97%E5%8C%96-%E7%BB%84%E4%BB%B6%E5%8C%96-%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    <id>https://forevas.github.io/2017/09/01/模块化-组件化-插件化/</id>
    <published>2017-09-01T14:19:06.000Z</published>
    <updated>2018-05-21T14:27:36.861Z</updated>
    
    <content type="html"><![CDATA[<p>在编程之初，相信每个人都有按照功能分包的意识，这就是最简单的模块化，而随着项目越来越大，代码逻辑越来越复杂，维护起来十分麻烦。因而组件化，插件化等技术慢慢的发展了起来，本文主要总结下自己对于模块化、组件化、插件化等概念的认识。<br><a id="more"></a></p>
<h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>根据功能或者业务进行划分模块,例如网络请求模块,图片加载模块,登录模块，模块化相互之间存在依赖关系</p>
<h4 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h4><p>根据业务逻辑划分,多个module,debug时可编译为多个apk,release时可编译为多个Library,可在gradle中配置debug和release的相关参数.组件间需要采用隐式通信</p>
<p>解决问题:</p>
<ol>
<li>用于项目过大，每次编译时间长</li>
<li>用于团队多个人分工开发不同的模块</li>
<li>解耦,便于维护</li>
</ol>
<p>在进行组件化开发时，首先需要进行基础模块和业务模块的划分，基础功能包括基础网络请求，图片加载，播放器等等，这些功能模块是所有业务模块的通用基础库。而我们进行的组件化开发，则是针对业务模块进行的。将业务拆分成一个个独立的模块，在开发时以独立app进行，整合时则作为lib进行。业务模块之间的页面跳转可以通过Route等开源框架实现，或者自己实现也可以。业务模块之间的数据通信，主要是通过Intent传值，ContentProvider，广播等形式进行。</p>
<h4 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h4><p>将各个功能拆分成独立的插件,可下载插件扩展功能,主要技术难点是动态加载</p>
<p>解决问题</p>
<ol>
<li>解决方法数超过65536问题</li>
<li>按照需要下载模块，减小项目apk的大小</li>
</ol>
<h4 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h4><p>主要原理和插件化差不多,都是动态加载,区别热更新是要做到bug类的替换和修复<br>常用操作为:资源替换,类替换,So库替换</p>
<p>Tinker,AndFix…</p>
<p>解决问题:</p>
<ol>
<li>线上修复bug,一般不用于新功能的上线</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在编程之初，相信每个人都有按照功能分包的意识，这就是最简单的模块化，而随着项目越来越大，代码逻辑越来越复杂，维护起来十分麻烦。因而组件化，插件化等技术慢慢的发展了起来，本文主要总结下自己对于模块化、组件化、插件化等概念的认识。&lt;br&gt;
    
    </summary>
    
    
      <category term="模块化" scheme="https://forevas.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
      <category term="组件化" scheme="https://forevas.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
      <category term="插件化" scheme="https://forevas.github.io/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL Es学习总结</title>
    <link href="https://forevas.github.io/2017/08/21/OpenGL-Es%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://forevas.github.io/2017/08/21/OpenGL-Es学习总结/</id>
    <published>2017-08-21T13:27:55.000Z</published>
    <updated>2018-05-21T14:17:58.788Z</updated>
    
    <content type="html"><![CDATA[<p>OpenGL ES是OpenGL的子集,针对嵌入式系统和移动设备所设计.<br><a id="more"></a></p>
<h4 id="OpenGL-ES-管道-Pipeline"><a href="#OpenGL-ES-管道-Pipeline" class="headerlink" title="OpenGL ES 管道(Pipeline)"></a>OpenGL ES 管道(Pipeline)</h4><ol>
<li>管道“工序”大致可以分为 Transformation Stage 和 Rasterization Stage 两大步。</li>
<li>OpenGL ES 支持的基本图形为 点 Point, 线 Line, 和三角形 Triangle ，其它所有复制图形都是通过这几种基本几何图形组合而成。</li>
<li>在发出绘图指令后，会对顶点(Vertices)数组进行指定的坐标变换或光照处理。</li>
<li>顶点处理完成后，通过 Rasterizer 来生成像素信息，称为”Fragments“ 。</li>
<li>对于 Fragment 在经过 Texture Processing, Color Sum ,Fog 等处理并将最终处理结果存放在内存中（称为FrameBuffer)。<br>OpenGL 2.0可以通过编程来修改蓝色的步骤，称为 Programmable Shader.</li>
</ol>
<h4 id="GLSurfaceView"><a href="#GLSurfaceView" class="headerlink" title="GLSurfaceView:"></a>GLSurfaceView:</h4><p>setDebugFlags(int) 设置 Debug 标志。</p>
<p>setEGLConfigChooser (boolean) 选择一个 Config 接近 16bitRGB 颜色模式，可以打开或关闭深度(Depth)Buffer ,缺省为RGB_565 并打开至少有 16bit 的 depth Buffer。</p>
<p>setEGLConfigChooser(EGLConfigChooser) 选择自定义 EGLConfigChooser。</p>
<p>setEGLConfigChooser(int, int, int, int, int, int) 指定 red ,green, blue, alpha, depth ,stencil 支持的位数，缺省为 RGB_565 ,16 bit depth buffer。</p>
<p>GLSurfaceView 缺省创建为 RGB_565 颜色格式的 Surface，如果需要支持透明度，可以调用 getHolder().setFormat(PixelFormat.TRANSLUCENT)。</p>
<p>GLSurfaceView 的渲染模式有两种，一种是连续不断的更新屏幕，另一种为 on-demand ，只有在调用 requestRender() 在更新屏幕。 缺省为 RENDERMODE_CONTINUOUSLY 持续刷新屏幕。</p>
<h5 id="GLSurfaceView-Renderer回调方法"><a href="#GLSurfaceView-Renderer回调方法" class="headerlink" title="GLSurfaceView.Renderer回调方法:"></a>GLSurfaceView.Renderer回调方法:</h5><p>onSurfaceCreated：在这个方法中主要用来设置一些绘制时不常变化的参数，比如：背景色，是否打开 z-buffer等。</p>
<p>onDrawFrame：定义实际的绘图操作。</p>
<p>onSurfaceChanged：如果设备支持屏幕横向和纵向切换，这个方法将发生在横向和纵向互换时。此时可以重新设置绘制的纵横比率。</p>
<h4 id="OpenGL-坐标系"><a href="#OpenGL-坐标系" class="headerlink" title="OpenGL 坐标系"></a>OpenGL 坐标系</h4><p>三维坐标系，原点在中间，x 轴向右，y 轴向上，z 轴朝向我们，x y z 取值范围都是 [-1, 1]</p>
<p>OpenGL ES支持的图形有 点,线,三角形</p>
<p>先定义点集(vertexArray)(三个坐标一组,一维数组)<br>indices 为绘制顺序</p>
<p>eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">float[] vertexArray = new float[]&#123;</div><div class="line"> -0.8f , -0.4f * 1.732f , 0.0f ,</div><div class="line"> 0.8f , -0.4f * 1.732f , 0.0f ,</div><div class="line"> 0.0f , 0.4f * 1.732f , 0.0f ,</div><div class="line"> &#125;;</div><div class="line">ByteBuffer vbb = ByteBuffer.allocateDirect(vertexArray.length*4);</div><div class="line">vbb.order(ByteOrder.nativeOrder());</div><div class="line">FloatBuffer vertex = vbb.asFloatBuffer();</div><div class="line">vertex.put(vertexArray);</div><div class="line">vertex.position(0);</div></pre></td></tr></table></figure></p>
<p>glEnableClientState 和 glDisableClientState 可以控制的 pipeline 开关可以有：GL_COLOR_ARRAY (颜色），GL_NORMAL_ARRAY (法线)，<br>GL_TEXTURE_COORD_ARRAY (材质)，GL_VERTEX_ARRAY(顶点)， GL_POINT_SIZE_ARRAY_OES等。</p>
<p>在打开顶点开关后，将顶点坐标传给 OpenGL 管道的方法为：glVertexPointer：</p>
<p>对应的传入颜色，顶点，材质，法线的方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">glColorPointer(int size,int type,int stride,Buffer pointer)</div><div class="line">glVertexPointer(int size, int type, int stride, Buffer pointer)</div><div class="line">glTexCoordPointer(int size, int type, int stride, Buffer pointer)</div><div class="line">glNormalPointer(int type, int stride, Buffer pointer)</div><div class="line"></div><div class="line">public abstract void glDrawArrays(int mode, int first, int count)   使用VetexBuffer 来绘制，顶点的顺序由vertexBuffer中的顺序指定。</div><div class="line">public abstract void glDrawElements(int mode, int count, int type, Buffer indices)  ，可以重新定义顶点的顺序，顶点的顺序由indices Buffer 指定。</div><div class="line"></div><div class="line">TRIANGLES,TRIANGLE_STRIP,TRIANGLE_FAN代表三种绘制三角形的方式.</div></pre></td></tr></table></figure></p>
<h4 id="矩阵操作，单位矩阵"><a href="#矩阵操作，单位矩阵" class="headerlink" title="矩阵操作，单位矩阵"></a>矩阵操作，单位矩阵</h4><p>在进行平移，旋转，缩放变换时，所有的变换都是针对当前的矩阵（与当前矩阵相乘），如果需要将当前矩阵回复最初的无变换的矩阵，可以使用单位矩阵（无平移，缩放，旋转）。</p>
<p>public abstract void glLoadIdentity()。</p>
<p>在栈中保存当前矩阵和从栈中恢复所存矩阵，可以使用</p>
<p>public abstract void glPushMatrix()</p>
<p>和</p>
<p>public abstract void glPopMatrix()。</p>
<p>在进行坐标变换的一个好习惯是在变换前使用glPushMatrix保存当前矩阵，完成坐标变换操作后，再调用glPopMatrix恢复原先的矩阵设置。</p>
<p>glLoadIdentity()将栈顶矩阵恢复为单位矩阵</p>
<p>glPushMatrix()入栈一个栈顶矩阵的copy</p>
<p>glPopMatrix()栈顶矩阵出栈,之前栈顶第二个矩阵变成当前矩阵</p>
<p>我们一直使用的都是栈顶矩阵,栈内至少有一个矩阵</p>
<p>这种入栈出栈的操作是为了保存矩阵的状态,消除当前矩阵的变换对下一组图形变化的影响(理解矩阵变化对空间的影响).</p>
<h4 id="Texture纹理"><a href="#Texture纹理" class="headerlink" title="Texture纹理"></a>Texture纹理</h4><ol>
<li><p>创建Bitmap对象:<br>Bitmap bitmap = BitmapFactory.decodeResource(contect.getResources(),R.drawable.icon);</p>
</li>
<li><p>创建材质(Generating a texture):<br>使用OpenGL库创建一个材质(Texture)，首先是获取一个Texture Id。<br>// Create an int array with the number of textures we want,<br>// in this case 1.<br>int[] textures = new int[1];<br>// Tell OpenGL to generate textures.<br>gl.glGenTextures(1, textures, 0);<br>有了Texture Id之后，就可以通知OpenGL库使用这个Texture：<br>gl.glBindTexture(GL10.GL_TEXTURE_2D, textures[0]);</p>
</li>
<li><p>设置Texture参数glTexParameter:<br>用来渲染的Texture可能比要渲染的区域大或者小，这是需要设置Texture需要放大或是缩小时OpenGL的模式：<br>// Scale up if the texture if smaller.<br>gl.glTexParameterf(GL10.GL_TEXTURE_2D,GL10.GL_TEXTURE_MAG_FILTER,GL10.GL_LINEAR);<br>// scale linearly when image smalled than texture<br>gl.glTexParameterf(GL10.GL_TEXTURE_2D,GL10.GL_TEXTURE_MIN_FILTER,GL10.GL_LINEAR);</p>
</li>
<li><p>UV Mapping<br>纹理坐标系为左上(0,0),右下(1,1)</p>
</li>
</ol>
<p>默认纹理图片的宽高都是1</p>
<p>textureCoordinates[]用来记录纹理坐标点的映射顺序(注意这里的坐标点可以大于或者小于1,起到缩放和放大的效果),用来和vertex[]进行映射,这样才能知道如何将纹理贴到平面上去<br>float textureCoordinates[] = {0.0f, 2.0f,2.0f, 2.0f,0.0f, 0.0f,2.0f, 0.0f };</p>
<p>GL_REPEAT 重复Texture。<br>GL_CLAMP_TO_EDGE 只靠边线绘制一次。</p>
<p>对应代码:<br>gl.glTexParameterf(GL10.GL_TEXTURE_2D,GL10.GL_TEXTURE_WRAP_S,GL10.GL_REPEAT);<br>gl.glTexParameterf(GL10.GL_TEXTURE_2D,GL10.GL_TEXTURE_WRAP_T,GL10.GL_REPEAT);<br>然后是将Bitmap资源和Texture绑定起来：<br>GLUtils.texImage2D(GL10.GL_TEXTURE_2D, 0, bitmap, 0);</p>
<ol>
<li><p>使用Texture<br>为了能够使用上面定义的Texture，需要创建一Buffer来存储UV坐标：<br>FloatBuffer byteBuf = ByteBuffer.allocateDirect(textureCoordinates.length * 4);<br>byteBuf.order(ByteOrder.nativeOrder());<br>textureBuffer = byteBuf.asFloatBuffer();<br>textureBuffer.put(textureCoordinates);<br>textureBuffer.position(0);</p>
</li>
<li><p>渲染<br>// Telling OpenGL to enable textures.<br>gl.glEnable(GL10.GL_TEXTURE_2D);<br>// Tell OpenGL where our texture is located.<br>gl.glBindTexture(GL10.GL_TEXTURE_2D, textures[0]);<br>// Tell OpenGL to enable the use of UV coordinates.<br>gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);<br>// Telling OpenGL where our UV coordinates are.<br>gl.glTexCoordPointer(2, GL10.GL_FLOAT, 0, textureBuffer);</p>
</li>
</ol>
<p>// … here goes the rendering of the mesh …</p>
<p>// Disable the use of UV coordinates.<br>gl.glDisableClientState(GL10.GL_TEXTURE_COORD_ARRAY);<br>// Disable the use of textures.<br>gl.glDisable(GL10.GL_TEXTURE_2D);</p>
<p>多个矩阵变换,实际顺序和写的顺序其实是相反的</p>
<p>gluLookAt决定了我们观测的位置,不同的位置观测到的效果不一样,所以通常每次画图的时候要向z轴负方向移动一个单位</p>
<p>OpenGL坐标体系:局部空间,世界空间,观察空间,裁剪空间<br><a href="http://blog.csdn.net/killallpigs/article/details/53941138" target="_blank" rel="external">http://blog.csdn.net/killallpigs/article/details/53941138</a></p>
<h4 id="EGL"><a href="#EGL" class="headerlink" title="EGL:"></a>EGL:</h4><p>EGL是OpenGL ES与底层窗口系统进行通信的桥梁.</p>
<ul>
<li>EGL初始化流程</li>
<li>a, 选择Display</li>
<li>b, 选择Config</li>
<li>c, 创建Surface</li>
<li>d, 创建Context</li>
<li>e, 指定当前的环境为绘制环境</li>
</ul>
<p>在c这一步:<br>要在某个窗口中显示, 则用eglCreateWindowSurface() 来创建,只有这种是在物理显示设备上显示的。</p>
<p>要在内存中以位图保存，则用eglCreatePixmapSurface()来创建,该类型只用于离屏渲染.</p>
<p>要保存在显存中的帧，则用eglCreatePbufferSurface()来创建。</p>
<p>使用EGL的绘图的一般步骤：</p>
<p>初始化阶段:</p>
<ol>
<li>获取 EGLDisplay 对象</li>
<li>初始化与 EGLDisplay 之间的连接</li>
<li>获取 EGLConfig 对象</li>
<li>创建 EGLContext 实例</li>
<li>创建 EGLSurface 实例</li>
<li>连接 EGLContext 和 EGLSurface<br>使用阶段:</li>
<li>使用 GL 指令绘制图形<br>销毁阶段:</li>
<li>断开并释放与 EGLSurface 关联的 EGLContext 对象</li>
<li>删除 EGLSurface 对象</li>
<li>删除 EGLContext 对象</li>
<li>终止与 EGLDisplay 之间的连接</li>
</ol>
<p>一般来说在 Android 平台上开发 OpenGL ES 应用，无需直接使用javax.microedition.khronos.egl 包中的类按照上述步骤来使用 OpenGL ES 绘制图形，<br>在Android 平台中提供了一个 android.opengl 包，类 GLSurfaceView 提供了对Display,Surface,Context 的管理，大大简化了 OpenGL ES 的程序框架,对应大部分 OpenGL ES 开发，<br>只需调用一个方法来设置 OpenGLView 用到的 GLSurfaceView.Renderer。</p>
<p>所以,想要抛开GLSurfaceView来进行渲染,就要使用EGL.</p>
<p>On-Screen Rendering<br>即当前屏幕渲染，在用于显示的屏幕缓冲区中进行，不需要额外创建新的缓存，也不需要开启新的上下文，所以性能较好，但是受到缓存大小限制等因素，一些复杂的操作无法完成。</p>
<p>Off-Screen Rendering<br>即离屏渲染，指的是在 GPU 的当前屏幕缓冲区外开辟新的缓冲区进行操作。</p>
<h4 id="FrameBufferObject"><a href="#FrameBufferObject" class="headerlink" title="FrameBufferObject"></a>FrameBufferObject</h4><p>帧缓存,一般使用OpenGL ES是直接使用GLSurfaceView和GLSurfaceView.Renderer提供的环境进行的,然后渲染也是直接显示在屏幕上,有时候我们并不想直接渲染到屏幕.这时候使用帧缓存可以实现离屏渲染.</p>
<p>帧缓存本身相当于一个容器,RenderBuffer和Texture可以挂载在帧缓存之上,一旦与帧缓存绑定,这种关系一直会存在,除非解绑.<br>我们可以通过帧缓存进行渲染到纹理操作,然后用渲染后的纹理进行下一个帧缓存渲染的输入,然后可得到输出纹理,如此循环…<br>最后我们可以拿到最后一次的输出进行渲染到屏幕等操作.</p>
<h4 id="使用纹理"><a href="#使用纹理" class="headerlink" title="使用纹理:"></a>使用纹理:</h4><p>eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//激活纹理单元1</div><div class="line">GLES20.glActiveTexture(GLES20.GL_TEXTURE1);</div><div class="line">//绑定2D纹理</div><div class="line">GLES20.glBindTexture(GLES20.GL_TEXTURE_2D,getTextureId());</div><div class="line">//将纹理设置给Shader</div><div class="line">GLES20.glUniform1i(mHTexture,1);</div></pre></td></tr></table></figure></p>
<p>android camera都是横着取景的,必须经过矩阵变换才正常.</p>
<p>opengl规定纹理坐标为左下是原点,因为平台特性的原因,在Android上可以认为左上是原点,否则绘制出来的图片就是颠倒的,不过这样也是有弊端的,除了第一次外<br>(平台的最终image库绘制图片的时候，将图片上下颠倒了(reverse the Y)。………image库………Bingo, 明白了。)</p>
<p>(其实可以这样理解,因为Android屏幕Y轴是向下的,所以图片按照纹理坐标的定义读入进来的话刚好是上下相反的,但当把图片转化为纹理之后,之后的渲染到纹理操作都是在OpenGL的纹理坐标下进行的,<br>这个时候若是传入相反的纹理坐标时,势必会导致纹理再次上下翻转,所以调整好纹理方向之后,之后的每次操作要么传入正确的坐标,要么传入上下颠倒矩阵,这样才能保证最终纹理方向的正确)</p>
<p>,后续每次转换都要传入颠倒矩阵,否则的话每次操作都会上下翻转图片.</p>
<p>利用PBO可以大幅度提升GLReadPixel的速度(提升十倍,用两个PBO交替读取),不过3.0之前不能使用.</p>
<h4 id="glScissor裁剪操作"><a href="#glScissor裁剪操作" class="headerlink" title="glScissor裁剪操作"></a>glScissor裁剪操作</h4><p>glScissor裁剪操作,接下来的渲染操作只在裁剪区域内有效.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">EasyGlUtils.bindFrameTexture(fFrame[0],fTexture[0]);</div><div class="line">GLES20.glViewport(0,0,mPreviewWidth,mPreviewHeight);</div><div class="line">GLES20.glEnable(GLES20.GL_SCISSOR_TEST);//启用剪裁测试</div><div class="line">GLES20.glScissor(0,500,mPreviewWidth,mPreviewHeight-1000);</div><div class="line">mPreFilter.draw();</div><div class="line">GLES20.glDisable(GLES20.GL_SCISSOR_TEST);//关闭剪裁测试</div><div class="line">EasyGlUtils.unBindFrameBuffer();</div></pre></td></tr></table></figure></p>
<p>使用正交投影可以裁剪画面</p>
<p>OpenGL三维纹理坐标 s,t,r,q<br>q是一个缩放因子，相当于顶点坐标中的w。实际应用在纹理读取中的坐标应该是s/q,t/q,r/q。默认情况下，q是1.0。通常情况下貌似没什么用，但是在一些产生纹理坐标的高级算法比如阴影贴图中，比较有用。<br>s、t、r分别相当于普通坐标系中的x、y、z三个方向。分别对应glTexImage3D中的参数width、height、depth。</p>
<h4 id="图像抗锯齿"><a href="#图像抗锯齿" class="headerlink" title="图像抗锯齿"></a>图像抗锯齿</h4><h5 id="超级采样抗锯齿（SSAA）"><a href="#超级采样抗锯齿（SSAA）" class="headerlink" title="超级采样抗锯齿（SSAA）"></a>超级采样抗锯齿（SSAA）</h5><p>图像放大之后取临近的2-4个像素点,采样混合后生成最终像素,令每个像素拥有邻近像素的特征,像素与像素之间的过渡色彩，就变得近似，<br>令图形的边缘色彩过渡趋于平滑。再把最终像素还原回原来大小的图像，并保存到帧缓存也就是显存中，替代原图像存储起来，最后输出到显示器，显示出一帧画面。<br>这样就等于把一幅模糊的大图，通过细腻化后再缩小成清晰的小图<br>(1.顺序栅格超级采样（Ordered Grid Super-Sampling，简称OGSS），采样时选取2个邻近像素。2.旋转栅格超级采样（Rotated Grid Super-Sampling，简称RGSS），采样时选取4个邻近像素。)</p>
<h4 id="多重采样抗锯齿（MSAA）"><a href="#多重采样抗锯齿（MSAA）" class="headerlink" title="多重采样抗锯齿（MSAA）"></a>多重采样抗锯齿（MSAA）</h4><p>多重采样抗锯齿（MultiSampling Anti-Aliasing，简称MSAA）是一种特殊的超级采样抗锯齿（SSAA）。MSAA首先来自于OpenGL。<br>具体是MSAA只对Z缓存（Z-Buffer）和模板缓存(Stencil Buffer)中的数据进行超级采样抗锯齿的处理。可以简单理解为只对多边形的边缘进行抗锯齿处理。<br>这样的话，相比SSAA对画面中所有数据进行处理，MSAA对资源的消耗需求大大减弱，不过在画质上可能稍有不如SSAA。</p>
<p>剩下的抗锯齿方式在这里看:<a href="https://baike.baidu.com/item/%E6%8A%97%E9%94%AF%E9%BD%BF/7556069?fr=aladdin" target="_blank" rel="external">https://baike.baidu.com/item/%E6%8A%97%E9%94%AF%E9%BD%BF/7556069?fr=aladdin</a></p>
<h4 id="Android设备抗锯齿"><a href="#Android设备抗锯齿" class="headerlink" title="Android设备抗锯齿"></a>Android设备抗锯齿</h4><p>上面的在Android平台都不靠谱,这才是抗锯齿的最佳方式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int[] textures = new int[1];</div><div class="line">GLES20.glGenTextures(1, textures, 0);</div><div class="line">mTextureID = textures[0];</div><div class="line">GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, mTextureID);</div><div class="line">checkGlError(&quot;glBindTexture mTextureID&quot;);</div><div class="line">GLES20.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MIN_FILTER,</div><div class="line">                GLES20.GL_LINEAR);//改为线性过滤,是画面更加平滑(抗锯齿)</div><div class="line">GLES20.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MAG_FILTER,</div><div class="line">                GLES20.GL_LINEAR);</div><div class="line">GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_S,</div><div class="line">                GLES20.GL_CLAMP_TO_EDGE);</div><div class="line">GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_T,</div><div class="line">                GLES20.GL_CLAMP_TO_EDGE);</div></pre></td></tr></table></figure></p>
<h5 id="OpenGL——纹理过滤函数glTexParameteri"><a href="#OpenGL——纹理过滤函数glTexParameteri" class="headerlink" title="OpenGL——纹理过滤函数glTexParameteri()"></a>OpenGL——纹理过滤函数glTexParameteri()</h5><p>图象从纹理图象空间映射到帧缓冲图象空间(映射需要重新构造纹理图像,这样就会造成应用到多边形上的图像失真),这时就可用glTexParmeteri()函数来确定如何把纹理象素映射成像素.</p>
<p>glTexParameteri(int target, int pname, int param)</p>
<ul>
<li><p>target —— 目标纹理，必须为GL_TEXTURE_1D或GL_TEXTURE_2D，视频的话对应于GLES11Ext.GL_TEXTURE_EXTERNAL_OES；</p>
</li>
<li><p>pname —— 用来设置纹理映射过程中像素映射的问题等，取值可以为：</p>
</li>
</ul>
<ol>
<li>GL_TEXTURE_MIN_FILTER 设置最小过滤，第三个参数决定用什么过滤；</li>
<li>GL_TEXTURE_MAG_FILTER设置最大过滤，也是第三个参数决定；</li>
<li>GL_TEXTURE_WRAP_S；纹理坐标一般用str表示，分别对应xyz，2d纹理用st表示</li>
<li>GL_TEXTURE_WRAP_T   接上面，纹理和你画的几何体可能不是完全一样大的，在边界的时候如何处理呢？就是这两个参数决定的，wrap表示环绕，可以理解成让纹理重复使用，直到全部填充完成；</li>
</ol>
<ul>
<li>param —— 实际上就是pname的值</li>
</ul>
<ol>
<li>GL_LINEAR: 线性过滤, 使用距离当前渲染像素中心最近的4个纹素加权平均值.</li>
<li>GL_LINEAR_MIPMAP_NEAREST: 使用GL_NEAREST对最接近当前多边形的解析度的两个层级贴图进行采样,然后用这两个值进行线性插值.</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OpenGL ES是OpenGL的子集,针对嵌入式系统和移动设备所设计.&lt;br&gt;
    
    </summary>
    
    
      <category term="音视频" scheme="https://forevas.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="OpenGL" scheme="https://forevas.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>Android音频处理-采集</title>
    <link href="https://forevas.github.io/2017/06/15/Android%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86-%E9%87%87%E9%9B%86/"/>
    <id>https://forevas.github.io/2017/06/15/Android音频处理-采集/</id>
    <published>2017-06-15T14:21:10.000Z</published>
    <updated>2018-05-21T14:16:01.935Z</updated>
    
    <content type="html"><![CDATA[<p>录音功能一般使用MediaRecorder来进行，这种录音方式比较简单，设置好声音源、采样率和编码格式等参数即可，最终得到的是编码压缩后的数据。不过由于我们需要对音频原始数据进行处理，例如混音、变声等操作，所以MediaRecorder不能满足我们的要求。这里介绍下另一种录音工具类 AudioRecord。通过它我们可以对原始音频数据进行采集，以便于后续加工。 <a id="more"></a></p>
<h1 id="AudioRecord"><a href="#AudioRecord" class="headerlink" title="AudioRecord"></a>AudioRecord</h1><h2 id="AudioRecord的初始化："><a href="#AudioRecord的初始化：" class="headerlink" title="AudioRecord的初始化："></a>AudioRecord的初始化：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int sampleRate = 44100;   //音频采样率</div><div class="line">int channelConfig = AudioFormat.CHANNEL_IN_STEREO;   //音频录制通道,默认为立体声</div><div class="line">int audioFormat = AudioFormat.ENCODING_PCM_16BIT; //音频录制格式，默认为PCM16Bit</div><div class="line">int bufferSize = AudioRecord.getMinBufferSize(sampleRate, channelConfig, audioFormat);//设置bufferSize为AudioRecord所需最小bufferSize的两倍</div><div class="line">AudioRecord mRecorder = new AudioRecord(MediaRecorder.AudioSource.MIC, sampleRate,</div><div class="line">                                        channelConfig, audioFormat, bufferSize);//初始化录音器</div><div class="line">mRecorder.startRecording();</div></pre></td></tr></table></figure>
<p>AudioRecord构造参数：<br><strong>audioSource</strong> 音源，MediaRecorder.AudioSource.MIC 代表音源是麦克风<br><strong>sampleRate</strong> 采样率，由于声音是一种连续的模拟信号，我们要对其进行取样，从而将模拟信号转为离散的数字信号加以利用。采样率则决定了每秒对模拟信号进行采样的次数，这里采样率为44100，也就是通常所说的44.1khz的采样率<br><strong>channelConfig</strong> 音频通道的设置，通常设置为立体声<br><strong>audioFormat</strong> 音频格式，这里设置为16位PCM，也就是每次采样数据为一个short<br><strong>bufferSize</strong> 每次读取数据的最小size，小于这个会导致单次读取的数据不完整</p>
<h2 id="输出PCM文件"><a href="#输出PCM文件" class="headerlink" title="输出PCM文件"></a>输出PCM文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">//生成PCM文件</div><div class="line">file = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + &quot;/demo.pcm&quot;);</div><div class="line">//如果存在，就先删除再创建</div><div class="line">if (file.exists())</div><div class="line">        file.delete();</div><div class="line">try &#123;</div><div class="line">        file.createNewFile();</div><div class="line">&#125; catch (IOException e) &#123;</div><div class="line">        throw new IllegalStateException(&quot;未能创建&quot; + file.toString());</div><div class="line">&#125;</div><div class="line">try &#123;</div><div class="line">        //输出流</div><div class="line">        OutputStream os = new FileOutputStream(file);</div><div class="line">        BufferedOutputStream bos = new BufferedOutputStream(os);</div><div class="line">        DataOutputStream dos = new DataOutputStream(bos);</div><div class="line"></div><div class="line">        //设置bufferSize为AudioRecord所需小bufferSize的两倍</div><div class="line">        int bufferSize = AudioRecord.getMinBufferSize(sampleRate, channelConfig, audioFormat) * 2;</div><div class="line"></div><div class="line">        short[] buffer = new short[bufferSize];</div><div class="line">        isRecording = true;</div><div class="line">        while (isRecording) &#123;</div><div class="line">                int bufferReadResult = mRecorder.read(buffer, 0, bufferSize);</div><div class="line">                for (int i = 0; i &lt; bufferReadResult; i++) &#123;</div><div class="line">                        dos.writeShort(buffer[i]);</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">        mRecorder.stop();</div><div class="line">        dos.close();</div><div class="line">&#125; catch (Exception e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码将收集到的PCM数据保存到demo.pcm文件，因为是16位PCM格式，所以每个音元均为short型，这点很重要，后面不管是播放还是混音，都要以转换成short型再进行操作。</p>
<h1 id="AudioTrack"><a href="#AudioTrack" class="headerlink" title="AudioTrack"></a>AudioTrack</h1><p>一般播放音频我们使用MediaPlayer即可，MediaPlayer支持的音频格式较多，如mp3,aac,wma等，而且调用方式也比较简单，其原理是将输入的音频数据先进行解码，最终MediaPlayer的底层还是要用到AudioTrack来播放解码后的PCM数据，上面我们已经采集到了PCM数据，这里将AudioRecord采集到的数据进行播放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">if (file == null) &#123;</div><div class="line">        file = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + &quot;/demo.pcm&quot;);</div><div class="line">&#125;</div><div class="line">//读取文件</div><div class="line">int musicLength = (int) (file.length() / 2);</div><div class="line">short[] music = new short[musicLength];</div><div class="line">try &#123;</div><div class="line">        AudioTrack audioTrack = new AudioTrack(AudioManager.STREAM_MUSIC,</div><div class="line">                                               sampleRate, channelConfig,</div><div class="line">                                               AudioFormat.ENCODING_PCM_16BIT,</div><div class="line">                                               (int) file.length(),</div><div class="line">                                               AudioTrack.MODE_STREAM);</div><div class="line">        audioTrack.play();</div><div class="line">        InputStream is = new FileInputStream(file);</div><div class="line">        BufferedInputStream bis = new BufferedInputStream(is);</div><div class="line">        DataInputStream dis = new DataInputStream(bis);</div><div class="line">        int i = 0;</div><div class="line">        while (dis.available() &gt; 0) &#123;</div><div class="line">                music[i] = dis.readShort();</div><div class="line">                i++;</div><div class="line">        &#125;</div><div class="line">        audioTrack.write(music, 0, musicLength);//写入数据</div><div class="line">        audioTrack.stop();</div><div class="line">        dis.close();</div><div class="line">&#125; catch (Exception e) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AudioTrack有两种播放方式，static和streaming,上面的播放方式为streaming，需要先启动AudioTrack，然后可以将音频数据分段写入(上面的代码中并没有进行分段，可以从后半段数据开始写入，则只播放后半段音频),这里采用了16位PCM的格式，所以每次写入的数据都要为short型的整数倍。而static模式则会一次写入所有的音频数据，然后再启动AudioTrack，这种方式适用于音频数据量较小的情况。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上为PCM音频数据的采集和播放，这只是最初的一步，有了PCM数据我们就可以进行混音、变音等操作，最终还要进行编码后才能与视频流进行混合。Android音频系统博大精深，之前看到<a href="http://blog.csdn.net/zyuanyun/article/details/60890534#t7" target="_blank" rel="external">一篇文章</a>，对整个音频系统分析的很透彻，令人叹为观止，有兴趣的同学都可以学习下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;录音功能一般使用MediaRecorder来进行，这种录音方式比较简单，设置好声音源、采样率和编码格式等参数即可，最终得到的是编码压缩后的数据。不过由于我们需要对音频原始数据进行处理，例如混音、变声等操作，所以MediaRecorder不能满足我们的要求。这里介绍下另一种录音工具类 AudioRecord。通过它我们可以对原始音频数据进行采集，以便于后续加工。
    
    </summary>
    
    
      <category term="音视频" scheme="https://forevas.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频基础</title>
    <link href="https://forevas.github.io/2017/06/05/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80/"/>
    <id>https://forevas.github.io/2017/06/05/音视频基础/</id>
    <published>2017-06-05T14:17:25.000Z</published>
    <updated>2018-05-21T14:15:44.095Z</updated>
    
    <content type="html"><![CDATA[<p>最近公司要求做短视频的功能，由于之前的工作中并没有接触过关于音视频的工作，最多也就使用MediaPlayer+SurfaceView播放视频罢了，所以对于音视频的基本知识了解甚少。不过好在公司给的时间比较充裕，刚好趁着这个机会好好学一下这方面的知识。<br><a id="more"></a><br><strong>解协议</strong> : 将使用流媒体协议传输的的数据，解析为相应的封装格式数据。RTMP,HTTP..-&gt;MP4，MKV，RMVB，TS，FLV，AVI..</p>
<p><strong>解封装</strong> : 将输入的封装格式的数据，分离成为视频流压缩编码数据和音频流压缩编码数据。MP4，MKV，RMVB，TS，FLV，AVI..-&gt;H.264,H.265….编码的视频码流和AAC,mp3…编码的音频码流。</p>
<p><strong>解码</strong> : 将视频/音频压缩编码数据，解码成为非压缩的视频/音频原始数据。音频的压缩编码标准包含AAC，MP3，AC-3等等，视频的压缩编码标准则包含H.264，MPEG2，VC-1等等。压缩编码的视频数据输出成为非压缩的颜色数据，例如YUV420P，RGB等等；压缩编码的音频数据输出成为非压缩的音频抽样数据，例如PCM数据。</p>
<p><strong>视音频同步</strong> ：根据解封装模块处理过程中获取到的参数信息，同步解码出来的视频和音频数据，并将视频音频数据送至系统的显卡和声卡播放出来。</p>
<p><strong>时间戳</strong> ：音视频同步的参照物，每帧视频和音频都有时间戳，播放器根据时间戳来进行视频的渲染和音频的播放。</p>
<p><strong>编码</strong> ：使用特定的音视频压缩算法对帧数据进行处理，减少视频和音频体积。例如YUV-&gt;H.264,PCM-&gt;AAC等。</p>
<p><strong>采样率</strong> ：每秒从连续信号中提取并组成离散信号的采样个数，常用音频采样率为44.1khz和48.0khz.音频录制编码常用参数有采样率，比特率，声道数。</p>
<p><strong>码率</strong> ：也叫比特率，代表每秒音视频的大小，这个参数决定音视频最终的大小，码率*时间=音视频体积，码率高到一定程度就没什么用了，但是低到一定程度会导致声音或者画面失真。</p>
<p><strong>帧率</strong> ：每秒帧数，一般手机录制视频大概在30帧左右，音频由于本质是随时间变化的一维信号，所以固定格式固定采样率的音频的帧率基本是固定的。音频每帧时长=一对应的采样样本的个数/采样频率(单位为s)。例如44.1khz采样率下，AAC一帧固定采样1024个样本，根据计算 一个AAC帧时长=1024/44100=0.02232s=22.32ms,而mp3略有不同，mp3格式一帧=1152 * 1000 / 44100=26.122ms.</p>
<p><strong>I帧，P帧，关键帧间隔</strong> ：I帧可进行独立解码，而P帧的解码则依赖于前一帧的数据，解码只能从I帧开始，I帧也称为关键帧，从一个I帧到下一个I帧为关键帧间隔，我们平时经常可以看到播放器只能从特定的地方开始播放，这个地方就是I帧所在，若I帧缺失则会导致接下来的画面花屏。</p>
<p><strong>封装</strong> ：将音视频流进行合成，生成封装格式。例如 H.264 + AAC -&gt; MP4</p>
<p><strong>视频原始数据格式</strong> ：通过硬件设备采集到的原始帧数据(YUV,RGB)</p>
<p><strong>音频原始数据格式</strong> ：通过硬件设备采集到的原始帧数据(PCM)</p>
<p><strong>视频编码格式</strong> : H.264(最流行),MPEG4,MPEG2,HEVC(H.265),VP9,VP8,VC-1…</p>
<p><strong>音频编码格式</strong> : AAC(新,各个领域),AC-3,MP3,WMA…</p>
<p><strong>封装格式</strong> : AVI(不支持流媒体),MP4，MKV，RMVB，TS，FLV，AVI…</p>
<p><strong>流媒体协议</strong> : RTSP+RTP,RTMP,RTMFP,HTTP,MMS…</p>
<p>直播服务普遍采用了RTMP作为流媒体协议，FLV作为封装格式，H.264作为视频编码格式，AAC作为音频编码格式,Flash播放器。</p>
<p>点播服务普遍采用了HTTP作为流媒体协议，H.264作为视频编码格式，AAC作为音频编码格式,Flash播放器。</p>
<p>经过调查，发现目前市场拍摄段视频多用的是mp4格式，视频流为H.264,音频流为AAC，至于AVI，3GP等格式，已经很少见了。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/18893769" target="_blank" rel="external">视音频编解码技术零基础学习方法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近公司要求做短视频的功能，由于之前的工作中并没有接触过关于音视频的工作，最多也就使用MediaPlayer+SurfaceView播放视频罢了，所以对于音视频的基本知识了解甚少。不过好在公司给的时间比较充裕，刚好趁着这个机会好好学一下这方面的知识。&lt;br&gt;
    
    </summary>
    
    
      <category term="音视频" scheme="https://forevas.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>ButterKnife解析</title>
    <link href="https://forevas.github.io/2017/05/25/ButterKnife%E8%A7%A3%E6%9E%90/"/>
    <id>https://forevas.github.io/2017/05/25/ButterKnife解析/</id>
    <published>2017-05-25T14:08:27.000Z</published>
    <updated>2018-05-21T14:17:35.672Z</updated>
    
    <content type="html"><![CDATA[<p>自从引入了ButterKnife，再也不用频繁的findViewById了，也不用手动setOnClickListener了。此框架小而精致，实乃提高开发效率之必备良品。<br><a id="more"></a><br>ButterKnife的注解都是应用于编译期(Class)的,使用ButterKnife不会影响性能,运行期就没什么关系了.</p>
<p>ButterKnife核心原理是在编译期会为每个使用ButterKnife注解的文件生成一个_ViewBinding关联文件,在这个文件相当于一个工具类,我们调用ButterKnife.Bind方法时,会执行这个文件中类的构造方法,帮助我们进行findViewById和强转操作.</p>
<p>每次进行bind操作会生成一个_ViewBinding的对象(也就是返回的unbinder)，这个对象持有对当前类的引用，不过这两者是相互引用，Unbind方法也只是简单的将当前类对View的引用置空，所以不解绑并不会造成内存泄漏问题。</p>
<p>在Activity中使用unbind其实有点多余,反正Activity生命周期结束了,也就不再被引用的时候,整个Activity和View会被一起回收.</p>
<p>在Fragment中使用解绑操作,是因为Fragment不在活跃的时候,可以及时回收View,降低内存消耗,这也是因为Fragment是属于轻量级的组件,但是,我们通常使用Fragment没必要每次切换都要回收和重建,所以也就不用解绑.</p>
<p>ButterKnife中有一个缓存map集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static final Map&lt;Class&lt;?&gt;, Constructor&lt;? extends Unbinder&gt;&gt; BINDINGS = new LinkedHashMap&lt;&gt;();</div></pre></td></tr></table></figure></p>
<p>这个集合用来缓存_ViewBinding的构造器，便于类的快速实例化。</p>
<h5 id="android-apt-Annotation-Processing-Tool"><a href="#android-apt-Annotation-Processing-Tool" class="headerlink" title="android-apt(Annotation Processing Tool)"></a>android-apt(Annotation Processing Tool)</h5><p>Annotation processing 是javac中用于编译时扫描和解析Java注解的工具</p>
<p>android-apt:</p>
<ul>
<li>能在编译时期去依赖注解处理器并进行工作，但在生成 APK 时不会包含任何遗留的东西</li>
<li>能够辅助 Android Studio 在项目的对应目录中存放注解处理器在编译期间生成的文件</li>
</ul>
<h5 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h5><p>应用javaPoet框架自动生成代码</p>
<p>apt+javaPoet目前也是应用比较广泛，在一些大的开源库，如EventBus3.0+,页面路由 ARout、Dagger、Retrofit等均有使用的身影</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从引入了ButterKnife，再也不用频繁的findViewById了，也不用手动setOnClickListener了。此框架小而精致，实乃提高开发效率之必备良品。&lt;br&gt;
    
    </summary>
    
    
      <category term="ButterKnife" scheme="https://forevas.github.io/tags/ButterKnife/"/>
    
      <category term="源码解析" scheme="https://forevas.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Okhttp源码解析</title>
    <link href="https://forevas.github.io/2017/05/10/OkHttp%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://forevas.github.io/2017/05/10/OkHttp源码解析/</id>
    <published>2017-05-10T14:15:11.000Z</published>
    <updated>2018-05-21T14:08:59.239Z</updated>
    
    <content type="html"><![CDATA[<p>OkHttp是一个非常强大的网络请求库，相比HttpClient、Volley和HttpUrlConnection有很大的优势，Android6.0以后废除了HttpClient，4.4以后HttpUrlConnection底层也是用OkHttp实现的，而Volley已经停止维护了，OkHttp是目前使用最广泛的网络请求库。以往只是停留在会用的阶段，今天来看下OkHttp内部具体是如何实现的。<br><a id="more"></a><br>下面是一段标准的post请求:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">OkHttpClient httpClient = new OkHttpClient().newBuilder()</div><div class="line">.followRedirects(false)</div><div class="line">.followSslRedirects(false)</div><div class="line">.addInterceptor(new GzipRequestInterceptor())</div><div class="line">.build();</div><div class="line"></div><div class="line">MediaType type = MediaType.parse(&quot;application/json; charset=utf-8&quot;);</div><div class="line">RequestBody requestBody = RequestBody.create(type, json);</div><div class="line">Request request = new Request.Builder()</div><div class="line">.url(StatApi.BASE_URL_STAT)</div><div class="line">.post(requestBody)</div><div class="line">.tag(StatApi.BASE_URL_STAT)</div><div class="line">.build();</div><div class="line"></div><div class="line">httpClient.newCall(request).enqueue(new Callback() &#123;</div><div class="line">	@Override</div><div class="line">    public void onFailure(Call call, IOException e) &#123;</div><div class="line">        System.out.println(&quot;call = [&quot; + call + &quot;], e = [&quot; + e + &quot;]&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onResponse(Call call, Response response) throws IOException &#123;</div><div class="line">        System.out.println(&quot;call = [&quot; + call + &quot;], response = [&quot; + response + &quot;]&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>首先我们用Builder模式创建OkHttpClient对象,利用OkHttpClient,我们可以发起request请求和获得response结果,在OkHttpClient创建过程中我们可以配置参数,<br>例如.cookieJar()进行Cookie管理,.sslSocketFactory()进行证书认证管理,.connectTimeout()进行超时管理,.addInterceptor()进行拦截器管理(实现GZIP压缩等),.cache()进行缓存等.</p>
<p>创建Request对象,然后httpClient.newCall(request)会创建RealCall对象,RealCall有如下几个成员变量:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private final OkHttpClient client;</div><div class="line"></div><div class="line">// Guarded by this.</div><div class="line">private boolean executed;</div><div class="line">volatile boolean canceled;</div><div class="line"></div><div class="line">/** The application&apos;s original request unadulterated by redirects or auth headers. */</div><div class="line">Request originalRequest;//请求实体类</div><div class="line">HttpEngine engine;//核心请求类</div></pre></td></tr></table></figure></p>
<p>RealCall中有enqueue和execute两种方式请求,区别在于enqueue是异步请求,execute是同步请求,会阻塞线程.</p>
<p>这两个方法之中均出现了Dispatcher类,这里说下Dispatcher类,这个类维护着一个线程池,最多允许同时存在64个请求数,超出的部分会被缓存起来.<br>注意这三个双向队列,很重要,用来记录我们所有发起的同步或者异步的请求.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/** Ready async calls in the order they&apos;ll be run. */</div><div class="line">private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();//记录还未运行的异步请求</div><div class="line"></div><div class="line">/** Running asynchronous calls. Includes canceled calls that haven&apos;t finished yet. */</div><div class="line">private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();//记录正在运行的异步请求</div><div class="line"></div><div class="line">/** Running synchronous calls. Includes canceled calls that haven&apos;t finished yet. */</div><div class="line">private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();//记录同步请求</div><div class="line">当使用enqueue时,会创建AsyncCall(AsyncCall是一个Runnable对象)对象然后加入线程池.而execute时.则是将当前的RealCall记录下来并立刻执行.</div><div class="line">void enqueue(Callback responseCallback, boolean forWebSocket) &#123;</div><div class="line">    synchronized (this) &#123;</div><div class="line">      if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</div><div class="line">      executed = true;</div><div class="line">    &#125;</div><div class="line">    client.dispatcher().enqueue(new AsyncCall(responseCallback, forWebSocket));</div><div class="line">  &#125;</div><div class="line">@Override public Response execute() throws IOException &#123;</div><div class="line">    synchronized (this) &#123;</div><div class="line">      if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);</div><div class="line">      executed = true;</div><div class="line">    &#125;</div><div class="line">    try &#123;</div><div class="line">      client.dispatcher().executed(this);</div><div class="line">      Response result = getResponseWithInterceptorChain(false);</div><div class="line">      if (result == null) throw new IOException(&quot;Canceled&quot;);</div><div class="line">      return result;</div><div class="line">    &#125; finally &#123;</div><div class="line">      client.dispatcher().finished(this);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>继续跟下去,发现不管是同步还是异步的执行,最终都会调用getResponseWithInterceptorChain()方法,从而获得Response对象,同步调用会直接返回Response,异步的话由于有回调方法,所以会调用Callback的onResponse或onFailure方法.<br>看下getResponseWithInterceptorChain()方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private Response getResponseWithInterceptorChain(boolean forWebSocket) throws IOException &#123;</div><div class="line">    Interceptor.Chain chain = new ApplicationInterceptorChain(0, originalRequest, forWebSocket);</div><div class="line">    return chain.proceed(originalRequest);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>这里发现又多了个ApplicationInterceptorChain类.这个类用来对Request进行统一处理,可以看下它的proceed方法.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">@Override public Response proceed(Request request) throws IOException &#123;</div><div class="line">      // If there&apos;s another interceptor in the chain, call that.</div><div class="line">      if (index &lt; client.interceptors().size()) &#123;</div><div class="line">        Interceptor.Chain chain = new ApplicationInterceptorChain(index + 1, request, forWebSocket);</div><div class="line">        Interceptor interceptor = client.interceptors().get(index);</div><div class="line">        Response interceptedResponse = interceptor.intercept(chain);</div><div class="line"></div><div class="line">        if (interceptedResponse == null) &#123;</div><div class="line">          throw new NullPointerException(&quot;application interceptor &quot; + interceptor</div><div class="line">              + &quot; returned null&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return interceptedResponse;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // No more interceptors. Do HTTP.</div><div class="line">      return getResponse(request, forWebSocket);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这里采用<strong>责任链模式</strong>将我们之前创建OkHttpClient时添加的Intercepter进行遍历处理,例如.addInterceptor(new GzipRequestInterceptor())<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class GzipRequestInterceptor implements Interceptor &#123;</div><div class="line"></div><div class="line">    @Override public Response intercept(Chain chain) throws IOException &#123;</div><div class="line">        Request originalRequest = chain.request();</div><div class="line">        if (originalRequest.body() == null || originalRequest.header(&quot;Content-Encoding&quot;) != null) &#123;</div><div class="line">            return chain.proceed(originalRequest);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Request compressedRequest = originalRequest.newBuilder()</div><div class="line">                .header(&quot;Content-Encoding&quot;, &quot;gzip&quot;)</div><div class="line">                .method(originalRequest.method(), gzip(originalRequest.body()))</div><div class="line">                .build();</div><div class="line">        return chain.proceed(compressedRequest);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private RequestBody gzip(final RequestBody body) &#123;</div><div class="line">        return new RequestBody() &#123;</div><div class="line">            @Override public MediaType contentType() &#123;</div><div class="line">                return body.contentType();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override public long contentLength() &#123;</div><div class="line">                return -1; // 无法知道压缩后的数据大小</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override public void writeTo(BufferedSink sink) throws IOException &#123;</div><div class="line">                BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));</div><div class="line">                body.writeTo(gzipSink);</div><div class="line">                gzipSink.close();</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现GZIP压缩等.</p>
<p>Intercepter遍历执行之后会调用getResponse方法.<br>在这个方法中我们会发现最终创建了一个HttpEngine对象,这个类是核心类,发送请求和获得返回数据都是通过这个类来进行.<br>可以看到大致流程为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">engine.sendRequest();</div><div class="line">engine.readResponse();</div><div class="line">Response response = engine.getResponse();</div></pre></td></tr></table></figure></p>
<p>engine.sendRequest()方法中首先调用了networkRequest(userRequest),在这个方法中会进行Request header的填充,包括设置GZIP压缩,Cookie填充等等.</p>
<p>接下来就是缓存处理了,Internal.instance在OkHttpClient初始化的时候被初始化,主要用来方便缓存和连接池的管理.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">InternalCache responseCache = Internal.instance.internalCache(client);</div><div class="line">Response cacheCandidate = responseCache != null</div><div class="line">        ? responseCache.get(request)</div><div class="line">        : null;</div><div class="line">long now = System.currentTimeMillis();</div></pre></td></tr></table></figure></p>
<p>responseCache为Cache类的代理,对外提供了增删改查的接口,真正的缓存实现是在Cache类中的,可以发现,Cache是用DiskLruCache进行缓存的.DisLruCache的实现就不再多说了,很容易看懂.</p>
<p>这里先取出缓存,接下来进行缓存有效性的判断:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cacheStrategy = new CacheStrategy.Factory(now, request, cacheCandidate).get();</div></pre></td></tr></table></figure></p>
<p>这里进行了一大堆的判断,目的是判断缓存是否可用,详细判断查看Http协议,都是些协议规定的东西,没什么特别的.</p>
<p>networkRequest和cacheResponse两个字段很重要,通过这两个字段来判断是否需要请求网络：</p>
<ol>
<li>都为空,证明Request设置了Cache-Control: only-if-cached,并且缓存中找不到对应的缓存记录。</li>
</ol>
<ol>
<li><p>networkRequest不为空,cacheResponse为空 没有可用的缓存,需要访问网络</p>
</li>
<li><p>networkRequest为空,cacheResponse不为空 直接访问缓存即可,不需要访问网络</p>
</li>
<li><p>networkRequest和cacheResponse都不为空 缓存过时,而且设置了If-Modified-Since或者If-None-Match字段,这个时候需要访问网络,如果服务器返回304,则表明服务器没有改动,返回缓存即可,节省流量(这块的逻辑在engine.readResponse()中).</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">networkRequest = cacheStrategy.networkRequest;</div><div class="line">cacheResponse = cacheStrategy.cacheResponse;</div><div class="line"></div><div class="line">if (responseCache != null) &#123;</div><div class="line">  responseCache.trackResponse(cacheStrategy);//更新请求次数,通过网络请求的次数,通过缓存请求的次数</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123;</div><div class="line">  closeQuietly(cacheCandidate.body()); // The cache candidate wasn&apos;t applicable. Close it.</div><div class="line">&#125;</div><div class="line"></div><div class="line">// If we&apos;re forbidden from using the network and the cache is insufficient, fail.</div><div class="line">if (networkRequest == null &amp;&amp; cacheResponse == null) &#123;//当Request设置了Cache-Control: only-if-cached,并且缓存中找不到对应的缓存记录时...</div><div class="line">  userResponse = new Response.Builder()</div><div class="line">          .request(userRequest)</div><div class="line">          .priorResponse(stripBody(priorResponse))</div><div class="line">          .protocol(Protocol.HTTP_1_1)</div><div class="line">          .code(504)</div><div class="line">          .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)</div><div class="line">          .body(EMPTY_BODY)</div><div class="line">          .build();</div><div class="line">      return;</div><div class="line">&#125;</div><div class="line">// If we don&apos;t need the network, we&apos;re done.</div><div class="line">if (networkRequest == null) &#123;//networkRequest为空,cacheResponse不为空,则直接返回缓存数据</div><div class="line">  userResponse = cacheResponse.newBuilder()</div><div class="line">          .request(userRequest)</div><div class="line">          .priorResponse(stripBody(priorResponse))</div><div class="line">          .cacheResponse(stripBody(cacheResponse))</div><div class="line">          .build();</div><div class="line">  userResponse = unzip(userResponse);</div><div class="line">  return;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>缓存的分析到此结束,接下来就到了真正的网络请求的时候了.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">// We need the network to satisfy this request. Possibly for validating a conditional GET.</div><div class="line">    boolean success = false;</div><div class="line">    try &#123;</div><div class="line">      httpStream = connect();</div><div class="line">      httpStream.setHttpEngine(this);</div><div class="line"></div><div class="line">      if (writeRequestHeadersEagerly()) &#123;</div><div class="line">        long contentLength = OkHeaders.contentLength(request);</div><div class="line">        if (bufferRequestBody) &#123;</div><div class="line">          if (contentLength &gt; Integer.MAX_VALUE) &#123;</div><div class="line">            throw new IllegalStateException(&quot;Use setFixedLengthStreamingMode() or &quot;</div><div class="line">                + &quot;setChunkedStreamingMode() for requests larger than 2 GiB.&quot;);</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          if (contentLength != -1) &#123;</div><div class="line">            // Buffer a request body of a known length.</div><div class="line">            httpStream.writeRequestHeaders(networkRequest);</div><div class="line">            requestBodyOut = new RetryableSink((int) contentLength);</div><div class="line">          &#125; else &#123;</div><div class="line">            // Buffer a request body of an unknown length. Don&apos;t write request headers until the</div><div class="line">            // entire body is ready; otherwise we can&apos;t set the Content-Length header correctly.</div><div class="line">            requestBodyOut = new RetryableSink();</div><div class="line">          &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">          httpStream.writeRequestHeaders(networkRequest);</div><div class="line">          requestBodyOut = httpStream.createRequestBody(networkRequest, contentLength);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      success = true;</div><div class="line">    &#125; finally &#123;</div><div class="line">      // If we&apos;re crashing on I/O or otherwise, don&apos;t leak the cache body.</div><div class="line">      if (!success &amp;&amp; cacheCandidate != null) &#123;</div><div class="line">        closeQuietly(cacheCandidate.body());</div><div class="line">      &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>先看下connect()方法,这个方法一直跟进去会走到StreamAllocation.findConnection()中去,核心代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//...</div><div class="line"> RealConnection allocatedConnection = this.connection;</div><div class="line">      if (allocatedConnection != null &amp;&amp; !allocatedConnection.noNewStreams) &#123;//如果本身已经存在了一个连接,并且连接可用</div><div class="line">        return allocatedConnection;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // Attempt to get a connection from the pool.</div><div class="line">      RealConnection pooledConnection = Internal.instance.get(connectionPool, address, this);//如果连接池中有可复用的连接</div><div class="line">      if (pooledConnection != null) &#123;</div><div class="line">        this.connection = pooledConnection;</div><div class="line">        return pooledConnection;</div><div class="line">      &#125;</div><div class="line">//...</div><div class="line">RealConnection newConnection = new RealConnection(selectedRoute);//新建一个连接</div><div class="line">    acquire(newConnection);</div><div class="line"></div><div class="line">    synchronized (connectionPool) &#123;</div><div class="line">      Internal.instance.put(connectionPool, newConnection);</div><div class="line">      this.connection = newConnection;</div><div class="line">      if (canceled) throw new IOException(&quot;Canceled&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    newConnection.connect(connectTimeout, readTimeout, writeTimeout, address.connectionSpecs(),</div><div class="line">        connectionRetryEnabled);</div><div class="line">    routeDatabase().connected(newConnection.route());</div><div class="line"></div><div class="line">    return newConnection;</div></pre></td></tr></table></figure></p>
<p>继续进入newConnection.connect()方法,发现在这里通过address创建了普通的Socket或是SSLSocket对象.继续跟进去会发现,最终会调用newConnection.connectSocket()方法,<br>这个方法中真正打通了Socket连接,而且如果采用的协议为Http2.x或者Spdy3的话还会创建一个FramedConnection对象,这个对象很重要,基于Http2.x和Spdy3请求的发送和响应的获取都是通过这个对象来进行.</p>
<p>Http1xStream和Http2xStream分别对应Http1.x和Http2.x.</p>
<p>至此,连接已经建立成功.</p>
<p>回到HttpEngine.sendRequest()方法中.<br>看看connect之后又做了什么:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">if (writeRequestHeadersEagerly()) &#123;</div><div class="line">        long contentLength = OkHeaders.contentLength(request);</div><div class="line">        if (bufferRequestBody) &#123;</div><div class="line">          if (contentLength &gt; Integer.MAX_VALUE) &#123;</div><div class="line">            throw new IllegalStateException(&quot;Use setFixedLengthStreamingMode() or &quot;</div><div class="line">                + &quot;setChunkedStreamingMode() for requests larger than 2 GiB.&quot;);</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          if (contentLength != -1) &#123;</div><div class="line">            // Buffer a request body of a known length.</div><div class="line">            httpStream.writeRequestHeaders(networkRequest);</div><div class="line">            requestBodyOut = new RetryableSink((int) contentLength);</div><div class="line">          &#125; else &#123;</div><div class="line">            // Buffer a request body of an unknown length. Don&apos;t write request headers until the</div><div class="line">            // entire body is ready; otherwise we can&apos;t set the Content-Length header correctly.</div><div class="line">            requestBodyOut = new RetryableSink();</div><div class="line">          &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">          httpStream.writeRequestHeaders(networkRequest);</div><div class="line">          requestBodyOut = httpStream.createRequestBody(networkRequest, contentLength);</div><div class="line">        &#125;</div><div class="line">      &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到,这里如果bufferRequestBody为false或者bufferRequestBody为true并且Content-Length字段不是-1的话,就先socket通道中写入Headers.<br>回到RealCall.getResponse方法中,接下来执行了engine.readResponse()这里做了一系列判断,如果没有写入Headers就写入Headers,如果没有写入body就写入body.<br>接下来会执行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">networkResponse = readNetworkResponse();//读取Response,Http1.x和Http2.x分别处理</div><div class="line">receiveHeaders(networkResponse.headers());//这里主要是Cookie保存</div><div class="line">接下来:</div><div class="line">// If we have a cache response too, then we&apos;re doing a conditional get.</div><div class="line">    if (cacheResponse != null) &#123;</div><div class="line">      if (validate(cacheResponse, networkResponse)) &#123;//服务器返回304或者Last-Modified没有发生改变,直接返回缓存内容</div><div class="line">        userResponse = cacheResponse.newBuilder()</div><div class="line">            .request(userRequest)</div><div class="line">            .priorResponse(stripBody(priorResponse))</div><div class="line">            .headers(combine(cacheResponse.headers(), networkResponse.headers()))</div><div class="line">            .cacheResponse(stripBody(cacheResponse))</div><div class="line">            .networkResponse(stripBody(networkResponse))</div><div class="line">            .build();</div><div class="line">        networkResponse.body().close();//释放连接</div><div class="line">        releaseStreamAllocation();//释放连接</div><div class="line"></div><div class="line">        // Update the cache after combining headers but before stripping the</div><div class="line">        // Content-Encoding header (as performed by initContentStream()).</div><div class="line">        InternalCache responseCache = Internal.instance.internalCache(client);</div><div class="line">        responseCache.trackConditionalCacheHit();</div><div class="line">        responseCache.update(cacheResponse, stripBody(userResponse));//更新缓存</div><div class="line">        userResponse = unzip(userResponse);</div><div class="line">        return;</div><div class="line">      &#125; else &#123;</div><div class="line">        closeQuietly(cacheResponse.body());</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    userResponse = networkResponse.newBuilder()//正常请求返回</div><div class="line">        .request(userRequest)</div><div class="line">        .priorResponse(stripBody(priorResponse))</div><div class="line">        .cacheResponse(stripBody(cacheResponse))</div><div class="line">        .networkResponse(stripBody(networkResponse))</div><div class="line">        .build();</div><div class="line"></div><div class="line">    if (hasBody(userResponse)) &#123;</div><div class="line">      maybeCache();</div><div class="line">      userResponse = unzip(cacheWritingResponse(storeRequest, userResponse));//更新缓存并构造Response返回</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>再次回到RealCall.getResponse方法中,继续往下看,在engine.readResponse()之后,会做一些异常处理,即重传机制.最后若请求正常返回,则返回Response.</p>
<p>至此，一次完整的请求结束，看的真是累，不得不说，看源码实现还是有很多好处的，可以加深我们对网络请求过程的认识和对Http协议的理解。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OkHttp是一个非常强大的网络请求库，相比HttpClient、Volley和HttpUrlConnection有很大的优势，Android6.0以后废除了HttpClient，4.4以后HttpUrlConnection底层也是用OkHttp实现的，而Volley已经停止维护了，OkHttp是目前使用最广泛的网络请求库。以往只是停留在会用的阶段，今天来看下OkHttp内部具体是如何实现的。&lt;br&gt;
    
    </summary>
    
    
      <category term="源码解析" scheme="https://forevas.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="OkHttp" scheme="https://forevas.github.io/tags/OkHttp/"/>
    
  </entry>
  
  <entry>
    <title>浅谈设计模式-代理模式和装饰模式</title>
    <link href="https://forevas.github.io/2017/05/04/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <id>https://forevas.github.io/2017/05/04/浅谈设计模式-代理模式和装饰模式/</id>
    <published>2017-05-04T15:29:04.000Z</published>
    <updated>2017-09-13T14:54:54.113Z</updated>
    
    <content type="html"><![CDATA[<p>代理模式和装饰模式十分相似，连类图都长得差不多，不过二者用来解决的问题不同，代理模式为其它对象提供一种代理，目的是为了隐藏其具体的实现细节和控制这个对象的访问（就比如通过代理上网）。而装饰模式是通过迭代来为一个对象增加额外的行为，而这个对象本身不变(比如人穿了多件衣服，但人本身不变)。在这里要加以区分。<br><a id="more"></a></p>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="Proxy.jpg" alt="代理模式"><br>代理模式中，代理类和真实类均继承于相同的抽象父类或是实现相同的接口，代理类持有真实类的引用，用户直接接触的对象是代理类，代理类在控制用户的访问的同时隐藏了真实类的实现细节。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface INetClient &#123;</div><div class="line">	void connectToServer(String serverAddress);</div><div class="line">	void sendMessage(String msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 真正与server通信的类</div><div class="line"> * @author Administrator</div><div class="line"> */</div><div class="line">public class Client implements INetClient&#123;</div><div class="line">	private String clientAddress=&quot;192.168.0.1&quot;;</div><div class="line">	private Server server;</div><div class="line">	@Override</div><div class="line">	public void connectToServer(String serverAddress) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		server=new Server(serverAddress);</div><div class="line">		server.connect(clientAddress);//连接</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void sendMessage(String msg) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		server.send(msg);//发消息</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 代理类</div><div class="line"> * @author Administrator</div><div class="line"> */</div><div class="line">public class ClientProxy implements INetClient&#123;</div><div class="line">	private String clientAddress=&quot;192.168.0.2&quot;;</div><div class="line">	private INetClient client=new Client();</div><div class="line">	@Override</div><div class="line">	public void connectToServer(String serverAddress) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		client.connectToServer(serverAddress);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void sendMessage(String msg) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		client.sendMessage(msg);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class Server &#123;</div><div class="line">	private String serverAddress;</div><div class="line">	private String clientAddress;</div><div class="line"></div><div class="line">	public Server(String serverAddress) &#123;</div><div class="line">		this.serverAddress = serverAddress;</div><div class="line">	&#125;</div><div class="line">	public void connect(String clientAddress)&#123;</div><div class="line">		if(clientAddress.endsWith(&quot;1&quot;))&#123;//判断地址是否合法</div><div class="line">			this.clientAddress=clientAddress;</div><div class="line">			System.out.println(clientAddress+&quot; 已连接至服务器 &quot;+serverAddress);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public void send(String msg)&#123;</div><div class="line">		if(clientAddress!=null)&#123;</div><div class="line">			System.out.println(clientAddress+&quot; 向服务器发送了 &quot;+msg);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class TestProxy &#123;</div><div class="line">	public static void main(String[]args)&#123;</div><div class="line">		INetClient client=new ClientProxy();</div><div class="line">		client.connectToServer(&quot;192.168.0.100&quot;);</div><div class="line">		client.sendMessage(&quot;hello world&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">192.168.0.1 已连接至服务器 192.168.0.100</div><div class="line">192.168.0.1 向服务器发送了 hello world</div></pre></td></tr></table></figure></p>
<h2 id="在Android中的应用"><a href="#在Android中的应用" class="headerlink" title="在Android中的应用"></a>在Android中的应用</h2><p>在 Android 中也有不少代理类的实现，我们经常打交道的就是 ActivityManagerProxy 了，其代理的是 ActivityManagerNative ，两者均实现了 IActivityManger 接口，而 ActivityManagerNative 作为一个抽象类，其具体实现是 ActivityManagerService ，两者运行于不同的进程，通过Binder机制进行通信。我们平时启动 Activity、Service 等操作都是通过本地 ActivityManagerProxy 来与 ActivityManagerService 进行交流的。 ActivityManagerService 的实现细节我们并不需要关心，只需要与其代理类进行交流即可。</p>
<h1 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h1><h2 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="Decorator.jpg" alt="装饰模式"><br>装饰模式和代理模式实现方式类似，我们可以对一个对象进行多层装饰，每层装饰均可实现特定的装饰功能。最终我们接触的是经过装饰之后的类，中间的装饰层对我们来说是透明的。</p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 定义饮料接口</div><div class="line"> * @author Administrator</div><div class="line"> *</div><div class="line"> */</div><div class="line">public interface Drink &#123;</div><div class="line">	public String getDescription();</div><div class="line">	public float getPrice();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 原始类</div><div class="line"> * @author Administrator</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class Coffee implements Drink &#123;</div><div class="line">	private String description=&quot;冲了一包咖啡&quot;;</div><div class="line">	private float price=10;</div><div class="line">	@Override</div><div class="line">	public String getDescription() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return description;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public float getPrice() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return price;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 原始类</div><div class="line"> * @author Administrator</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class Tea implements Drink &#123;</div><div class="line">	private String description=&quot;泡了一杯茶&quot;;</div><div class="line">	private float price=12;</div><div class="line">	@Override</div><div class="line">	public String getDescription() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return description;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public float getPrice() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return price;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 装饰类</div><div class="line"> * @author Administrator</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class SugerDecorator implements Drink &#123;</div><div class="line">	private Drink drink;</div><div class="line">	private String description=&quot;加入一勺糖&quot;;</div><div class="line">	private float price=1.5f;</div><div class="line">	public SugerDecorator(Drink drink) &#123;</div><div class="line">		this.drink = drink;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public String getDescription() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return drink.getDescription()+description;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public float getPrice() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return drink.getPrice()+price;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 装饰类</div><div class="line"> * @author Administrator</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class SaltDecorator implements Drink &#123;</div><div class="line">	private Drink drink;</div><div class="line">	private String description=&quot;加入一勺盐&quot;;</div><div class="line">	private float price=1;</div><div class="line">	public SaltDecorator(Drink drink) &#123;</div><div class="line">		this.drink = drink;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public String getDescription() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return drink.getDescription()+description;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public float getPrice() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return drink.getPrice()+price;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 装饰类</div><div class="line"> * @author Administrator</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class PepperDecorator implements Drink &#123;</div><div class="line">	private Drink drink;</div><div class="line">	private String description=&quot;加入一勺辣椒粉&quot;;</div><div class="line">	private float price=2;</div><div class="line">	public PepperDecorator(Drink drink) &#123;</div><div class="line">		this.drink = drink;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public String getDescription() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return drink.getDescription()+description;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public float getPrice() &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return drink.getPrice()+price;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class TestDecorator &#123;</div><div class="line">	public static void main(String[]args)&#123;</div><div class="line">		Drink coffee=new Coffee();</div><div class="line">		Drink tea=new Tea();</div><div class="line">		Drink sugerCoffee=new SugerDecorator(coffee);</div><div class="line">		Drink saltCoffee=new SaltDecorator(coffee);</div><div class="line">		Drink pepperCoffee=new PepperDecorator(coffee);</div><div class="line">		Drink sugerTea=new SugerDecorator(tea);</div><div class="line">		Drink saltTea=new SaltDecorator(tea);</div><div class="line">		Drink pepperTea=new PepperDecorator(tea);</div><div class="line">		System.out.println(coffee.getDescription()+&quot;;价格=&quot;+coffee.getPrice());</div><div class="line">		System.out.println(tea.getDescription()+&quot;;价格=&quot;+tea.getPrice());</div><div class="line">		System.out.println(sugerCoffee.getDescription()+&quot;;价格=&quot;+sugerCoffee.getPrice());</div><div class="line">		System.out.println(saltCoffee.getDescription()+&quot;;价格=&quot;+saltCoffee.getPrice());</div><div class="line">		System.out.println(pepperCoffee.getDescription()+&quot;;价格=&quot;+pepperCoffee.getPrice());</div><div class="line">		System.out.println(sugerTea.getDescription()+&quot;;价格=&quot;+sugerTea.getPrice());</div><div class="line">		System.out.println(saltTea.getDescription()+&quot;;价格=&quot;+saltTea.getPrice());</div><div class="line">		System.out.println(pepperTea.getDescription()+&quot;;价格=&quot;+pepperTea.getPrice());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">冲了一包咖啡;价格=10.0</div><div class="line">泡了一杯茶;价格=12.0</div><div class="line">冲了一包咖啡加入一勺糖;价格=11.5</div><div class="line">冲了一包咖啡加入一勺盐;价格=11.0</div><div class="line">冲了一包咖啡加入一勺辣椒粉;价格=12.0</div><div class="line">泡了一杯茶加入一勺糖;价格=13.5</div><div class="line">泡了一杯茶加入一勺盐;价格=13.0</div><div class="line">泡了一杯茶加入一勺辣椒粉;价格=14.0</div></pre></td></tr></table></figure></p>
<h2 id="在Android中的应用-1"><a href="#在Android中的应用-1" class="headerlink" title="在Android中的应用"></a>在Android中的应用</h2><p>Android 中的 Context 体系就是装饰模式很好的应用，Activity 继承于 ContextThemeWrapper，而 ContextThemeWrapper、Service 和 Application，均继承于 ContextThemeWrapper，ContextWrapper 持有 ContextImpl的引用，ContextImpl 则实现了 Context 中定义的方法。在这里，ContextWrapper以及其子类，均装饰了ContextImpl类。我们在Activity、Service或是Application中均可以直接调用到Context中定义的方法，而不用关心中间的装饰过程，因为其装饰过程不同，所以其最终表现的结果也可能是不同的，但这些对我们来说都是透明的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>代理模式和装饰模式因为结构比较类似，所以这里将两者一起进行论述，以加深印象。目前在工作中代理模式用的多一点，大多用在 Android 网络请求中，配合弱引用，对网络请求的callback进行封装，可以有效避免内存泄漏。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代理模式和装饰模式十分相似，连类图都长得差不多，不过二者用来解决的问题不同，代理模式为其它对象提供一种代理，目的是为了隐藏其具体的实现细节和控制这个对象的访问（就比如通过代理上网）。而装饰模式是通过迭代来为一个对象增加额外的行为，而这个对象本身不变(比如人穿了多件衣服，但人本身不变)。在这里要加以区分。&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://forevas.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>浅谈设计模式-Builder模式</title>
    <link href="https://forevas.github.io/2017/04/27/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Builder%E6%A8%A1%E5%BC%8F/"/>
    <id>https://forevas.github.io/2017/04/27/浅谈设计模式-Builder模式/</id>
    <published>2017-04-27T14:18:31.000Z</published>
    <updated>2017-05-18T14:33:20.139Z</updated>
    
    <content type="html"><![CDATA[<p>当我们去设计一个比较简单的类的构造方式时，一般情况下，直接重载几个不同参数的构造方法即可。但当类的成员变量比较多的时候，可能某些成员变量是必要的，某些又是可选的。有些是创建的时候需要传入的，有些又是对象创建完成之后才传的。这样的话重载构造方法的方式就会让人感到很迷茫，必须写一大堆注释来进行说明。这个时候，用Builder模式来进行对象的构建是十分合理的。<br><a id="more"></a><br>Builder模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<br>下面是标准Builder模式的类图。<br><img src="Builder.jpg" alt="Builder模式"><br>我们在实际使用中往往使用的是改造过的Builder模式，经常会省略掉Director,直接在代码中使用Builder模式来创建对象，在这里我们自己充当了Director的角色。下面自己来实现一个最简单的Builder模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">public class Person &#123;</div><div class="line">	private String id;</div><div class="line">	private String name;</div><div class="line">	private String sex;</div><div class="line">	private int age;</div><div class="line">	private String phoneNumber;</div><div class="line">	private String email;</div><div class="line">	private String address;</div><div class="line">	private String occupation;</div><div class="line"></div><div class="line">	private Person(Builder builder) &#123;</div><div class="line">		this.id = builder.id;</div><div class="line">		this.name = builder.name;</div><div class="line">		this.sex = builder.sex;</div><div class="line">		this.age = builder.age;</div><div class="line">		this.phoneNumber = builder.phoneNumber;</div><div class="line">		this.email = builder.email;</div><div class="line">		this.address = builder.address;</div><div class="line">		this.occupation = builder.occupation;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	static class Builder &#123;</div><div class="line">		private String id;</div><div class="line">		private String name;</div><div class="line">		private String sex;</div><div class="line">		private int age;</div><div class="line">		private String phoneNumber;</div><div class="line">		private String email;</div><div class="line">		private String address;</div><div class="line">		private String occupation;</div><div class="line"></div><div class="line">		public Builder(String id, String name, String sex, int age) &#123;</div><div class="line">			this.id = id;</div><div class="line">			this.name = name;</div><div class="line">			this.sex = sex;</div><div class="line">			this.age = age;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		public Builder setPhoneNumber(String phoneNumber) &#123;</div><div class="line">			this.phoneNumber = phoneNumber;</div><div class="line">			return this;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		public Builder setEmail(String email) &#123;</div><div class="line">			this.email = email;</div><div class="line">			return this;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		public Builder setAddress(String address) &#123;</div><div class="line">			this.address = address;</div><div class="line">			return this;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		public Builder setOccupation(String occupation) &#123;</div><div class="line">			this.occupation = occupation;</div><div class="line">			return this;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		public Person build() &#123;</div><div class="line">			return new Person(this);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class TestBuilder &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		Person person = new Person.Builder(&quot;xxx&quot;, &quot;Faker&quot;, &quot;man&quot;, 22)</div><div class="line">				.setAddress(&quot;Korea&quot;).setEmail(&quot;xxx@gmail.com&quot;)</div><div class="line">				.setOccupation(&quot;lol&quot;).setPhoneNumber(&quot;12345678901&quot;).build();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的例子很直观的反映出了Builder模式的核心内容，当我们想要创建Person对象时，哪些参数是必须的，哪些是可选的，一目了然。而且链式的调用方式可读性更佳。<br>在Android中最常见的Builder模式就是AlertDialog了吧，在平时的编码中经常打交道。还有开源框架okhttp也大量使用了Builder模式，相信用过的人肯定深有感触。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们去设计一个比较简单的类的构造方式时，一般情况下，直接重载几个不同参数的构造方法即可。但当类的成员变量比较多的时候，可能某些成员变量是必要的，某些又是可选的。有些是创建的时候需要传入的，有些又是对象创建完成之后才传的。这样的话重载构造方法的方式就会让人感到很迷茫，必须写一大堆注释来进行说明。这个时候，用Builder模式来进行对象的构建是十分合理的。&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://forevas.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>浅谈设计模式-单例模式</title>
    <link href="https://forevas.github.io/2017/04/20/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://forevas.github.io/2017/04/20/浅谈设计模式-单例模式/</id>
    <published>2017-04-20T14:29:47.000Z</published>
    <updated>2017-05-18T14:36:50.059Z</updated>
    
    <content type="html"><![CDATA[<p>最近一段时间都没有写博客，感觉自己变懒了，这几天反省了一下，决定写点什么，想了想，准备写一下自己对于设计模式的理解。设计模式的思想对于代码的解耦和灵活性有很大的帮助，尤其是项目做的越来越大的时候，合理的使用设计模式的思想来进行代码结构的设计有利于以后的的扩展和维护。<br><a id="more"></a><br>谈到设计模式，大家肯定最先想到的是单例，毕竟大多数人学习设计模式最先接触的就是单例模式。在平时的软件设计中，单例也占据很重要的地位，例如一个APP中用户个人信息就可以使用单例来进行维护等等。接下来就说说我对于单例的理解。</p>
<p>单例的实现方式有很多种，个人看来，不管怎么变，都离不开以下四种方式。</p>
<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 饿汉模式</div><div class="line"> *</div><div class="line"> * @author Administrator</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class Singleton_3 &#123;</div><div class="line">	private static final Singleton_3 singleton = new Singleton_3();</div><div class="line"></div><div class="line">	private Singleton_3() &#123;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	public static Singleton_3 getInstance() &#123;</div><div class="line">		return singleton;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>饿汉式简单易懂，不过在类初始化的时候就会被实例化，但可能此时并没有用到它，比较浪费内存。</p>
<h2 id="饱汉式（双重校验锁）"><a href="#饱汉式（双重校验锁）" class="headerlink" title="饱汉式（双重校验锁）"></a>饱汉式（双重校验锁）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 饱汉模式</div><div class="line"> *</div><div class="line"> * @author Administrator</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class Singleton_4 &#123;</div><div class="line">	private static volatile Singleton_4 singleton;</div><div class="line"></div><div class="line">	private Singleton_4() &#123;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	public static Singleton_4 getInstance() &#123;</div><div class="line">		if (singleton == null) &#123;</div><div class="line">			synchronized (Singleton_4.class) &#123;</div><div class="line">				if (singleton == null) &#123;</div><div class="line">					singleton = new Singleton_4();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return singleton;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>饱汉式实现了lazyload，但是考虑到线程安全和效率问题还是要使用双重校验锁来实现。注意这里单例要加上volatile关键字，否则可能会造成双重校验锁失效问题。</p>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 静态内部类模式</div><div class="line"> *</div><div class="line"> * @author Administrator</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class Singleton_1 &#123;</div><div class="line">	private Singleton_1() &#123;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	private static class SingletonHolder &#123;</div><div class="line">		private static final Singleton_1 singleton = new Singleton_1();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static final Singleton_1 getInstance() &#123;</div><div class="line">		return SingletonHolder.singleton;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>静态内部类也实现了lazyload，不过它的优点在于避免了线程锁的校验，效率比较高，综合来看，比前两种方式都要好。</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 枚举实现</div><div class="line"> *</div><div class="line"> * @author Administrator</div><div class="line"> *</div><div class="line"> */</div><div class="line">public enum Singleton_2 &#123;</div><div class="line">	INSTANCE;</div><div class="line">	public void whatEverYouWant() &#123;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>枚举实现单例应该是最简单的了吧，而且枚举实现的单例无法被破坏，个人感觉实现单例的最佳方式。</p>
<h2 id="问题和对策"><a href="#问题和对策" class="headerlink" title="问题和对策"></a>问题和对策</h2><p>前三种方法通过反射、序列化和克隆均可以破坏其单例性，具体破坏代码的实现就不再赘述，大家可以自己试一试，这里只针对这几种破坏单例的方式给出对策。就拿第一种单例实现方式来举例吧。<br>避免单例被反射破坏：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class Singleton_3 &#123;</div><div class="line">	private static boolean flag = false;</div><div class="line">	private static final Singleton_3 singleton = new Singleton_3();</div><div class="line"></div><div class="line">	private Singleton_3() &#123;</div><div class="line">		synchronized (Singleton_3.class) &#123;//加锁是为了防止多个线程同时利用反射进行实例的创建时产生的问题</div><div class="line">			if (!flag) &#123;</div><div class="line">				flag = true;</div><div class="line">			&#125; else &#123;</div><div class="line">				throw new RuntimeException(&quot;单例模式被破坏...&quot;);//利用反射创建实例的时候直接抛出异常</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	public static Singleton_3 getInstance() &#123;</div><div class="line">		return singleton;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>避免单例被序列化破坏：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Singleton_3 implements Serializable&#123;</div><div class="line">	private static final Singleton_3 singleton = new Singleton_3();</div><div class="line"></div><div class="line">	private Singleton_3() &#123;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	public static Singleton_3 getInstance() &#123;</div><div class="line">		return singleton;</div><div class="line">	&#125;</div><div class="line">	private Object readResolve() &#123;</div><div class="line">		return singleton;//在其反序列化的时候直接返回已存在的单例</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>避免单例被克隆破坏：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Singleton_3 implements Cloneable&#123;</div><div class="line">	private static final Singleton_3 singleton = new Singleton_3();</div><div class="line"></div><div class="line">	private Singleton_3() &#123;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	public static Singleton_3 getInstance() &#123;</div><div class="line">		return singleton;</div><div class="line">	&#125;</div><div class="line">	@Override</div><div class="line">	protected Object clone() throws CloneNotSupportedException &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		return singleton;//覆写clone()方法，直接返回已存在的单例</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于单例，就说这么多吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一段时间都没有写博客，感觉自己变懒了，这几天反省了一下，决定写点什么，想了想，准备写一下自己对于设计模式的理解。设计模式的思想对于代码的解耦和灵活性有很大的帮助，尤其是项目做的越来越大的时候，合理的使用设计模式的思想来进行代码结构的设计有利于以后的的扩展和维护。&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://forevas.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Windows下使用MinGW编译FFmpeg</title>
    <link href="https://forevas.github.io/2017/03/20/Windows%E4%B8%8B%E4%BD%BF%E7%94%A8MinGW%E7%BC%96%E8%AF%91FFmpeg/"/>
    <id>https://forevas.github.io/2017/03/20/Windows下使用MinGW编译FFmpeg/</id>
    <published>2017-03-20T15:00:33.000Z</published>
    <updated>2018-05-21T13:32:20.931Z</updated>
    
    <content type="html"><![CDATA[<p>在linux下编译FFmpeg很方便，但在Windows下还是有不少坑的，试了下使用Windows+MinGW编译FFmpeg，过程还是挺顺利的。记录一下(这里针对的平台是Android)。<br><a id="more"></a></p>
<h1 id="下载FFmpeg源码"><a href="#下载FFmpeg源码" class="headerlink" title="下载FFmpeg源码"></a>下载FFmpeg源码</h1><p>首先，去<a href="http://ffmpeg.org/download.html" target="_blank" rel="external">FFmpeg官网</a>下载源码。</p>
<p><img src="download_ffmpeg.png" alt="FFmpeg"></p>
<p>然后解压至任意盘中，解压之后的目录如下。</p>
<p><img src="unzip_ffmpeg.png" alt="Source"></p>
<h1 id="NDK下载"><a href="#NDK下载" class="headerlink" title="NDK下载"></a>NDK下载</h1><p>下载NDK可以通过Android Studio自带的SDK管理工具来进行下载。也可以自行去<a href="https://developer.android.com/ndk/downloads/index.html?hl=zh-cn" target="_blank" rel="external">官网</a>下载解压。</p>
<p><img src="NDK.png" alt="NDK"></p>
<h1 id="MinGW下载配置"><a href="#MinGW下载配置" class="headerlink" title="MinGW下载配置"></a>MinGW下载配置</h1><p> MinGW - Minimalist GNU for Windows-是Windows下模拟Linux运行的库、头文件等的集合。我们编译FFmpeg源码需要用到它。</p>
<p> 点击<a href="https://superb-dca2.dl.sourceforge.net/project/mingw/Installer/mingw-get-setup.exe" target="_blank" rel="external">这里</a>直接下载安装程序，安装过程时长视网速而定。</p>
<p> 安装完成后，打开MinGW Installation Manager,选中Basic Setup，在右边的package中选中如下几项：</p>
<p><img src="MinGW_config.png" alt="MinGW"></p>
<p> 然后点击Installation-&gt;Apply Changes,过一会就ok了。</p>
<p> 到这里，我们的准备工作已经完成了。</p>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>在之前FFmpeg解压后的文件夹中找到configure文件，将其中的这段代码：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SLIBNAME_WITH_MAJOR=&apos;$(SLIBNAME).$(LIBMAJOR)&apos;</div><div class="line">LIB_INSTALL_EXTRA_CMD=&apos;$$(RANLIB) &quot;$(LIBDIR)/$(LIBNAME)&quot;&apos;</div><div class="line">SLIB_INSTALL_NAME=&apos;$(SLIBNAME_WITH_VERSION)&apos;</div><div class="line">SLIB_INSTALL_LINKS=&apos;$(SLIBNAME_WITH_MAJOR) $(SLIBNAME)&apos;</div></pre></td></tr></table></figure>
<p> 替换为：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SLIBNAME_WITH_MAJOR=&apos;$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)&apos;</div><div class="line">LIB_INSTALL_EXTRA_CMD=&apos;$$(RANLIB) &quot;$(LIBDIR)/$(LIBNAME)&quot;&apos;</div><div class="line">SLIB_INSTALL_NAME=&apos;$(SLIBNAME_WITH_MAJOR)&apos;</div><div class="line">SLIB_INSTALL_LINKS=&apos;$(SLIBNAME)&apos;</div></pre></td></tr></table></figure></p>
<p> 这段代码是控制将来编译生成so库的命名格式，如果按照原来的命名格式编译出来将会是libavcodec.so.57这样的格式，android不能识别，改过之后为libavcodec-57.so，这样就可以了。</p>
<p> 然后在FFmpeg解压后的目录中新建build_android.sh文件，内容如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">NDK=D:/Android/sdk/ndk-bundle</div><div class="line">SYSROOT=$NDK/platforms/android-21/arch-arm/</div><div class="line">TOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/windows-x86_64</div><div class="line">function build_one</div><div class="line">&#123;</div><div class="line">./configure \</div><div class="line">    --prefix=$PREFIX \</div><div class="line">    --enable-shared \</div><div class="line">    --disable-static \</div><div class="line">    --disable-doc \</div><div class="line">    --disable-ffmpeg \</div><div class="line">    --disable-ffplay \</div><div class="line">    --disable-ffprobe \</div><div class="line">    --disable-ffserver \</div><div class="line">    --disable-avdevice \</div><div class="line">    --disable-doc \</div><div class="line">    --disable-symver \</div><div class="line">    --cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \</div><div class="line">    --target-os=linux \</div><div class="line">    --arch=arm \</div><div class="line">    --enable-cross-compile \</div><div class="line">    --sysroot=$SYSROOT \</div><div class="line">    --extra-cflags=&quot;-Os -fpic $ADDI_CFLAGS&quot; \</div><div class="line">    --extra-ldflags=&quot;$ADDI_LDFLAGS&quot; \</div><div class="line">    $ADDITIONAL_CONFIGURE_FLAG</div><div class="line">make clean</div><div class="line">make</div><div class="line">make install</div><div class="line">&#125;</div><div class="line">CPU=arm</div><div class="line">PREFIX=$(pwd)/android/$CPU</div><div class="line">ADDI_CFLAGS=&quot;-marm&quot;</div><div class="line">build_one</div></pre></td></tr></table></figure></p>
<p> 注意要把NDK的位置改为自己本地NDK的位置。然后双击运行 <strong>MinGW安装目录\msys\1.0\msys.bat</strong> 文件，启动MinGW命令行，切换到FFmpeg目录下，运行build_android.sh脚本，开始编译：</p>
<p> <img src="compile.png" alt="compile"></p>
<p> 编译过程有点慢，这个跟电脑的速度有关。大概半小时后，编译完成，FFmpeg目录下多了一个android文件夹：</p>
<p> <img src="android.png" alt="android"></p>
<p> 打开android-&gt;arm-&gt;lib:</p>
<p> <img src="finish.png" alt="finish"></p>
<p>编译成功。至于集成到Android平台，可以查阅官方API文档，通过JNI方式调用相关接口即可。</p>
<p>FFmpeg功能十分强大，很多音视频处理的工作都会用到它，以后还需要深入研究。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在linux下编译FFmpeg很方便，但在Windows下还是有不少坑的，试了下使用Windows+MinGW编译FFmpeg，过程还是挺顺利的。记录一下(这里针对的平台是Android)。&lt;br&gt;
    
    </summary>
    
    
      <category term="FFmpeg" scheme="https://forevas.github.io/tags/FFmpeg/"/>
    
      <category term="MinGW" scheme="https://forevas.github.io/tags/MinGW/"/>
    
  </entry>
  
  <entry>
    <title>搭建Shadowsocks代理服务实现科学上网</title>
    <link href="https://forevas.github.io/2017/03/05/%E6%90%AD%E5%BB%BAShadowsocks%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <id>https://forevas.github.io/2017/03/05/搭建Shadowsocks代理服务实现科学上网/</id>
    <published>2017-03-05T08:16:37.000Z</published>
    <updated>2017-03-12T08:29:11.188Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，由于GFW的存在，Google，YouTube等一系列网站被挡在了墙外，这样一来很多优质资源都无法访问。作为一名程序猿，平时工作需要查阅不少资料，用百度很不方便。之前也用过第三方的VPN和免费蓝灯，但是总感觉不安全，而且不是很稳定。而自己除了本职工作之外，平时也喜欢研究一些相关技术，所以就萌生了自己搭建VPN的想法。经过一段时间的折腾，VPN是搭好了，结果发现完全连不上，后来了解到使用PPTP协议的VPN早都被封了。之后经过研究，发现Shadowsocks代理很方便，自己也成功的搭建了服务。这里总结下自己搭建的过程，以供以后参阅：<br><a id="more"></a></p>
<p>先来分析一波原理，没有耐心看的可以直接跳转到搭建过程~~</p>
<h1 id="关于GFW"><a href="#关于GFW" class="headerlink" title="关于GFW"></a>关于GFW</h1><p>GFW(Great Firewall of China)是一套建立在我国骨干网国际出口上的网络内容检测和过滤系统，国内所有的运营商的流量最后全部都要接入GFW的机房之后才能够出国。这套系统功能就是过滤不和谐的内容,实现的方法主要是IP封锁，DNS劫持和污染，关键字检测等手段。</p>
<p align="center"><img src="/2017/03/05/搭建Shadowsocks代理服务实现科学上网/GFW工作原理.png" alt="GFW工作原理" title="GFW工作原理"></p>

<h2 id="IP封锁："><a href="#IP封锁：" class="headerlink" title="IP封锁："></a>IP封锁：</h2><p>IP封锁是指防火墙维护一张IP黑名单，会将一些不想让你访问的网站的IP收入其中，一旦发现发往黑名单中地址的请求数据包，就直接将其丢弃，这将导致源主机得不到目标主机的及时响应而引发超时，从而达到屏蔽对目标主机的访问的目的。</p>
<h2 id="DNS劫持和污染："><a href="#DNS劫持和污染：" class="headerlink" title="DNS劫持和污染："></a>DNS劫持和污染：</h2><p>DNS劫持又称域名劫持，是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能反应或访问的是假网址。</p>
<p>域名服务器缓存污染（DNS cache pollution），又称域名服务器缓存投毒（DNS cache poisoning），是指一些刻意制造或无意中制造出来的域名服务器封包，把域名指往不正确的IP地址。一般来说，在互联网上都有可信赖的域名服务器，但为减低网络上的流量压力，一般的域名服务器都会把从上游的域名服务器获得的解析记录暂存起来，待下次有其他机器要求解析域名时，可以立即提供服务。一旦有关域名的局域域名服务器的缓存受到污染，就会把域名内的电脑导引往错误的服务器或服务器的网址。</p>
<h2 id="关键字检测"><a href="#关键字检测" class="headerlink" title="关键字检测"></a>关键字检测</h2><p>GFW一旦发现连接有敏感词，就会伪装成连接两方，向真正的对方发送 RST 数据包。由于RST标示复位、可以用来异常的关闭连接。所以收到RST数据包会导致连接关闭，从而达到阻断连接的目的。</p>
<p>所以想要绕过GFW必须克服以上的封锁手段。</p>
<h1 id="关于VPN"><a href="#关于VPN" class="headerlink" title="关于VPN"></a>关于VPN</h1><p>虚拟专用网（英语：Virtual Private Network，简称VPN），是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。虚拟私人网络的讯息透过公用的网络架构（例如：互联网）来传送内联网的网络讯息。它利用已加密的通道协议（Tunneling Protocol）来达到保密、发送端认证、消息准确性等私人消息安全效果。这种技术可以用不安全的网络（例如：互联网）来发送可靠、安全的消息。</p>
<p align="center"><img src="/2017/03/05/搭建Shadowsocks代理服务实现科学上网/VPN翻墙原理.png" alt="VPN翻墙原理" title="VPN翻墙原理"></p>

<p>上图基本说明了VPN的原理，首先客户端访问VPN服务器(前提是VPN服务器没有被墙)，然后建立加密的数据通道，通道建立之后，用户就可以通过VPN访问目标网站。不过VPN的流量特征很明显，握手阶段依然是明文，导致匹配流量特征很容易。在VPN科学上网这方面，一些地区已经根据VPN的流量特征做出了相应的匹配策略，可以有效封杀VPN了，像我之前用的PPTP协议基本上已经没办法再用了。</p>
<h1 id="关于Socks5"><a href="#关于Socks5" class="headerlink" title="关于Socks5"></a>关于Socks5</h1><p>Socks5是一个代理协议，它工作在OSI七层模型的会话层，它对于上层协议(HTTP,FTP,SMTP等)是透明的，当我们打开本地代理后，本地Socks5客户端会通过事先和服务端协商好的加密协议对请求数据进行加密，这就避免了VPN握手阶段明文的问题，服务器收到请求后解密数据转发给真正的目标服务器，返回的数据也会进行加密再返回，整个通信过程均采用加密通信，至今也没有发现明显的流量特征，因此不会被GFW察觉。</p>
<p align="center"><img src="/2017/03/05/搭建Shadowsocks代理服务实现科学上网/shadowsocks翻墙原理.png" alt="shadowsocks翻墙原理" title="shadowsocks翻墙原理"></p>

<h1 id="关于Shadowsocks"><a href="#关于Shadowsocks" class="headerlink" title="关于Shadowsocks"></a>关于Shadowsocks</h1><p>一款基于Socks5协议实现的软件，分为服务端和客户端，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。</p>
<h1 id="关于锐速"><a href="#关于锐速" class="headerlink" title="关于锐速"></a>关于锐速</h1><p>一款加速软件，原理是通过算法优化TCP的拥塞控制机制，预判并及时重传可能的丢包，从而实现加速的效果。我们搭建好了Socks代理之后会用到它，否则会有点卡。</p>
<p>好了，关于基础的一些理论就研究到这里，废话不多说，开始我们的搭建过程吧。</p>
<h1 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h1><h2 id="创建VPS"><a href="#创建VPS" class="headerlink" title="创建VPS"></a>创建VPS</h2><p>第一步，我们需要租一个位于国外的VPS，这里给大家推荐<a href="https://www.digitalocean.com/" target="_blank" rel="external">DigitalOcean</a>,每个月最低只要5$，而且支持<a href="https://www.paypal.com/cn/home" target="_blank" rel="external">Paypal</a>支付，很方便。</p>
<p>在首页输入账号和密码注册，验证后点击 Create Droplet创建服务器，系统会提示充值，可以使用信用卡支付，若你的信用卡不支持可以选择用<a href="https://www.paypal.com/cn/home" target="_blank" rel="external">Paypal</a>支付(可以想象成支付宝)，没有<a href="https://www.paypal.com/cn/home" target="_blank" rel="external">Paypal</a>账户的话直接去申请一个，绑定一张银联卡，国内大行的卡都可以。然后进行支付即可。<br><img src="注册页面.png" alt="注册页面"></p>
<hr>
<p>支付完成后就可以创建VPS了，点击右上角 Create Droplet，然后选择操作系统，这里我选择的是Ubuntu14.04x64的系统，不要选太高版本，后面要装的锐速不支持太高版本的内核。</p>
<p align="center"><img src="选择操作系统.png" alt="选择操作系统"></p>

<hr>
<p>VPS配置选择，若只用于上网，选最低配置足够了。</p>
<p align="center"><img src="选择服务器配置.png" alt="选择服务器配置"></p>

<hr>
<p>机房位置推荐San Francisco的机房，感觉速度还可以，之前试过New York的，感觉速度一般，大家可以点击<a href="http://speedtest-nyc1.digitalocean.com/" target="_blank" rel="external">这里</a>测一下各个结点的网络状况，选择最适合自己的即可。</p>
<p align="center"><img src="选择机房位置.png" alt="选择机房位置"></p>

<hr>
<p>SSH Key配置，配置了之后可以使用密钥登录，这个比用密码登录的安全系数要高。密钥形式登录的原理是：利用密钥生成器制作一对密钥——一只公钥和一只私钥。将公钥添加到服务器的某个账户上，然后在客户端利用私钥即可完成认证并登录。这里先不讨论这个问题了，下文的链接有生成密钥的方法。直接点击Create即可。</p>
<p align="center"><img src="sshkey配置.png" alt="sshkey配置"></p>

<hr>
<p>到这里后，服务器就创建好了，一定要牢记IP Address，以后登录服务器都要用到它。</p>
<p align="center"><img src="创建完成.png" alt="创建完成.png"></p>


<hr>
<h2 id="登录并初始化"><a href="#登录并初始化" class="headerlink" title="登录并初始化"></a>登录并初始化</h2><p>现在我们已经可以登录这台服务器了。Linux下就不用说了，相信对大家来说都很简单。主要说说Windows，首先我们需要一个Shell终端，Putty、XShell等等都可以，这里我使用了Git(一款免费、开源的分布式版本控制系统)自带的Shell终端，这里不管你使用的是哪种Shell终端，打开命令行后，输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh root@your_ip</div></pre></td></tr></table></figure>
<p><code>your_ip</code>换成要换成刚才创建的服务器的IP地址。登录成功后会看到如下界面：</p>
<p align="center"><img src="登录成功.png" alt="登录成功"></p>


<p>然后执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># apt-get update</div></pre></td></tr></table></figure></p>
<p>更新软件包列表：</p>
<p align="center"><img src="更新软件包列表.png" alt="更新软件包列表"></p>

<p>官方推荐<a href="https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-14-04" target="_blank" rel="external">这篇教程</a>来提高服务器的安全性，大家有空可以看一下。</p>
<h2 id="配置Socks5代理"><a href="#配置Socks5代理" class="headerlink" title="配置Socks5代理"></a>配置Socks5代理</h2><p>执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># apt-get install python-m2crypto</div><div class="line"># apt-get install python-pip</div><div class="line"># pip install shadowsocks</div></pre></td></tr></table></figure></p>
<p>至此，shadowsocks服务端已经成功安装，然后执行以下命令编辑配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/shadowsocks.json</div></pre></td></tr></table></figure></p>
<p>文件内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;server&quot;:&quot;your_server_ip&quot;,</div><div class="line">    &quot;server_port&quot;:8388,</div><div class="line">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,</div><div class="line">    &quot;local_port&quot;:1080,</div><div class="line">    &quot;password&quot;:&quot;choose_your_password&quot;,</div><div class="line">    &quot;timeout&quot;:300,</div><div class="line">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</div><div class="line">    &quot;fast_open&quot;: false</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将<code>your_server_ip</code>替换为你的服务器IP，<code>choose_your_password</code>替换为自己想要设置的密码(这个密码将用来验证连接者的身份)，然后保存退出。</p>
<p>执行以下命令启动服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># ssserver -c /etc/shadowsocks.json -d start</div></pre></td></tr></table></figure></p>
<p>想要停止服务则执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># ssserver -d stop</div></pre></td></tr></table></figure></p>
<p>至此，socks5代理服务已经配置成功。接下来配置本地代理。</p>
<h2 id="本地代理配置"><a href="#本地代理配置" class="headerlink" title="本地代理配置"></a>本地代理配置</h2><p>点击<a href="https://shadowsocks.org/en/download/clients.html" target="_blank" rel="external">这里</a>下载Shadowsocks客户端，这里只说下windows下的配置方法，下载完之后运行，配置如下：</p>
<p></p><p align="center"><img src="本地配置.png" alt="本地配置"></p><br>输入服务器的IP地址，还有和服务器端约定好的端口和密码，保持加密方式一致，点击确定，右键右下角图标开启系统代理，现在我们已经可以访问Google、Facebook、Twitter等网站了。手机端可以去Google Play下载影梭，配置方法同上。<p></p>
<p></p><p align="center"><img src="google.png" alt="Google"></p><br>如果只是看看网页查查资料的话现在已经足够了，不过若是想上Youtube看高清视频仅仅这样还是不够的，接下来说下锐速的配置过程。<p></p>
<h1 id="锐速加速"><a href="#锐速加速" class="headerlink" title="锐速加速"></a>锐速加速</h1><p>首先得确定我们的VPS究竟是采用了哪种虚拟化技术，openvz 还是 kvm 还是 xen 或者是 vmare，如果是openvz，那么很遗憾，锐速不支持openvz。具体查看方法之前试了好几种，感觉这种方法比较靠谱，执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># ifconfig</div></pre></td></tr></table></figure></p>
<p>查看网卡信息，openvz的一般都是venet0:<em> ，xen、kvm的一般都是eth</em>。</p>
<p></p><p align="left"><img src="网卡信息.png" alt="网卡信息"></p><br>然后查看系统内核信息，这个在我们每次登录服务器的欢迎界面就可以看到：<p></p>
<p></p><p align="left"><img src="系统内核.png" alt="系统内核"></p><br>因为锐速对于某些版本的内核是不支持的，可以在<a href="https://www.91yun.org/serverspeeder91yun" target="_blank" rel="external">这里</a>查看自己的系统内核是否支持。<br>如果不支持的话就要更换系统内核了，更换系统内核的方法可以参考<a href="https://blessing.studio/ubuntu-14-04-change-kernel-to-install-serverspeeder/" target="_blank" rel="external">这篇教程</a>，这里不再赘述。<p></p>
<p>假设现在你的系统内核已经可以支持锐速，那么执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/serverspeeder/master/serverspeeder-all.sh &amp;&amp; bash serverspeeder-all.sh</div></pre></td></tr></table></figure></p>
<p>如果内核完全匹配就会自动下载安装。</p>
<p>接下来执行以下命令重启锐速：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># service serverSpeeder restart</div></pre></td></tr></table></figure></p>
<p>配置完成。打开YouTube，随便点开一个视频：</p>
<p></p><p align="center"><img src="YouTube.png" alt="YouTube"></p><br>720P,无压力。<p></p>
<p>至此，全部配置过程完成。第一次正式写博客，居然写了这么长…<br><img src="亚丝娜.jpg" alt="亚丝娜"></p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://zh.wikipedia.org/wiki/%E9%98%B2%E7%81%AB%E9%95%BF%E5%9F%8E" target="_blank" rel="external">虚拟专用网</a><br><a href="https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E7%A7%81%E4%BA%BA%E7%B6%B2%E8%B7%AF" target="_blank" rel="external">防火长城</a><br><a href="http://www.people.virginia.edu/~tq7bw/vpn/" target="_blank" rel="external">建立自己的VPN服务器</a><br><a href="https://www.91yun.org/archives/683" target="_blank" rel="external">锐速破解版linux一键自动安装包</a><br><a href="https://www.freehao123.com/vps-ssh/" target="_blank" rel="external">Ubuntu 14.04 更换内核以安装锐速</a><br><a href="https://www.freehao123.com/vps-ssh/" target="_blank" rel="external">增强VPS安全</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，由于GFW的存在，Google，YouTube等一系列网站被挡在了墙外，这样一来很多优质资源都无法访问。作为一名程序猿，平时工作需要查阅不少资料，用百度很不方便。之前也用过第三方的VPN和免费蓝灯，但是总感觉不安全，而且不是很稳定。而自己除了本职工作之外，平时也喜欢研究一些相关技术，所以就萌生了自己搭建VPN的想法。经过一段时间的折腾，VPN是搭好了，结果发现完全连不上，后来了解到使用PPTP协议的VPN早都被封了。之后经过研究，发现Shadowsocks代理很方便，自己也成功的搭建了服务。这里总结下自己搭建的过程，以供以后参阅：&lt;br&gt;
    
    </summary>
    
    
      <category term="Shadowsocks" scheme="https://forevas.github.io/tags/Shadowsocks/"/>
    
      <category term="Socks5" scheme="https://forevas.github.io/tags/Socks5/"/>
    
      <category term="VPS" scheme="https://forevas.github.io/tags/VPS/"/>
    
      <category term="GFW" scheme="https://forevas.github.io/tags/GFW/"/>
    
      <category term="锐速" scheme="https://forevas.github.io/tags/%E9%94%90%E9%80%9F/"/>
    
  </entry>
  
  <entry>
    <title>新的开始</title>
    <link href="https://forevas.github.io/2017/01/08/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
    <id>https://forevas.github.io/2017/01/08/新的开始/</id>
    <published>2017-01-08T15:05:14.000Z</published>
    <updated>2017-08-22T15:19:40.404Z</updated>
    
    <content type="html"><![CDATA[<p>之前看到很多个人博客，不仅内容优秀，而且布局精美。所以一直想着自己也搞一个个人博客，奈何因为工作原因和自己比较懒，一直没有下决心去做。好在最近发现了hexo，其简洁性和实用性深深地吸引了我，历经N久的瞎折腾，个人博客终于搭建好了，看着自己的劳动成果，感觉自己花费的时间也没有白费。下定决心，从今天开始，开始写博客。<br><a id="more"></a><br>下面是一些常用的语法：</p>
<h1 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h1><p>在文章中插入引言，可包含作者、来源和标题。</p>
<h2 id="别号：-quote"><a href="#别号：-quote" class="headerlink" title="别号： quote"></a>别号： quote</h2><blockquote><p>content</p>
<footer><strong>[author[</strong><cite>source]] [link] [source_link_title]</cite></footer></blockquote>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>没有提供参数，则只输出普通的 blockquote<br><blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</p>
</blockquote></p>
<h2 id="引用书上的句子"><a href="#引用书上的句子" class="headerlink" title="引用书上的句子"></a>引用书上的句子</h2><blockquote><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p>
<footer><strong>David Levithan</strong><cite>Wide Awake</cite></footer></blockquote>
<h2 id="引用-Twitter"><a href="#引用-Twitter" class="headerlink" title="引用 Twitter"></a>引用 Twitter</h2><blockquote><p>NEW: DevDocs now comes with syntax highlighting. <a href="http://devdocs.io" target="_blank" rel="external">http://devdocs.io</a></p>
<footer><strong>@DevDocs</strong><cite><a href="https://twitter.com/devdocs/status/356095192085962752" target="_blank" rel="external">twitter.com/devdocs/status/356095192085962752</a></cite></footer></blockquote>
<h2 id="引用网络上的文章"><a href="#引用网络上的文章" class="headerlink" title="引用网络上的文章"></a>引用网络上的文章</h2><blockquote><p>Every interaction is both precious and an opportunity to delight.</p>
<footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html" target="_blank" rel="external">Welcome to Island Marketing</a></cite></footer></blockquote>
<h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>在文章中插入代码。<br>别名： code<br><figure class="highlight plain"><figcaption><span>[title] [] [url] [link text]</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">code snippet</div></pre></td></tr></table></figure></p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><p>普通的代码块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(&apos;Hello World!&apos;);</div></pre></td></tr></table></figure><br>指定语言<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[rectangle setX: <span class="number">10</span> y: <span class="number">10</span> width: <span class="number">20</span> height: <span class="number">20</span>];</div></pre></td></tr></table></figure><br>附加说明<br><figure class="highlight plain"><figcaption><span>Array.map</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array.map(callback[, thisArg])</div></pre></td></tr></table></figure><br>附加说明和网址<br><figure class="highlight plain"><figcaption><span>_.compact</span><a href="http://underscorejs.org/#compact" target="_blank" rel="external">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_.compact([0, 1, false, 2, &apos;&apos;, 3]);</div><div class="line">=&gt; [1, 2, 3]</div></pre></td></tr></table></figure></p>
<h1 id="反引号代码块"><a href="#反引号代码块" class="headerlink" title="反引号代码块"></a>反引号代码块</h1><p>另一种形式的代码块，不同的是它使用三个反引号来包裹。</p>
<p><code>[language] [title] [url] [link text] code snippet</code></p>
<h1 id="Pull-Quote"><a href="#Pull-Quote" class="headerlink" title="Pull Quote"></a>Pull Quote</h1><p>在文章中插入 Pull quote。<br><blockquote class="pullquote [class]"><p>content</p>
</blockquote></p>
<h1 id="jsFiddle"><a href="#jsFiddle" class="headerlink" title="jsFiddle"></a>jsFiddle</h1><p>在文章中嵌入 jsFiddle。<br><iframe scrolling="no" width="[width]" height="[height]" src="http://jsfiddle.net/shorttag/embedded/[tabs]/[skin]" frameborder="0" allowfullscreen></iframe></p>
<h1 id="Gist"><a href="#Gist" class="headerlink" title="Gist"></a>Gist</h1><p>在文章中嵌入 Gist。<br><script src="//gist.github.com/gist_id.js?file=[filename]"></script></p>
<h1 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h1><p>在文章中插入 iframe。<br><iframe src="url" width="[width]" height="[height]" frameborder="0" allowfullscreen></iframe></p>
<h1 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h1><p>在文章中插入指定大小的图片。<br><img src="/path/to/image" class="[class names]" title="[width] [height] [title text [alt text]]"></p>
<h1 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h1><p>在文章中插入链接，并自动给外部链接添加 target=”_blank” 属性。<br><a>text url [external] [title]</a></p>
<h1 id="Include-Code"><a href="#Include-Code" class="headerlink" title="Include Code"></a>Include Code</h1><p>插入 source 文件夹内的代码文件。<br></p>
<h1 id="Youtube"><a href="#Youtube" class="headerlink" title="Youtube"></a>Youtube</h1><p>在文章中插入 Youtube 视频。<br><div class="video-container"><iframe src="//www.youtube.com/embed/video_id" frameborder="0" allowfullscreen></iframe></div></p>
<h1 id="Vimeo"><a href="#Vimeo" class="headerlink" title="Vimeo"></a>Vimeo</h1><p>在文章中插入 Vimeo 视频。<br><div class="video-container"><iframe src="//player.vimeo.com/video/video_id" frameborder="0" allowfullscreen></iframe></div></p>
<h1 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h1><p>引用其他文章的链接。<br><br></p>
<h1 id="引用资源"><a href="#引用资源" class="headerlink" title="引用资源"></a>引用资源</h1><p>引用文章的资源。<br><br><br></p>
<h1 id="Raw"><a href="#Raw" class="headerlink" title="Raw"></a>Raw</h1><p>如果您想在文章中插入 Swig 标签，可以尝试使用 Raw 标签，以免发生解析异常。<br>
content
</p>
<blockquote>
<p>Every interaction is both precious and an opportunity to delight.</p>
</blockquote>
<h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><p>$$J_\alpha(x)=\sum _{m=0}^\infty \frac{(-1)^ m}{m! \, \Gamma (m + \alpha + 1)}{\left({\frac{x}{2}}\right)}^{2 m + \alpha }$$</p>
<h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><p align="center"><font size="6">我是居中变大的字</font></p>

<p>比较了一下，感觉Markdown语法和swing语法混合使用体验最好，各取所长吧。</p>
<p><img src="saber.jpg" alt="saber"></p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">hexo文档</a><br><a href="http://www.appinn.com/markdown/" target="_blank" rel="external">Markdown语法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前看到很多个人博客，不仅内容优秀，而且布局精美。所以一直想着自己也搞一个个人博客，奈何因为工作原因和自己比较懒，一直没有下决心去做。好在最近发现了hexo，其简洁性和实用性深深地吸引了我，历经N久的瞎折腾，个人博客终于搭建好了，看着自己的劳动成果，感觉自己花费的时间也没有白费。下定决心，从今天开始，开始写博客。&lt;br&gt;
    
    </summary>
    
    
      <category term="Test" scheme="https://forevas.github.io/tags/Test/"/>
    
  </entry>
  
</feed>
