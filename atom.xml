<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>厚德载物，追求卓越</title>
  <subtitle>我的征途是星辰大海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://forevas.github.io/"/>
  <updated>2018-05-22T15:42:37.580Z</updated>
  <id>https://forevas.github.io/</id>
  
  <author>
    <name>Forevas</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络协议五层模型</title>
    <link href="https://forevas.github.io/2018/05/04/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
    <id>https://forevas.github.io/2018/05/04/网络协议五层模型/</id>
    <published>2018-05-04T15:31:02.000Z</published>
    <updated>2018-05-22T15:42:37.580Z</updated>
    
    <content type="html"><![CDATA[<p>最近把大学时的计算机网络教程又拿出来啃了一遍，感觉好多知识都还给老师了，所以还是得时常看看，温故而知新，写篇读书笔记记录一下。由于OSI七层模型划分的过于细致，实际应用一般不会划分这么细，所以这里只讨论五层模型。<br><a id="more"></a></p>
<h3 id="1-物理层"><a href="#1-物理层" class="headerlink" title="1.物理层"></a>1.物理层</h3><p>物理层考虑的是如何传输比特流，定义硬件标准等等。</p>
<h4 id="调制解调"><a href="#调制解调" class="headerlink" title="调制解调"></a>调制解调</h4><p>将数字信号转化为模拟信号，将模拟信号还原为数字信号，此过程为调制解调。(调制解调器的作用)</p>
<h4 id="ADSL，FTTX，无线接入技术"><a href="#ADSL，FTTX，无线接入技术" class="headerlink" title="ADSL，FTTX，无线接入技术"></a>ADSL，FTTX，无线接入技术</h4><p>互联网发展的早期，用传统电话线来进行网络接入，低频段用来电话语音数据传输，高频段进行网络数据传输，互不影响。</p>
<p>FTTX只要指的是光纤接入技术。</p>
<p>前几种都是有线接入，无线接入技术主要用于移动设备。包括现在的物联网等等。</p>
<h3 id="2-数据链路层"><a href="#2-数据链路层" class="headerlink" title="2.数据链路层"></a>2.数据链路层</h3><p>传输数据帧.将上层数据封装成帧，差错检测，超时重传。不过超时重传并不是必须的。PPP协议(点对点传输协议)是数据链路层应用最广泛的协议。对上层提供不可靠的服务。</p>
<h4 id="PPP协议特点"><a href="#PPP协议特点" class="headerlink" title="PPP协议特点"></a>PPP协议特点</h4><p>1.简单 2.封装成帧 3.透明性 4.多种网络层协议和多种类型链路 5.差错检测 6.检测连接状态 7.最大传送单元 8.网络层地址协商</p>
<h4 id="CRC以及FCS"><a href="#CRC以及FCS" class="headerlink" title="CRC以及FCS"></a>CRC以及FCS</h4><p>循环冗余检验CRC是一种检错方法，帧检验序列FCS是添加在数据后面的冗余码</p>
<h5 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h5><p>最大传输单元，帧的数据部分不能超过MTU数值，不同协议的MTU数值也不一样。</p>
<h4 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h4><p>以太网是目前主流的局域网标准，提供不可靠的交付，注意PPP协议是工作在广域网的，不是工作在这里的。</p>
<p>以太网的结构有总线型，星型(配合集线器)。星型结构在逻辑上还是总线型。在同一时刻之多只允许一个站点发送数据。</p>
<h5 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA/CD协议"></a>CSMA/CD协议</h5><p>载波监听多点接入/碰撞检测的缩写。协议要点：<br>1.多点接入 2.载波监听 3.碰撞检测<br>CSMA/CD协议是半双工通信，只能进行双向交替通信。</p>
<h5 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h5><p>网络接口卡(Network Interface Card)，目前的计算机主板上都已经嵌入了网卡，所以叫适配器更合适一点。</p>
<p>适配器上面有处理器和存储器(包括RAM和ROM)，适配器和局域网之间的通信是以串行传输方式进行的，而适配器和计算机主板上的IO总线是以并行传输方式进行的。适配器的一个重要功能就是串行和并行的转换。</p>
<p>适配器收到正确的帧之后使用中断通知计算机并交付给协议栈中的网络层。当要发送IP数据报时，由协议栈把IP数据报向下交给适配器，组装成帧后发送到局域网。</p>
<h5 id="以太网的MAC层"><a href="#以太网的MAC层" class="headerlink" title="以太网的MAC层"></a>以太网的MAC层</h5><h6 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h6><p>MAC地址信息在适配器的ROM中，IP地址在计算机的存储器中。<br>MAC地址48位，全球唯一。RA是局域网全球地址的法定管理机构。</p>
<h6 id="MAC帧"><a href="#MAC帧" class="headerlink" title="MAC帧"></a>MAC帧</h6><p>分类：1.单播 2.广播 3.多播<br>适配器可以以<strong>混杂方式</strong>进行工作，可以监听到以太网上的所有帧，黑客经常这么搞。</p>
<p>MAC帧和PPP帧不一样，不要混为一谈，MAC帧只是工作在以太网之中，而PPP帧工作在广域网上，所以PPP是有帧结束定界符的。</p>
<p>MAC帧的长度为64-1518字节之间。</p>
<h4 id="扩展的以太网"><a href="#扩展的以太网" class="headerlink" title="扩展的以太网"></a>扩展的以太网</h4><h5 id="在物理层扩展以太网"><a href="#在物理层扩展以太网" class="headerlink" title="在物理层扩展以太网"></a>在物理层扩展以太网</h5><p>通过光纤，集线器等扩展以太网的规模</p>
<h5 id="在数据链路层扩展以太网"><a href="#在数据链路层扩展以太网" class="headerlink" title="在数据链路层扩展以太网"></a>在数据链路层扩展以太网</h5><h6 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h6><p>网桥工作在数据链路层，集线器工作在物理层。网桥根据MAC帧的目的地址对帧进行转发和过滤，网桥收到帧后不是向所有的接口发送此帧，而是先检查此帧的目的MAC地址，然后在确定发到哪个接口，或者将其丢弃。</p>
<p>网桥经历了一代又一代的更新，现在我们使用的为以太网交换机，其本质为一个多接口的网桥。其内部的帧转发表也是通过自学习算法逐渐建立起来的。</p>
<h6 id="VLAN-虚拟局域网"><a href="#VLAN-虚拟局域网" class="headerlink" title="VLAN(虚拟局域网)"></a>VLAN(虚拟局域网)</h6><p>在一个局域网中逻辑性的划分多个虚拟局域网，虚拟局域网在逻辑上相互独立，交换机不会将一个虚拟局域网的广播数据发送到其他的其它的虚拟局域网中去。</p>
<p>注意交换机是星型结构，每个主机和交换机直连，所以交换机可以精确控制每一台主机发出的帧数据。不同于总线结构，总线上的所有主机都会被动收到其它主机发出的帧数据。</p>
<h4 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h4><p>高速以太网可以全双工方式工作，所以CSMA/CD协议对其不起效果。不过在半双工方式工作的时候，仍然要使用CSMA/CD协议。</p>
<h4 id="PPPoE-PPP-over-Ethernet"><a href="#PPPoE-PPP-over-Ethernet" class="headerlink" title="PPPoE(PPP over Ethernet)"></a>PPPoE(PPP over Ethernet)</h4><p>在以太网上运行PPP。</p>
<p>当用户利用ADSL进行宽带上网时，PC到发出帧经过ADSL之后，就转换为ADSL使用的PPP帧，这种方式不能称为以太网上网，而是利用电话线接入到因特网。</p>
<h4 id="无线局域网-WLAN"><a href="#无线局域网-WLAN" class="headerlink" title="无线局域网(WLAN)"></a>无线局域网(WLAN)</h4><p>在MAC层使用CSMA/CA协议以及停止等待协议</p>
<h4 id="对于PPP和MAC层的一些看法"><a href="#对于PPP和MAC层的一些看法" class="headerlink" title="对于PPP和MAC层的一些看法"></a>对于PPP和MAC层的一些看法</h4><p>PPP协议是点对点传输，所以PPPoE应该是用MAC帧封装了ppp帧，这样才能在以太网上面传输。</p>
<p>路由器之间进行通信，如果要经过以太网，则必然要使用ARP，当然也会用MAC帧，若路由器直连，之间不经过以太网，则不会用到MAC帧。</p>
<h3 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3.网络层"></a>3.网络层</h3><p>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。</p>
<h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><p>IP协议是TCP/IP体系最主要的协议之一。与IP配套使用的还有以下四个协议：</p>
<ul>
<li>地址解析协议ARP</li>
<li>你地址解析协议RARP</li>
<li>网际控制报文协议ICMP</li>
<li>网际组管理协议IGMP</li>
</ul>
<p>物理层使用的中间设备叫转发器，如集线器<br>链路层使用的叫网桥或者桥接器，如交换机<br>网络层使用的中间设备是路由器。<br>网络层以上的叫网关，用网关连接两个不兼容的系统需要在高层进行协议的转换。</p>
<h5 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h5><p>IP地址由网络号和主机号组成。根据网络号可以对IP地址进行分类。</p>
<h6 id="IP地址的划分"><a href="#IP地址的划分" class="headerlink" title="IP地址的划分"></a>IP地址的划分</h6><ul>
<li>A类 0开头 0-127</li>
<li>B类 10开头 128-191</li>
<li>C类 110开头 192-223</li>
<li>D类 1110开头</li>
<li>E类 11110开头</li>
</ul>
<p>A类，B类和C类都是单播地址，D类为多播地址，E类保留为以后用。</p>
<p>不过现在广泛使用无分类IP地址(CIDR)进行路由选择，IP地址分类基本已经成为了历史。</p>
<p>IP地址中的网络号全0表示本网络。</p>
<p>网络号为127保留为本地软件<strong>环回测试</strong>本主机的进程之间的通信只用。若主机发送为127开头的数据包，则不会把数据报发送到任何网络。</p>
<p>全0的主机号表示当前主机所在的网络地址，全1的主机号表示该网络上的所有主机。</p>
<h4 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h4><p>已经知道了一个机器的IP地址，需要找出其相应的物理地址。就需要使用到ARP协议。</p>
<p>APR使用MAC帧进行封装，以广播的方式在以太网上工作，每一个主机都设有一个ARP高速缓存。</p>
<h4 id="IP数据报的格式"><a href="#IP数据报的格式" class="headerlink" title="IP数据报的格式"></a>IP数据报的格式</h4><p>首部：固定部分20个字节，可选字段长度可变，最长不超过40个字节。不过长度必须是4字节的整数倍，不足的部分用全0填充。</p>
<h5 id="首部组成"><a href="#首部组成" class="headerlink" title="首部组成"></a>首部组成</h5><ol>
<li>版本 4位</li>
<li>首部长度 4位</li>
<li>区分服务 8位</li>
<li>总长度 16位</li>
<li>标识 16位</li>
<li>标志 3位</li>
<li>片偏移 13位</li>
<li>生存时间 8位</li>
<li>协议 8位</li>
<li>首部检验和 16位</li>
<li>原地址 32位</li>
<li>目的地址 32位</li>
<li>可变部分 长度不定</li>
</ol>
<h4 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h4><p>从两级IP地址到三级IP地址。为了解决IP地址利用率低，减少路由表的规模，以及解决两级IP不够灵活的问题。</p>
<p>具体做法是将主机号的前几位作为子网号，可以将一个大型网络划分为多个子网号。</p>
<h5 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h5><p>子网掩码是一个网络或一个子网的重要属性，IP地址与其逐位相与，便可得出网络号。例如A类地址默认的子网掩码为255.0.0.0</p>
<p>子网网络号不能为全1或者全0，但随着CIDR的使用，现在全1和全0的子网号也可以使用了。</p>
<p>划分子网增加了灵活性，但是却减少了能够连接在网络上的主机总数。</p>
<p>使用子网划分后，路由表必须包含目的网络地址、子网掩码和下一跳地址(接口0，接口1…)。</p>
<h4 id="无分类编址CIDR-构造超网"><a href="#无分类编址CIDR-构造超网" class="headerlink" title="无分类编址CIDR(构造超网)"></a>无分类编址CIDR(构造超网)</h4><p>CIDR取消了传统的A类，B类，C类以及划分子网的概念，因而可以更有效的利用IPv4的网络空间。CIDR将IP地址分为两部分，网络前缀和主机号。</p>
<p>CIDR使用<strong>斜线记法</strong>，或称为<strong>CIDR</strong>记法。例如：128.14.35.7/20，斜线后的数字表示网络前缀的位数。</p>
<p>全0和全1的主机号一般并不使用。</p>
<p>CIDR也使用地址掩码，也可以进行子网划分。不过子网的网络前缀肯定是比整个组织的网络前缀长的。</p>
<p>由于一个CIDR地址块中有很多地址，所以在路由表中就利用CIDR地址块来查找目的网络，这种地址的聚合称为<strong>路由聚合</strong>，也称为<strong>构成超网</strong>。使用路由聚合，使得路由表的复杂度大大降低。(因为我们可以将多个长前缀的网络地址块聚合为一个短前缀地址块，当然，这几个长前缀地址块要有相同的短地址前缀)</p>
<p>使用CIDR时，路由器查找路由表进行匹配时，当使用最长前缀匹配规则。</p>
<h4 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h4><p>ICMP允许主机或者路由器报告差错情况和提供有关异常情况的报告。ICMP报文使用IP数据报进行封装。</p>
<p>ICMP报文分为ICMP差错报告报文和ICMP询问报文。</p>
<h5 id="ICMP差错报告报文"><a href="#ICMP差错报告报文" class="headerlink" title="ICMP差错报告报文"></a>ICMP差错报告报文</h5><p>分类：</p>
<ol>
<li>终点不可达</li>
<li>源点抑制</li>
<li>时间超过</li>
<li>参数问题</li>
<li>改变路由(重定向)</li>
</ol>
<h5 id="ICMP询问报文"><a href="#ICMP询问报文" class="headerlink" title="ICMP询问报文"></a>ICMP询问报文</h5><ol>
<li>回送请求和回答</li>
<li>时间戳请求和回答</li>
</ol>
<h5 id="ICMP的应用"><a href="#ICMP的应用" class="headerlink" title="ICMP的应用"></a>ICMP的应用</h5><p>ping命令和traceroute。</p>
<p>ping命令的原理主要是利用询问报文回送请求和回送回答报文。</p>
<p>traceroute是利用差错报告报文，主要原理是利用TTL值逐渐递增，经过的路由器逐个回送时间超过差错报告报文，直至返回终点不可达。</p>
<h4 id="因特网的路由选择协议"><a href="#因特网的路由选择协议" class="headerlink" title="因特网的路由选择协议"></a>因特网的路由选择协议</h4><h5 id="内部网关协议RIP"><a href="#内部网关协议RIP" class="headerlink" title="内部网关协议RIP"></a>内部网关协议RIP</h5><p>路由信息协议RIP是基于距离向量的路由选择协议，每一跳距离加1。<br>特点：</p>
<ol>
<li>仅和相邻路由器交换信息。</li>
<li>交换的是自己的路由表，全部信息。</li>
<li>固定间隔交换</li>
</ol>
<p>RIP协议可以收敛，过程较快。不过目的是找出到每个网络的最短距离。</p>
<p>优点：实现简单，开销较小。</p>
<p>缺点：当网络出现故障时，要经过较长时间才能将此信息传送到所有的路由器。路由的最大跳数不能超过15，16时即不可达。所以RIP只适用于小型互联网。</p>
<h5 id="内部网关协议OSPF"><a href="#内部网关协议OSPF" class="headerlink" title="内部网关协议OSPF"></a>内部网关协议OSPF</h5><p>开放最短路径优先OSPF，使用最短路径算法SPF，每个路由器都有一个链路状态数据库，这个数据库实际上是全网的拓扑机构图，然后通过最短路径算法生成路由表，</p>
<p>这个数据库一开始的建立是通过洪泛法进行的，既路由器向所有输出端口发送信息，收到信息的路由器右再次转发给其它路由器，最终所有路由器都会收到信息。</p>
<p>OSPF可以将一个自治系统划分为若干个更小的范围，叫做区域，区域可以将洪泛法交换链路状态信息的范围局限于每一个区域，而不是整个自治系统，减少了整个网络上的通信量。区域之间通过区域边界路由器进行通信。自治系统之间的通信通过自治系统边界路由器进行。</p>
<p>优点：链路的代价可以自定义。相同代价的链路可以负载平衡。鉴别的功能，保证了仅在可信赖的路由器之间交换链路状态信息。支持子网划分和CIDR，链路状态更新及时。最重要的是可以有层次的划分，使得每一个区域交换路由信息的通信量大大减小。</p>
<h6 id="OSPF五种类型"><a href="#OSPF五种类型" class="headerlink" title="OSPF五种类型"></a>OSPF五种类型</h6><ol>
<li>问候分组</li>
<li>数据库描述分组</li>
<li>链路状态请求</li>
<li>链路状态更新</li>
<li>链路状态确认</li>
</ol>
<h5 id="外部网关协议BGP"><a href="#外部网关协议BGP" class="headerlink" title="外部网关协议BGP"></a>外部网关协议BGP</h5><p>BGP用于AS(自治系统)之间的路由，由于因特网的规模太大，所以不能使用OSPF等协议，而且AS之间的路由选择必须考虑有关策略。</p>
<p>BGP力求寻找比较好的路由，而并非最佳路由，采用<strong>路径向量</strong>协议。</p>
<p>每个AS管理员需要选择至少一个路由器作为该AS的”BGP发言人”，一般选择BGP的边界路由器。</p>
<p>BGP发言人之间通过TCP连接建立BGP会话，利用BGP会话交换路由信息。每一个BGP发言人不仅要运行BGP协议，还要运行本AS的内部网关协议。</p>
<p>BGP协议交换路由信息的节点数量级是自治系统的量级，这比自治系统中的网络数少很多。因此路由选择不会过于复杂。</p>
<p>BGP协议可以有效防止兜圈子，BGP支持CIDR，因此路由表中包括目的前缀，下一跳路由器，以及到达该网络要经过的各个自治系统序列。如果发现自己在这条路径中，就不能采用这条路径。</p>
<h6 id="BGP报文类型"><a href="#BGP报文类型" class="headerlink" title="BGP报文类型"></a>BGP报文类型</h6><ol>
<li>OPEN</li>
<li>UPDATE</li>
<li>KEEPALIVE</li>
<li>NOTIFICATION</li>
</ol>
<h5 id="路由器的构成"><a href="#路由器的构成" class="headerlink" title="路由器的构成"></a>路由器的构成</h5><p>路由器由路由选择部分(控制部分)和分组转发部分构成。</p>
<p>路由控制部分根据所选的协议构造出路由表，并和相邻路由器交换路由信息而不断地更新和维护路由表。</p>
<p>分组转发部分由交换结构，一组输入端口和一组输出端口(这里的端口就是硬件接口)。</p>
<p>路由器有数据缓冲区，来不及转发的数据报会进入缓存队列，不过若是缓存区满了，后来的数据报只能被丢弃。</p>
<h4 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h4><p>广域网的多播还没办法完全实现，需要多播路由器的支持。需要用到IGMP(网际组管理协议)和多播路由协议。</p>
<p>IP多播使用D类IP地址。</p>
<p>局域网的硬件多播。以太网的多播地址范围是从01-00-5E-00-00-00到01-00-5E-7F-FF-FF.</p>
<h4 id="本地地址和虚拟专用网VPN"><a href="#本地地址和虚拟专用网VPN" class="headerlink" title="本地地址和虚拟专用网VPN"></a>本地地址和虚拟专用网VPN</h4><p>由于IP地址的紧缺，不可能做到IP和主机一一对应，而且，一个机构内部的主机很多时候要和本机构内的其它主机进行通信。如果使用TCP/IP协议，那么这个时候内部的主机的IP地址可以由本机构分配，这种仅在本机构有效的IP地址称为本地地址。</p>
<p>为了避免IP地址的二义性问题，RFC 1918指定了一些专用地址，在因特网中的所有路由器，对目的地址为专用地址的数据报一律不进行转发。</p>
<p>专用地址为：</p>
<ol>
<li>10.0.0.0-10.255.255.255(或记为10/8)</li>
<li>172.16.0.0-172.31.255.255(或记为172.16/12)</li>
<li>192.168.0.0-192.168.255.255(或记为192.168/16)</li>
</ol>
<p>本地地址的主机访问因特网需要用到NAT或NAPT映射技术。</p>
<p>VPN又被称为内联网，VPN技术可以使得同一个机构，不同地点的部门使用共同的网络环境。VPN将因特网作为不同地点相互交流的通信载体，使用者需要先登入机构的VPN服务器，通过认证，建立加密隧道，然后才能进行内部数据访问。</p>
<h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><p>IPv6是解决IP地址耗尽的根本措施。</p>
<h5 id="IPv6的特点"><a href="#IPv6的特点" class="headerlink" title="IPv6的特点"></a>IPv6的特点</h5><ol>
<li>更大的地址空间(128位地址)</li>
<li>灵活的首部格式</li>
<li>改进的选项</li>
<li>支持即插即用</li>
<li>支持资源的预分配</li>
<li>IPv6首部采用8字节对齐</li>
<li>目的地址可以是单播多播和任播</li>
<li>使用冒号十六进制记法</li>
</ol>
<p>IPv6的过渡可以使用双协议栈或隧道技术。</p>
<h3 id="4-传输层"><a href="#4-传输层" class="headerlink" title="4.传输层"></a>4.传输层</h3><p>传输层向应用进程之间提供端到端的逻辑通信。</p>
<h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><p>传输层使用协议端口号对通信进程进行区分。端口用一个16位端口号进行标志，最多可允许65535个端口号。</p>
<h5 id="熟知端口"><a href="#熟知端口" class="headerlink" title="熟知端口"></a>熟知端口</h5><p>0-1023.由IANA负责分配给一些常用的应用层程序固定使用。例如：</p>
<p>FTP:21,TELENT:23,SMTP:25,DNS:53,TFTP:69,HTTP:80,SNMP:161,SNMP:162,HTTPS:443.</p>
<h5 id="登记端口"><a href="#登记端口" class="headerlink" title="登记端口"></a>登记端口</h5><p>1024-49151,IANA不分配也不控制，但是可以在IANA注册登记，以防重复使用。</p>
<h5 id="动态端口"><a href="#动态端口" class="headerlink" title="动态端口"></a>动态端口</h5><p>49151-65535，用户自己发起通信时可以临时使用，没有什么限制。</p>
<h4 id="用户数据报协议UDP"><a href="#用户数据报协议UDP" class="headerlink" title="用户数据报协议UDP"></a>用户数据报协议UDP</h4><h5 id="UDP的特点："><a href="#UDP的特点：" class="headerlink" title="UDP的特点："></a>UDP的特点：</h5><ol>
<li>无连接</li>
<li>最大努力交付</li>
<li>没有拥塞控制</li>
<li>面向报文</li>
<li>支持一对一，一对多，多对一，多对多的交互通信</li>
<li>8个字节的首部开销</li>
</ol>
<h5 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h5><ol>
<li>源端口</li>
<li>目的端口</li>
<li>长度</li>
<li>检验和</li>
</ol>
<p>每个字段都是两个字节。UDP的差错检验要加入12个字节的伪首部，而且在检验时，是将首部和数据部分一起都检验的。</p>
<h4 id="传输控制协议TCP"><a href="#传输控制协议TCP" class="headerlink" title="传输控制协议TCP"></a>传输控制协议TCP</h4><p>TCP提供全双工的可靠交付服务，和UDP的最大区别是：TCP是面向连接的，而UDP是无连接的。TCP还有流量控制和拥塞控制机制。</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol>
<li>面向连接</li>
<li>点对点</li>
<li>可靠交付</li>
<li>全双工通信</li>
<li>面向字节流</li>
</ol>
<h5 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h5><ol>
<li>源端口和目的端口  各2个字节</li>
<li>序号    4字节</li>
<li>确认号  4字节</li>
<li>数据偏移 4位 指出TCP报文的数据部分距离TCP报文起始处有多远，这里的单位是4字节的倍数，所有数据偏移最大长度为60字节，这是TCP报文首部的最大长度</li>
<li>保留  6位</li>
<li>标志位  分为紧急URG，确认ACK，推送PSH，复位RST，同步SYN，终止FIN   这6种标志各占1位</li>
<li>窗口  2字节</li>
<li>检验和  2字节 和UDP检验方式类似</li>
<li>选项 长度可变</li>
</ol>
<p>TCP报文首部20字节固定长度，40字节的可变长度，最大为60字节。</p>
<p><strong>MSS</strong>:最大报文段长度，默认是536字节，所以TCP默认最大556字节。MSS=TCP报文长度-TCP首部长度。</p>
<h5 id="TCP的可靠数据传输"><a href="#TCP的可靠数据传输" class="headerlink" title="TCP的可靠数据传输"></a>TCP的可靠数据传输</h5><h6 id="数据编号与确认"><a href="#数据编号与确认" class="headerlink" title="数据编号与确认"></a>数据编号与确认</h6><p>TCP将应用层交下来的长报文看成是一个个字节组成的数据流，并使每一个字节对应于一个序号。在连接建立时，双方TCP要各自确定初始序号。TCP报文首部中的序号字段数值标识该报文段中紧接着首部后面的第一个数据字节的序号。</p>
<p>TCP使用积累确认，即确认是对所有按序接收到的数据的确认。接收方返回的确认号是已按序收到的数据的最高序号加一。也就是说确认号表示接收方期望下次收到的数据中的第一个数据字节序号。</p>
<p>确认信息可以使用捎带确认，但是不能超过0.5s.</p>
<h6 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h6><p>TCP采用滑动窗口协议来提高报文段的传输效率。</p>
<p>TCP发送端维护一个发送窗口，落入发送窗口的数据可以被发送，窗口外左侧是已发送并受到确认的字节。窗口外右侧是还不能被发送的字节，窗口收到确认则向右移动，知道左侧边缘正好包含确认号的字节。</p>
<p>TCP的流量控制和拥塞控制会根据情况动态的调整发送窗口的上限值，从而控制发送数据的平均速率。</p>
<h6 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h6><p>RTT(Round-Trip Time):往返时延<br>RTTs:平均往返时延<br>RTO(Retransmission Time-Out):计时器设置的超时重传时间</p>
<p>超时重传时间的计算可参考RFC 2988.</p>
<h6 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h6><p>发送端一脸受到三个重复的确认时，就应该立即重传丢失的报文段，而不必等待重传计时器超时。</p>
<h5 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h5><p>流量控制服务用于解决因发送方发送数据太快，而导致接收方来不及接收，以至于接收方缓存溢出的问题。</p>
<p>TCP接收方要维持一个接收窗口(rwnd, receiver window)的变量，其值不能大于接收缓存的大小。</p>
<p>TCP报文首部的窗口字段写入的字段就是当前接收方的接收窗口大小。注意，只有ACK置为1时确认号字段才有意义。</p>
<p>发送方要根据接收方回传的窗口大小动态的调整自己的发送窗口大小。</p>
<h5 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h5><p>这里要注意，SYN和FIN都要消耗一个序列号，ACK报文不携带数据的情况下，ACK不消耗序列号，但若是携带数据的话，则是要消耗序列号的。基本上现实的TCP通信中，除了SYN，发送TCP报文时都会带上ACK标志的，可以提高信道的利用率。</p>
<h6 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h6><ol>
<li>客户端发送 SYN=1，seq=x 到服务端</li>
<li>服务端返回 SYN=1，ACK=1，seq=y，ack=x+1 到客户端</li>
<li>客户端发送 ACK=1，seq=x+1,ack=y+1 到服务端</li>
</ol>
<p>这里的seq表示序列号，ack表示确认号。</p>
<p>三次握手后，连接建立。</p>
<h6 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h6><ol>
<li>客户端发送 FIN=1，seq=u 到服务端</li>
<li>服务端返回 ACK=1，seq=v，ack=u+1 到客户端，现在已经进入了半关闭状态，不过这只是表示客户端告诉服务器，我已经没什么要发给你了，但是你要是还有什么要发给我的，我还可以接收(这种情况极少，基本上不会再发数据了)。</li>
<li>服务端发送 FIN=1，seq=v，ack=u+1 到客户端</li>
<li>客户端返回 ACK=1，seq=u+1，ack=v+1 到服务端</li>
</ol>
<p>四次挥手后，连接断开。</p>
<p><strong>TCB</strong>：传输控制程序块(Transmission Control Block),它存储了每一个连接中的一些重要信息，如TCP连接表，到发送和接收缓存的指针，到重传队列的指针，当前的发送和接收序号等等。</p>
<h4 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h4><p>网络传输的带宽是有限的，当网络中出现太多的分组时，网络性能会开始下降，这种情况称为拥塞，而当拥塞达到一定程度，甚至会造成死锁，网络传输的吞吐量为0.</p>
<p>所谓拥塞控制就是防止过多的数据注入到网络中，避免路由器或者链路过载。</p>
<p>拥塞控制分为开环控制和闭环控制，开环控制试图用良好的设计来解决问题，当系统运行起来后，不需要中途修正，也就是说不需要考虑网络的当前状态。</p>
<p>鉴于互联网的复杂性，开环控制基本上不可能实现，所以还是说说闭环控制吧。</p>
<p>闭环控制算法又分为显式反馈算法和隐式反馈算法。显示就是利用ICMP类似的机制来实现，不过拥堵已经发生，如果再使用这种机制，无异于火上浇油。所以TCP用的是隐式反馈算法。</p>
<h5 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h5><p>TCP的发送方维持一个拥塞窗口(cwnd, congestion window)的变量.拥塞窗口取决于网络的拥塞程度，动态变化。TCP发送方确定发送速率时，既要根据接收方的接受能力，又要考虑不使网络发生拥塞。所以：</p>
<p>发送窗口的上限值=Min[rwnd,cwnd]</p>
<p>TCP发送方通过分组丢失来判断网络是否发生了拥堵，所以，当重传计数器超时或者接收到三个重复确认时，TCP的发送方就认为网络发生了拥堵。</p>
<p>TCP发送方采用<strong>慢开始(slow-start)</strong> , <strong>拥塞避免(congestion avoidance)</strong> , <strong>快速重传(fast retransmit)</strong> 和 <strong>快速恢复(fast recovery)</strong> 算法来改变发送速率。</p>
<h6 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h6><p>由小到大逐渐增大发送发的拥塞窗口数值，可将拥塞窗口数值设置为1个MSS的数值，每收到一个对新的报文段的确认后，将拥塞窗口增加至多一个MSS的数值。</p>
<p>由此可见，慢开始每过一个RTT，发送速率几乎增加一倍，所以这个“慢”，其实指的是一开始发送速率很慢，并不是指拥塞窗口的增长速率慢。</p>
<p>当慢开始的cwnd达到<strong>慢开始门限ssthresh</strong>时，停止慢开始算法而使用拥塞避免算法。</p>
<p>具体做法是拥塞避免算法每经过大约一个RTT时间就将cwnd增加一个RSS大小。实际做法是，每收到一个确认，就将cwnd增加MSS*(MSS/cwnd).这样cwnd按线性缓慢增长，比慢开始慢的多。</p>
<p>无论是在慢开始阶段还是拥塞避免阶段，只要发现出现网络拥堵，就立即将cwnd置为1，并执行慢开始算法。同时将ssthresh设置为出现拥堵时的发送窗口的一半。</p>
<h6 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h6><p>由于重传计数器超时和收到三个重复的ACK时，当前的网络拥堵状况是不一样的，收到三个重复的ACK意味着当前的网络并不是特别拥堵。所以这里应该使用快速恢复算法</p>
<p>快速恢复算法将ssthresh置为发送窗口的一半，这一点和慢启动一样，不同的是并不将cwnd直接置为1，而是从ssthresh开始执行拥塞避免算法。</p>
<h3 id="5-应用层"><a href="#5-应用层" class="headerlink" title="5.应用层"></a>5.应用层</h3><h4 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h4><p>将域名和ip地址进行映射。DNS除了这个功能外，还提供主机别名，负载分配，反向域名解析等功能。</p>
<h5 id="域名结构"><a href="#域名结构" class="headerlink" title="域名结构"></a>域名结构</h5><p>xxx.三级域名.二级域名.顶级域名</p>
<h5 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h5><p>根域名服务器，顶级域名服务器，权限域名服务器，本地域名服务器</p>
<p>域名解析过程分为递归查询和迭代查询。</p>
<h5 id="统一资源定位符URL"><a href="#统一资源定位符URL" class="headerlink" title="统一资源定位符URL"></a>统一资源定位符URL</h5><p>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</p>
<h5 id="超文本传输协议HTTP"><a href="#超文本传输协议HTTP" class="headerlink" title="超文本传输协议HTTP"></a>超文本传输协议HTTP</h5><p>HTTP使用TCP作为传输层协议，是一个无状态协议。</p>
<h6 id="非持续连接与持续连接"><a href="#非持续连接与持续连接" class="headerlink" title="非持续连接与持续连接"></a>非持续连接与持续连接</h6><p>HTTP/1.0采用非持续连接方式，每次请求对应一个TCP连接。</p>
<p>HTTP/1.1使用持续连接方式，同一个客户和该服务器可以在这条连接上传送后续的HTTP请求报文和响应报文。</p>
<p>HTTP/1.1还可以使用流水线方式工作，即客户可以连续发送多个请求报文，这样一个接一个的请求报文到达服务器后，服务器就发回一个接一个的报文响应，使TCP连接中的空闲时间减少，提高了网络传输的效率。</p>
<h6 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h6><p>代理服务器又称为万维网缓存，代理服务器把最近的一些请求和响应暂存在本地磁盘中，当新请求到来时，若代理服务器发现这个请求与暂时存放的请求相同，就返回暂存的响应。例如校园网解决网络拥堵和时延过高的问题。</p>
<h6 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h6><p><strong>请求报文</strong>–从客户端向服务器发送请求报文。<br><strong>响应报文</strong>–从服务端到客户的回答。</p>
<ol>
<li>请求行/状态行：用于区分是请求报文还是响应报文。在请求报文中第一行是请求行，在响应报文中第一行是状态行。</li>
<li>首部行：用来说明浏览器、服务器或报文主体的一些信息。</li>
<li>实体主体：请求报文一般没有这个字段，有些响应报文中可能没有这个字段。</li>
</ol>
<p>请求行只有三个内容：方法，请求资源URL以及HTTP的版本。</p>
<p>方法有：OPTION,GET,HEAD,POST,PUT,DELETE,TRACE,CONNECT</p>
<p>状态行包括三项内容：HTTP的版本，状态码以及解释状态码的简单短语。</p>
<p>状态码：1xx表示通知信息，2xx表示成功，3xx表示重定向，4xx表示客户的差错，5xx表示服务器的差错。</p>
<h6 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h6><p>由于HTTP是无状态的协议，所以服务器为了辨识用户，增加了Cookie机制，Cookie由服务端返回，浏览器将其存在本地。下次再次进行请求时，会带上Cookie请求，服务器通过Cookie判断当前用户的身份。</p>
<h5 id="万维网的文档"><a href="#万维网的文档" class="headerlink" title="万维网的文档"></a>万维网的文档</h5><h6 id="超文本标记语言HTML"><a href="#超文本标记语言HTML" class="headerlink" title="超文本标记语言HTML"></a>超文本标记语言HTML</h6><p>静态文档</p>
<h6 id="动态文档"><a href="#动态文档" class="headerlink" title="动态文档"></a>动态文档</h6><p>动态文档技术主要有：CGI，PHP，JSP，ASP</p>
<h6 id="活动文档"><a href="#活动文档" class="headerlink" title="活动文档"></a>活动文档</h6><p>活动文档技术主要有: java applet,javaScript,ActionScript等</p>
<p>目前万维网上的文档都是这三种文档的混合体。</p>
<h5 id="电子邮件-e-mail"><a href="#电子邮件-e-mail" class="headerlink" title="电子邮件(e-mail)"></a>电子邮件(e-mail)</h5><h6 id="简单邮件传送协议SMTP"><a href="#简单邮件传送协议SMTP" class="headerlink" title="简单邮件传送协议SMTP"></a>简单邮件传送协议SMTP</h6><p>用于从用户代理到邮件服务器以及在邮件服务器之间的邮件传送。</p>
<h6 id="邮件读取协议POP3和IMAP"><a href="#邮件读取协议POP3和IMAP" class="headerlink" title="邮件读取协议POP3和IMAP"></a>邮件读取协议POP3和IMAP</h6><p>用户代理从邮件服务器读取邮件时要用到这两个协议。IMAP比POP3复杂得多，不过IMAP提供的功能也比较多，IMAP允许用户管理邮件服务器上面的邮件。</p>
<h6 id="通用因特网邮件扩充MIME"><a href="#通用因特网邮件扩充MIME" class="headerlink" title="通用因特网邮件扩充MIME"></a>通用因特网邮件扩充MIME</h6><p>由于SMTP限于传送7位的ASCII码，不能传送可执行文件或其他二进制对象(因为以解读ASCII码的形式解读二进制文件，会产生大量的特殊字符)。</p>
<p>MIME没有改动或者取代SMTP，只是一个辅助协议。MIME将非ASCII码数据转换为ASCII码数据，交给SMTP传送。在接收方再把收到的数据转换为原来的ASCII码数据。</p>
<p>MIME新增5个首部：</p>
<ol>
<li>MIME-Version</li>
<li>Content-Description</li>
<li>Content-Id</li>
<li>Content-Transfer-Encoding</li>
<li>Content-Type</li>
</ol>
<p>内容传送编码：</p>
<p><strong>quoted-printable</strong> : 适用于少量的非ASCII码。对于每个字节，如果是可打印的ASCII码，除了’=’之外，都不改变。如果不能打印，则将每个字节的二进制代码用两个十六进制数字表示，然后在前面再加上一个等号 ‘=’。如果全是不可打印的字符的话，则编码的开销达到200%。也就是32位的数据编码后会达到96位的长度。如果全是可打印的二进制码的话，则开销为0。</p>
<p><strong>Base64</strong>：将二进制码划分为一个个24位长的单元，然后将每一个24位单元划分为4个6位组，每个6位组按以下方式转换为ASCII码。0-63分别对应26个大写字母，26个小写字母，0-9，+代表62，/代表63。用 == 表示末尾只有8位，用 = 表示末尾是16位。因为如果结尾的长度不足24位，需要用全0填充至24位。所以需要用到 == 和 = 来说明具体是多少位。</p>
<p>内容类型：</p>
<p>Text,Image,Audio,Video,Application,Message,multipart</p>
<p>子类型：</p>
<p>plain,richtext,gif,jpeg,basic,mpeg,octet-stream,partial,external-body,mixed,alternative,parallel,digest.</p>
<h5 id="文件传输协议FTP"><a href="#文件传输协议FTP" class="headerlink" title="文件传输协议FTP"></a>文件传输协议FTP</h5><p>用于文件传输。。。</p>
<h5 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h5><p>一台计算机连接到因特网需要配置以下参数：</p>
<ol>
<li>IP地址</li>
<li>子网掩码</li>
<li>默认路由器的IP地址</li>
<li>域名服务器的IP地址</li>
</ol>
<p>动态主机配置协议DHCP提供了一种机制，称为即插即用联网。允许一台计算机加入新的网络和获取IP地址而不用手工参与。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近把大学时的计算机网络教程又拿出来啃了一遍，感觉好多知识都还给老师了，所以还是得时常看看，温故而知新，写篇读书笔记记录一下。由于OSI七层模型划分的过于细致，实际应用一般不会划分这么细，所以这里只讨论五层模型。&lt;br&gt;
    
    </summary>
    
    
      <category term="基础巩固" scheme="https://forevas.github.io/tags/%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/"/>
    
      <category term="数据结构" scheme="https://forevas.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="https://forevas.github.io/2018/04/09/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>https://forevas.github.io/2018/04/09/红黑树/</id>
    <published>2018-04-09T15:26:02.000Z</published>
    <updated>2018-05-22T15:30:08.950Z</updated>
    
    <content type="html"><![CDATA[<p>红黑树是一种应用非常广泛的数据结构，虽然实现起来挺麻烦，不过其效率很高。Java8之后HashMap的底层使用了哈希表+红黑树来进行实现。<br><a id="more"></a></p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树属于二叉平衡树的一种，常用于二叉查找树。</p>
<h3 id="红黑树定义如下："><a href="#红黑树定义如下：" class="headerlink" title="红黑树定义如下："></a>红黑树定义如下：</h3><ol>
<li>每个节点非黑即红</li>
<li>root节点必须为黑色</li>
<li>所有叶子节点为黑色(这里说的叶子节点指的是NULL)</li>
<li>红色节点的两个子节点必须为黑(换句话说，红色节点不能连续存在)</li>
<li>从root到叶子节点每条路径上的黑色节点数量一样多</li>
</ol>
<h3 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h3><ol>
<li>所有的叶子节点都为NULL</li>
<li>最长路径/最短路径&lt;2 (因为每条路径黑色节点一样多，而红色节点不能连续，所以单条路径上面的黑色节点必定多于红色节点)</li>
<li>插入的新节点都为红色</li>
</ol>
<h3 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h3><h4 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h4><p>修改和查询过程和二叉查找树一致，主要是增删过程，因为红黑树就是为了解决二叉查找树不平衡问题而诞生的，所以在每次增删过后，都要对树的结构进行检查和调整。确保符合红黑树的定义，保证树的平衡性。</p>
<p>红黑树的调整手段有变色和旋转，变色分为红变黑或者黑边红，旋转分为左旋和右旋。</p>
<p>效率：<br>红黑树最差情况下也能达到O(logn),而普通二叉查找树最差情况下会退化为链表，时间复杂度为O(n)</p>
<p>应用：<br>java中的TreeMap,TreeSet,HashMap(java8之后也是红黑树)</p>
<p>完美二叉树可以理解为二进制，111111代表了6层的二叉树，或者说二进制本身就是一棵完美二叉树</p>
<h3 id="具体操作："><a href="#具体操作：" class="headerlink" title="具体操作："></a>具体操作：</h3><h4 id="查找"><a href="#查找" class="headerlink" title="查找:"></a>查找:</h4><p>二叉查找树基本操作</p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入:"></a>插入:</h4><p>这里只讨论左边的情况,右边的也一样,只不过要对称一下.</p>
<p>插入的新节点总是红的.</p>
<p>如果树为空,则将其置为根节点涂黑即可.若父节点为黑色,则不用管,不影响平衡性.若父节点为红,则需要考虑以下情况:</p>
<p>1.若当前节点的父节点为红,父节点的兄弟节点为红—–&gt;将父节点和父节点的兄弟节点都改为黑色,将其祖父节点改为红色,将祖父节点设为当前节点,开始新一轮的平衡调整.</p>
<p>2.若当前节点的父节点为红,父节点的兄弟节点为黑,且插入的是父节点的右子节点.—–&gt;将父节点设为当前节点,以父节点为轴心,左旋</p>
<p>3.若当前节点的父节点为红,父节点的兄弟节点为黑,且插入的是父节点的左子节点.—–&gt;将父节点置黑,将祖父节点置红,以祖父节点为轴心,右旋</p>
<p>至此,调整结束.</p>
<p>如果是从情况1开始发生的，必然会走完情况13或者123，如果从情况2开始发生，那再走个情况3即可完成调整，如果从3开始，那么前两种情况均不走。故变色和旋转之间的先后关系可以表示为：变色-&gt;左旋-&gt;右旋。</p>
<h4 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h4><p>关于删除的操作,是和普通二叉搜索树是一致的,只不过红黑树要考虑删除之后的平衡问题.</p>
<p>如果被删除节点没有子节点,则不影响平衡性.</p>
<p>如果被删除节点只有单子节点,则用单子节点填充,然后检查平衡性,若被删除节点为红,则不用管,若为黑,则要进行平衡操作.这里的平衡操作可以当做双子节点情况下后继节点原位置的平衡处理.</p>
<p>如果被删除节点有双子节点,则要寻找后继节点.</p>
<p>后继节点会被用来填充被删节点的位置，而且后继节点会被改为和被删除节点一致的颜色。所以被删节点的位置的平衡性不用考虑。</p>
<p>如果后继节点没有子节点，则不用考虑后继节点原来位置的平衡性。</p>
<p>如果后继节点为红色，则不影响原来位置的平衡性。这里解释一下，因为后继节点必然不是双子节点，所以从后继节点往下的路径最多为1条,如果为红色，删掉并不影响平衡性。</p>
<p>只有后继节点为黑色的时候才需要考虑平衡性这一点.这个时候要看后继节点原来的子节点的情况:</p>
<p>define 后继节点的子节点 当前节点</p>
<p>0.如果当前节点为红色.—–&gt;直接涂黑就ok</p>
<p>假设当前节点是左子节点:</p>
<p>1.如果当前节点为黑色,其兄弟节点为红色.—–&gt;这个时候将父节点涂红,将兄弟节点涂黑,然后以其父节点为轴心左旋(这时会出现3,4,5的情况).</p>
<p>2.如果当前节点为黑色,其兄弟节点也为黑色,兄弟节点的子节点均为黑色.—–&gt;这个时候将兄弟节点涂为红色.将当前节点指向其父节点,或者说将其父节点设为当前节点,将祖父节点设为父节点,以新的当前节点为开始,继续算法.</p>
<p>3.当前节点是黑色的，且兄弟节点是黑色的，且兄弟节点的左子节点是红色，右子节点时黑色的.—–&gt;将兄弟节点涂红,兄弟节点的左子节点涂黑,以兄弟节点为轴心,右旋.</p>
<p>4.当前节点是黑色的,且兄弟节点是黑色的,且兄弟的右子节点是红色,左子节点任意色.—–&gt;将兄弟结点涂为和父节点一样的颜色,父节点涂黑,兄弟节点的右节点涂黑,以当前节点的父节点为轴心,左旋.(如果旋转后的兄弟节点变成了根节点,若为红色,就要改为黑色).至此,修复完成.</p>
<p>如果是从情况1开始发生的，可能情况2，3，4中的一种：如果是情况2，就不可能再出现3和4；如果是情况3，必然会导致情况4的出现；如果2和3都不是，那必然是4。当然咯，实际中可能不一定会从情况1发生，这要看具体情况了。</p>
<p>归根结底,我们做了这么多的操作就是为了保证红黑树的平衡性,例如左边少了一个黑色节点,而左边自己又补不上,就要右边通过变色旋转往左边补,右边补不上,那就右边也少一个,保持左右平衡,然后问题抛给上一级,让它们头疼去吧,哈哈.</p>
<p>学习这里的难点在于,自己老是想一些不可能存在的状况来测试,走了很多弯路,须知,删除之前,红黑树已经是红黑树了,肯定是相当平衡的.</p>
<p>相比插入,删除是真滴难.</p>
<p>参考链接:<a href="http://blog.csdn.net/eson_15/article/details/51144079" target="_blank" rel="external">http://blog.csdn.net/eson_15/article/details/51144079</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;红黑树是一种应用非常广泛的数据结构，虽然实现起来挺麻烦，不过其效率很高。Java8之后HashMap的底层使用了哈希表+红黑树来进行实现。&lt;br&gt;
    
    </summary>
    
    
      <category term="基础巩固" scheme="https://forevas.github.io/tags/%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/"/>
    
      <category term="数据结构" scheme="https://forevas.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>B-tree和B+tree</title>
    <link href="https://forevas.github.io/2018/03/29/B-tree%E5%92%8CB-tree/"/>
    <id>https://forevas.github.io/2018/03/29/B-tree和B-tree/</id>
    <published>2018-03-29T15:23:37.000Z</published>
    <updated>2018-05-22T15:25:38.828Z</updated>
    
    <content type="html"><![CDATA[<p>B-tree和B+tree是一种多路平衡查找树，常用于数据库索引，或者用于文件系统索引。相对于二叉平衡树，其每个节点会有多个元素和多个子节点，因此深度更小，查找时IO次数也会减少。<br><a id="more"></a></p>
<h4 id="B-tree"><a href="#B-tree" class="headerlink" title="B-tree"></a>B-tree</h4><p>B-tree读法是B Tree，不是“B减树”，这一点需要明确一下。B-tree定义如下：</p>
<ol>
<li><p>定义任意非叶子结点最多只有M个儿子；且M&gt;2；</p>
</li>
<li><p>根结点的儿子数为[2, M]；</p>
</li>
<li><p>除根结点以外的非叶子结点的儿子数为[M/2, M]；</p>
</li>
<li><p>每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）</p>
</li>
<li><p>非叶子结点的关键字个数=指向儿子的指针个数-1；</p>
</li>
<li><p>非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</p>
</li>
<li><p>非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</p>
</li>
<li><p>所有叶子结点位于同一层；</p>
</li>
</ol>
<p><img src="https://note.youdao.com/yws/api/personal/file/DCA929399BB34B0EB0EB003EB8441C99?method=download&amp;shareKey=c1edf02d3eb66a779f4fbf4be211425f" alt="B-tree"></p>
<h5 id="B-tree的特点"><a href="#B-tree的特点" class="headerlink" title="B-tree的特点"></a>B-tree的特点</h5><ol>
<li>关键字集合分布在整颗树中；</li>
<li>任何一个关键字出现且只出现在一个结点中；</li>
<li>搜索有可能在非叶子结点结束；</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找；</li>
<li>自动层次控制；</li>
</ol>
<p>由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并；</p>
<h4 id="B-tree-1"><a href="#B-tree-1" class="headerlink" title="B+tree"></a>B+tree</h4><p>B+树是B-树的变体，其定义基本与B-树同：</p>
<ol>
<li>非叶子结点的子树指针与关键字个数相同；</li>
<li>非叶子结点的子树指针P[i]，指向关键字值属于[K[i],K[i+1])的子树（B-树是开区间）；</li>
<li>为所有叶子结点增加一个链指针；</li>
<li>所有关键字都在叶子结点出现；</li>
</ol>
<p> B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；<br><img src="https://note.youdao.com/yws/api/personal/file/162414AD9D3D449C836DFA7F3CD8EF17?method=download&amp;shareKey=22bdff3a264e4871d20ab34a4d1d06f9" alt="B+tree"></p>
<h5 id="B-tree的特点-1"><a href="#B-tree的特点-1" class="headerlink" title="B+tree的特点"></a>B+tree的特点</h5><ol>
<li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</li>
<li>不可能在非叶子结点命中；</li>
<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li>
<li>更适合文件索引系统；</li>
</ol>
<h5 id="B-tree的优势"><a href="#B-tree的优势" class="headerlink" title="B+tree的优势"></a>B+tree的优势</h5><ol>
<li><p>单一节点存储更多的元素，使得查询的IO次数更少。</p>
</li>
<li><p>所有查询都要查找到叶子节点，查询性能稳定。</p>
</li>
<li><p>所有叶子节点形成有序链表，便于范围查询。</p>
</li>
</ol>
<h4 id="B-tree-2"><a href="#B-tree-2" class="headerlink" title="B*tree"></a>B*tree</h4><p>是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；<br><img src="https://note.youdao.com/yws/api/personal/file/1ACD4A363A76453193B7BF061052ABC1?method=download&amp;shareKey=ccd80e8273d2d6a22ca450cf1ee9716e" alt="B*tree"></p>
<h4 id="B-tree和B-tree的对比"><a href="#B-tree和B-tree的对比" class="headerlink" title="B+tree和B*tree的对比"></a>B+tree和B*tree的对比</h4><p> B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；</p>
<p>B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；</p>
<p>所以，B*树分配新结点的概率比B+树要低，空间使用率更高；</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;B-tree和B+tree是一种多路平衡查找树，常用于数据库索引，或者用于文件系统索引。相对于二叉平衡树，其每个节点会有多个元素和多个子节点，因此深度更小，查找时IO次数也会减少。&lt;br&gt;
    
    </summary>
    
    
      <category term="基础巩固" scheme="https://forevas.github.io/tags/%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/"/>
    
      <category term="数据结构" scheme="https://forevas.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio依赖方式</title>
    <link href="https://forevas.github.io/2018/03/12/Android-Studio%E4%BE%9D%E8%B5%96%E6%96%B9%E5%BC%8F/"/>
    <id>https://forevas.github.io/2018/03/12/Android-Studio依赖方式/</id>
    <published>2018-03-12T15:18:25.000Z</published>
    <updated>2018-05-22T15:22:32.423Z</updated>
    
    <content type="html"><![CDATA[<p>最近将Android Studio升级到了3.X版本，同时Gradle也升级到了4.X，发现现在默认的依赖方式为implementation方式，以前使用的compile方式已经不推荐使用了，这里将2.x和3.x版本所有的依赖方式进行总结下。<br><a id="more"></a></p>
<h4 id="compile-2-0-和api-3-0"><a href="#compile-2-0-和api-3-0" class="headerlink" title="compile(2.0)和api(3.0)"></a>compile(2.0)和api(3.0)</h4><p>compile是对所有的build type以及favlors都会参与编译并且打包到最终的apk文件中。</p>
<h4 id="provided-2-0-和compileOnly-3-0"><a href="#provided-2-0-和compileOnly-3-0" class="headerlink" title="provided(2.0)和compileOnly(3.0)"></a>provided(2.0)和compileOnly(3.0)</h4><p>Provided是对所有的build type以及favlors只在编译时使用，类似eclipse中的external-libs,只参与编译，不打包到最终apk。</p>
<h4 id="apk-2-0-和runtimeOnly-3-0"><a href="#apk-2-0-和runtimeOnly-3-0" class="headerlink" title="apk(2.0)和runtimeOnly(3.0)"></a>apk(2.0)和runtimeOnly(3.0)</h4><p>只会打包到apk文件中，而不参与编译，所以不能再代码中直接调用jar中的类或方法，否则在编译时会报错。应该是在运行时通过反射来调用吧。</p>
<h4 id="implementation-3-0"><a href="#implementation-3-0" class="headerlink" title="implementation(3.0)"></a>implementation(3.0)</h4><p>Android Studio 3.0 新增的依赖模式，例如项目依赖某个Module,而Module又依赖于某个库，如果使用implementation的方式，则主项目不能访问Module所依赖的库。</p>
<h4 id="debugCompile-2-0-和debugApi-3-0-和debugImplementation-3-0"><a href="#debugCompile-2-0-和debugApi-3-0-和debugImplementation-3-0" class="headerlink" title="debugCompile(2.0)和debugApi(3.0)和debugImplementation(3.0)"></a>debugCompile(2.0)和debugApi(3.0)和debugImplementation(3.0)</h4><p>debugCompile 仅仅针对debug模式的编译和最终的debug apk打包。</p>
<h4 id="releaseCompile-2-0-和releaseApi-3-0-和releaseImplementation-3-0"><a href="#releaseCompile-2-0-和releaseApi-3-0-和releaseImplementation-3-0" class="headerlink" title="releaseCompile(2.0)和releaseApi(3.0)和releaseImplementation(3.0)"></a>releaseCompile(2.0)和releaseApi(3.0)和releaseImplementation(3.0)</h4><p>releaseCompile 仅仅针对Release 模式的编译和最终的Release apk打包。</p>
<h4 id="testCompile-2-0-和testApi-3-0-和testImplementation-3-0"><a href="#testCompile-2-0-和testApi-3-0-和testImplementation-3-0" class="headerlink" title="testCompile(2.0)和testApi(3.0)和testImplementation(3.0)"></a>testCompile(2.0)和testApi(3.0)和testImplementation(3.0)</h4><p>testCompile 仅仅是针对单元测试代码的编译编译以及最终打包测试apk时有效，而对正常的debug或者release apk包不起作用。</p>
<h4 id="androidTestCompile-2-0-和androidTestApi-3-0-和androidTestImplementation-3-0"><a href="#androidTestCompile-2-0-和androidTestApi-3-0-和androidTestImplementation-3-0" class="headerlink" title="androidTestCompile(2.0)和androidTestApi(3.0)和androidTestImplementation(3.0)"></a>androidTestCompile(2.0)和androidTestApi(3.0)和androidTestImplementation(3.0)</h4><p>android单元测试时有效，正常的debug和release包无效。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近将Android Studio升级到了3.X版本，同时Gradle也升级到了4.X，发现现在默认的依赖方式为implementation方式，以前使用的compile方式已经不推荐使用了，这里将2.x和3.x版本所有的依赖方式进行总结下。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://forevas.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android进程优先级</title>
    <link href="https://forevas.github.io/2018/03/04/Android%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <id>https://forevas.github.io/2018/03/04/Android进程优先级/</id>
    <published>2018-03-04T15:12:12.000Z</published>
    <updated>2018-05-22T15:16:38.710Z</updated>
    
    <content type="html"><![CDATA[<p>系统的资源是一定的，当开启的进程过多，系统资源不够用时，系统会根据进程的优先级进行判断，优先级低的进程会先被回收。<br><a id="more"></a></p>
<h4 id="前台进程-Foreground-process"><a href="#前台进程-Foreground-process" class="headerlink" title="前台进程(Foreground process)"></a>前台进程(Foreground process)</h4><p>前台进程是用户当前做的事所必须的进程，如果满足下面各种情况中的一种，一个进程被认为是在前台：</p>
<ol>
<li><p>进程持有一个正在与用户交互的Activity。</p>
</li>
<li><p>进程持有一个Service，这个Service处于这几种状态:①Service与用户正在交互的Activity绑定。②Service是在前台运行的，即它调用了 startForeground()。③Service正在执行它的生命周期回调函数（onCreate(), onStart(), or onDestroy()）。</p>
</li>
</ol>
<p>杀死前台进程需要用户交互，因为前台进程的优先级是最高的。</p>
<h4 id="可见进程-Visible-process"><a href="#可见进程-Visible-process" class="headerlink" title="可见进程(Visible process)"></a>可见进程(Visible process)</h4><p>如果一个进程不含有任何前台的组件，但仍可被用户在屏幕上所见。当满足如下任一条件时，进程被认为是可见的：</p>
<p>进程持有一个Activity，这个Activity不在前台，但是仍然被用户可见（处于onPause()调用后又没有调用onStop()的状态，比如，前台的activity打开了一个对话框，这样activity就会在其后可见）。</p>
<p>进程持有一个Service，这个Service和一个可见的（或者前台的）Activity绑定。</p>
<p>可见的进程也被认为是很重要的，一般不会被销毁，除非是为了保证所有前台进程的运行而不得不杀死可见进程的时候。</p>
<h4 id="服务进程-Service-process"><a href="#服务进程-Service-process" class="headerlink" title="服务进程(Service process)"></a>服务进程(Service process)</h4><p>如果一个进程中运行着一个service，这个service是通过 startService() 开启的，并且不属于上面两种较高优先级的情况，这个进程就是一个服务进程。</p>
<p>尽管服务进程没有和用户可以看到的东西绑定，但是它们一般在做的事情是用户关心的，比如后台播放音乐，后台下载数据等。所以系统会尽量维持它们的运行，除非系统内存不足以维持前台进程和可见进程的运行需要。</p>
<h4 id="后台进程-Background-process"><a href="#后台进程-Background-process" class="headerlink" title="后台进程(Background process)"></a>后台进程(Background process)</h4><p>如果进程不属于上面三种情况，但是进程持有一个用户不可见的activity（activity的onStop()被调用，但是onDestroy()没有调用的状态），就认为进程是一个后台进程。</p>
<p>后台进程不直接影响用户体验，系统会为了前台进程、可见进程、服务进程而任意杀死后台进程。</p>
<p>通常会有很多个后台进程存在，它们会被保存在一个LRU (least recently used)列表中，这样就可以确保用户最近使用的activity最后被销毁，即最先销毁时间最远的activity。</p>
<h4 id="空进程-Empty-process"><a href="#空进程-Empty-process" class="headerlink" title="空进程(Empty process)"></a>空进程(Empty process)</h4><p>如果一个进程不包含任何活跃的应用组件，则认为是空进程。<br>例如：一个进程当中已经没有数据在运行了，但是内存当中还为这个应用驻留了一个进程空间。<br>保存这种进程的唯一理由是为了缓存的需要，为了加快下次要启动这个进程中的组件时的启动时间。系统为了平衡进程缓存和底层内核缓存的资源，经常会杀死空进程。</p>
<h4 id="Service保活手段"><a href="#Service保活手段" class="headerlink" title="Service保活手段"></a>Service保活手段</h4><p>1.在AndroidManifest.xml文件中对于intent-filter可以通过android:priority = “1000”这个属性设置最高优先级</p>
<p>2.onStartCommand方法，返回START_STICKY。</p>
<p>3.在onDestroy方法里发广播重启service。</p>
<p>4.监听系统广播判断Service状态。</p>
<p>5.Application加上Persistent属性。</p>
<p>然而在国产ROM面前，并没有什么卵用。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>我们平时Home键退出应用就到了后台进程，返回键退出就到了空进程。</p>
<p>如果存在Service且在运行中(非被可见或者前台bind)就是服务进程。</p>
<p>若是还能看见界面的应用哪怕没有在用至少也是可见进程。</p>
<p>Service被可见进程或前台进程bind为可见进程。</p>
<p>Service被正在和用户交互的Activity绑定或者startForeground启动为前台进程。</p>
<p>正在和用户交互的进程是前台进程。</p>
<p>参考链接：<a href="https://blog.csdn.net/wuseyukui/article/details/48004687" target="_blank" rel="external">https://blog.csdn.net/wuseyukui/article/details/48004687</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;系统的资源是一定的，当开启的进程过多，系统资源不够用时，系统会根据进程的优先级进行判断，优先级低的进程会先被回收。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://forevas.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android View体系</title>
    <link href="https://forevas.github.io/2018/02/25/Android-View%E4%BD%93%E7%B3%BB/"/>
    <id>https://forevas.github.io/2018/02/25/Android-View体系/</id>
    <published>2018-02-25T14:48:14.000Z</published>
    <updated>2018-05-22T15:07:38.565Z</updated>
    
    <content type="html"><![CDATA[<p>以往对于View生命周期的认识停留在onMeasure，onLayout，onDraw等方法上，对Touch事件的传递停留在dispatchTouchEvent，onInterceptTouchEvent，OnTouchEvent等方法上，这样写写自定义控件什么的还是没问题的，不过究其原理，还是有些模糊不清，因为这样的认识还停留在应用层。因此看了下Framework层对于View的组织和管理，以及与Window，ViewRootImpl，WindowManagerService之间的关系。对于整个View体系的认识进一步加深。<br><a id="more"></a></p>
<h4 id="WindowManagerGlobal"><a href="#WindowManagerGlobal" class="headerlink" title="WindowManagerGlobal"></a>WindowManagerGlobal</h4><p>本地所有窗口的管理者，本身是一个单例对象，在很多地方都可以看到它的影子。</p>
<p>例如ActivityThread中的handleLaunchActivity方法中调用了initialize方法，初始化了一个实现IWindowManager接口的binder单例,通过它可以与WMS进行交互。</p>
<p>在WindowManagerImpl中也有实例化的操作，可以看到WindowManagerImpl实际上相当于WindowManagerGlobal的一个代理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public static WindowManagerGlobal getInstance() &#123;</div><div class="line">        synchronized (WindowManagerGlobal.class) &#123;</div><div class="line">            if (sDefaultWindowManager == null) &#123;</div><div class="line">                sDefaultWindowManager = new WindowManagerGlobal();</div><div class="line">            &#125;</div><div class="line">            return sDefaultWindowManager;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static IWindowManager getWindowManagerService() &#123;</div><div class="line">        synchronized (WindowManagerGlobal.class) &#123;</div><div class="line">            if (sWindowManagerService == null) &#123;</div><div class="line">                sWindowManagerService = IWindowManager.Stub.asInterface(</div><div class="line">                        ServiceManager.getService(&quot;window&quot;));</div><div class="line">                try &#123;</div><div class="line">                    sWindowManagerService = getWindowManagerService();</div><div class="line">                    ValueAnimator.setDurationScale(sWindowManagerService.getCurrentAnimatorScale());</div><div class="line">                &#125; catch (RemoteException e) &#123;</div><div class="line">                    throw e.rethrowFromSystemServer();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return sWindowManagerService;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>同时，WindowManagerGlobal持有对当前应用所有窗口的引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private final ArrayList&lt;View&gt; mViews = new ArrayList&lt;View&gt;();//这是每个窗口的根view的集合</div><div class="line">private final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;();//ViewRootImpl的集合，与根View一一对应</div><div class="line">private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams = new ArrayList&lt;WindowManager.LayoutParams&gt;();//根View的布局属性</div><div class="line">private final ArraySet&lt;View&gt; mDyingViews = new ArraySet&lt;View&gt;();//要回收的View</div></pre></td></tr></table></figure></p>
<h4 id="WindowManagerImpl"><a href="#WindowManagerImpl" class="headerlink" title="WindowManagerImpl"></a>WindowManagerImpl</h4><p>实现了WindowManager接口，WindowManager接口继承了ViewManager接口，ViewManager接口定义了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void addView(View view, ViewGroup.LayoutParams params);</div><div class="line">public void updateViewLayout(View view, ViewGroup.LayoutParams params);</div><div class="line">public void removeView(View view);</div></pre></td></tr></table></figure></p>
<p>这几个方法，我们在使用WindowManager实现自定义窗口时经常会用到。</p>
<p>在WindowManagerImpl中，我们可以看到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();</div></pre></td></tr></table></figure></p>
<p>发现几乎所有方法的实现都是通过WindowManagerGlobal来进行的。其实我们也可以看到getSystemService(Context.WINDOW_SERVICE)方法，最终也只是new了一个WindowManagerImpl对象，所以，WindowManagerGlobal才是真正的实现类，全局的管理对象。</p>
<h4 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h4><p>PhoneWindow是Android中Window的唯一实现类，可以看到在Activity.attach方法中，创建了PhoneWindow对象:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mWindow = new PhoneWindow(this, window);    mWindow.setWindowControllerCallback(this);</div><div class="line">mWindow.setCallback(this);</div><div class="line">mWindow.setOnWindowDismissedCallback(this);</div></pre></td></tr></table></figure></p>
<p>这里可以看到Activity实现了Window中定义的相关回调接口，因此我们才能在Activity中收到Touch事件的回调信息，实际上Activity本身并不属于View体系，只是PhoneWindow在分发消息的时候将Activity考虑进去了而已。</p>
<p>Window可以看作一个封装类，对外提供了一系列的回调方法，定义了UI交互的标准，实际上Window本身是一个抽象的概念。可以看到Dialog中自己生成了一个PhoneWindow，而PopupWindow中直接通过WindowManager进行交互，没有生成PhoneWindow。</p>
<p>我们在调用setContentView方法的时候，最终调用的是PhoneWindow.setContentView方法,可以看下这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    public void setContentView(int layoutResID) &#123;</div><div class="line">        if (mContentParent == null) &#123;</div><div class="line">            installDecor();//这种情况下DecorView应该还没有初始化，需要初始化DecorView</div><div class="line">        &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</div><div class="line">            mContentParent.removeAllViews();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</div><div class="line">            final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</div><div class="line">                    getContext());</div><div class="line">            transitionTo(newScene);</div><div class="line">        &#125; else &#123;</div><div class="line">            mLayoutInflater.inflate(layoutResID, mContentParent);//将要设置的的布局加入内容区域</div><div class="line">        &#125;</div><div class="line">        mContentParent.requestApplyInsets();</div><div class="line">        final Callback cb = getCallback();</div><div class="line">        if (cb != null &amp;&amp; !isDestroyed()) &#123;</div><div class="line">            cb.onContentChanged();</div><div class="line">        &#125;</div><div class="line">        mContentParentExplicitlySet = true;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这里我们可以看到，其实通过源码我们可以发现，mContentParent实际上对应id的是android.R.id.content，本质是FragmentLayout。</p>
<p><strong>这里说下DecorView的概念，DecorView为Activity中View的最高级ParentView，其本身继承了FrameLayout，子View一般上是LinearLayout，这个LinearLayout又包含顶部区域和内容区域，其中顶部区域包含状态栏、ActionBar等等不定(根据主题样式变化)，内容区域为一个id的是android.R.id.content的FrameLayout。而我们调用setContentView设置内容布局时，其实就是往这个FrameLayout中添加子View而已。</strong></p>
<p>接着上面分析，如果判断mContentParent为空，则调用installDecor()方法，这个方法中可以看到根据当前的主题初始化了DecorView以及其子View的层级关系，具体过程不再分析。</p>
<p>不过这里有个很重要的操作，mDecor.setWindow(this)，这个将自己传递给了DecorView，从而使DecorView可以拿到Window的Callback，我们可以看看DecorView的这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   public boolean dispatchTouchEvent(MotionEvent ev) &#123;</div><div class="line">       final Window.Callback cb = mWindow.getCallback();</div><div class="line">       return cb != null &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; 0</div><div class="line">               ? cb.dispatchTouchEvent(ev) : super.dispatchTouchEvent(ev);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>通过这个操作，成功的将点击事件传递给了Activity或Dialog等等，让它们也参与了View事件分发的过程。</p>
<h4 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h4><p>从Activity的创建过程到BadTokenException，随处可见Token的影子。那么Token究竟是什么呢?</p>
<p>从Activity的启动流程开始回溯，一直到AMS，再到ActivityRecord中，找到了Token的定义。Token继承于IApplicationToken.Stub，是一个Binder对象，它的作用有两个：</p>
<ol>
<li>作为Binder对象供WMS回调使用</li>
<li>作为ActivityRecord，Activity的唯一标识</li>
</ol>
<p>网上找了一幅图，画的很好：<br><img src="https://note.youdao.com/yws/api/personal/file/3262D834A158455193A6494C9F8A8DCE?method=download&amp;shareKey=0cf3b8a651181c942f68928a761a301c" alt="Token"></p>
<p>所以应用级别的窗口操作必须带上Token，否则就会报BadTokenException。</p>
<h4 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h4><p>在ActivityThread的handleResumeActivity中，我们可以看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</div><div class="line">                r.window = r.activity.getWindow();</div><div class="line">                View decor = r.window.getDecorView();</div><div class="line">                decor.setVisibility(View.INVISIBLE);</div><div class="line">                ViewManager wm = a.getWindowManager();</div><div class="line">                WindowManager.LayoutParams l = r.window.getAttributes();</div><div class="line">                a.mDecor = decor;</div><div class="line">                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</div><div class="line">                l.softInputMode |= forwardBit;</div><div class="line">                if (r.mPreserveWindow) &#123;</div><div class="line">                    a.mWindowAdded = true;</div><div class="line">                    r.mPreserveWindow = false;</div><div class="line">                    // Normally the ViewRoot sets up callbacks with the Activity</div><div class="line">                    // in addView-&gt;ViewRootImpl#setView. If we are instead reusing</div><div class="line">                    // the decor view we have to notify the view root that the</div><div class="line">                    // callbacks may have changed.</div><div class="line">                    ViewRootImpl impl = decor.getViewRootImpl();</div><div class="line">                    if (impl != null) &#123;</div><div class="line">                        impl.notifyChildRebuilt();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                if (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123;</div><div class="line">                    a.mWindowAdded = true;</div><div class="line">                    wm.addView(decor, l);</div><div class="line">                &#125;</div><div class="line">            &#125;</div></pre></td></tr></table></figure></p>
<p>这里通过PhoneWindow拿到了DecorView，将其置为不可见状态(之后会通过r.activity.makeVisible()来置为可见)，然后调用了wm.addView(decor, l)方法，(注意这一步调用了requestLayout引起了scheduleTraversals操作)，跟进去发现，最终调用了WindowManagerGlobal.addView方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//省略判断的代码若干</div><div class="line"></div><div class="line">root = new ViewRootImpl(view.getContext(), display);</div><div class="line"></div><div class="line">            view.setLayoutParams(wparams);</div><div class="line"></div><div class="line">            mViews.add(view);</div><div class="line">            mRoots.add(root);</div><div class="line">            mParams.add(wparams);</div><div class="line"></div><div class="line">            // do this last because it fires off messages to start doing things</div><div class="line">            try &#123;</div><div class="line">                root.setView(view, wparams, panelParentView);</div><div class="line">            &#125; catch (RuntimeException e) &#123;</div><div class="line">                // BadTokenException or InvalidDisplayException, clean up.</div><div class="line">                if (index &gt;= 0) &#123;</div><div class="line">                    removeViewLocked(index, true);</div><div class="line">                &#125;</div><div class="line">                throw e;</div><div class="line">            &#125;</div></pre></td></tr></table></figure></p>
<p>最终我们发现这里创建了ViewRootImpl对象，并将View，ViewRootImpl，Params一一对应保存了起来，最终调用了root.setView()方法。这里我们看下ViewRootImpl的构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public ViewRootImpl(Context context, Display display) &#123;</div><div class="line">        mContext = context;</div><div class="line">        mWindowSession = WindowManagerGlobal.getWindowSession();</div><div class="line">        //......</div><div class="line">        mWindow = new W(this);</div><div class="line">        //......</div><div class="line">        mAttachInfo = new View.AttachInfo(mWindowSession, mWindow, display, this, mHandler, this);</div><div class="line">        //......</div><div class="line">        mChoreographer = Choreographer.getInstance();</div><div class="line">        //......</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到ViewRootImpl构造方法中创建了WindowSession(Binder)，W,AttachInfo,Choreographer等等。</p>
<p>IWindowSession的实现类是服务端的Session类。</p>
<p>至于ViewRootImpl.setView()方法最终调用了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</div><div class="line">                            getHostVisibility(), mDisplay.getDisplayId(),</div><div class="line">                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</div><div class="line">                            mAttachInfo.mOutsets, mInputChannel);</div><div class="line">unscheduleTraversals();//调用performTraversals</div><div class="line">view.assignParent(this);//将自己关联到根View(一般是DecorView)</div></pre></td></tr></table></figure></p>
<p>这个方法将Token随着mWindowAttributes传入WMS，一并传入的还有mInputChannel，mWindow，DisplayId等等。</p>
<p>最终跟到WMS中，发现调用了addWindow方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public int addWindow(Session session, IWindow client, int seq,  </div><div class="line">        WindowManager.LayoutParams attrs, int viewVisibility, int displayId,  </div><div class="line">        Rect outContentInsets, Rect outStableInsets, InputChannel outInputChannel) &#123;  </div><div class="line">        //......  </div><div class="line">        boolean addToken = false;  </div><div class="line">        WindowToken token = mTokenMap.get(attrs.token);  </div><div class="line">        //......  </div><div class="line">        win = new WindowState(this, session, client, token,  </div><div class="line">                attachedWindow, appOp[0], seq, attrs, viewVisibility, displayContent);  </div><div class="line">        win.attach();</div><div class="line">        mWindowMap.put(client.asBinder(), win);  </div><div class="line">        ......  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法会通过attrs拿到Token，然后用Token从mTokenMap去拿本地保存的WindowToken，然后会进行Window层级判断，如果是应用内窗口而且WindowToken为空就返回BadToken，拿到了说明Token有效，然后创建WindowState，并将IWindow作为key，将WindowState存入mWindowMap。</p>
<p>WindowState是Window在WMS中的表现形式，如同ActivityRecord和Activity一样。</p>
<p>ps:WindowState是Window在WMS中的表现形式，ActivityRecord是Activity的表现形式，TaskRecord是Task的表现形式，ActivityStack是所有Task的Manager.</p>
<p>win.attach()方法会调用mSession.windowAddedLocked()，然后会创建SurfaceSession的实例，Session中持有SurfaceSession，SurfaceSession构造方法里调用了nativeCreate，从这里开始就是native的世界，简单概括一下流程是通过创建SurfaceComposerClient与SurfaceFlinger进行交互，锁定一块共享内存。</p>
<p>这里mWindowSession.addToDisplay()方法先告一段落。</p>
<p>可以看到ViewRootImpl.setView()方法之后又执行了unscheduleTraversals()方法，之后发现又调用了performTraversals()方法，这个方法是View的measure，layout，draw的起点。我们平时调用的requestLayout()或者是invalidate()方法,最终都是会回到这个方法，只不过调用的方法不通，其遍历的流程也不一样。</p>
<p>大概看一下这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">if (mFirst) &#123;</div><div class="line">    //......</div><div class="line">    host.dispatchAttachedToWindow(mAttachInfo, 0);//第一次执行需要分发attach事件</div><div class="line"></div><div class="line">&#125;</div><div class="line">//......</div><div class="line">if (viewVisibilityChanged) &#123;//可见性发生变化</div><div class="line">    mAttachInfo.mWindowVisibility = viewVisibility;</div><div class="line">    host.dispatchWindowVisibilityChanged(viewVisibility);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//将之前View.post()方法所积攒的消息加入消息队列.</div><div class="line">//注意只有在mAttachInfo为空的时候(也就是在dispatchAttachedToWindow之前)才会积攒消息.</div><div class="line">//不为空的话是直接加入消息队列的.</div><div class="line">getRunQueue().executeActions(mAttachInfo.mHandler);</div><div class="line">//......</div><div class="line">relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);</div><div class="line">//......</div><div class="line">performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);//measure流程的起点</div><div class="line">//......</div><div class="line">performLayout(lp, mWidth, mHeight);//layout流程的起点</div><div class="line">//......</div><div class="line">performDraw();//draw流程的起点</div></pre></td></tr></table></figure></p>
<p>可以看到，在第一次执行performTraversals()时，会回调dispatchAttachedToWindow，将mAttachInfo传递给View，当View被remove的时候，会回调dispatchDetachFromWindow，mAttachInfo被同一个Window中所有的View所共用，View从mAttachInfo中获取要用的信息。</p>
<p>看下View.post()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public boolean post(Runnable action) &#123;</div><div class="line">        final AttachInfo attachInfo = mAttachInfo;</div><div class="line">        if (attachInfo != null) &#123;</div><div class="line">            return attachInfo.mHandler.post(action);</div><div class="line">        &#125;</div><div class="line">        getRunQueue().post(action);</div><div class="line">        return true;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>如果attachInfo为空，则会将action存入getRunQueue()方法的返回值中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private HandlerActionQueue getRunQueue() &#123;</div><div class="line">        if (mRunQueue == null) &#123;</div><div class="line">            mRunQueue = new HandlerActionQueue();</div><div class="line">        &#125;</div><div class="line">        return mRunQueue;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到getRunQueue是一个队列，它会将消息先存起来，到了performTraversals的时候，再将其加入主线程消息队列进行分发执行。</p>
<p>relayoutWindow最终在WMS中根据Window测量的大小相对应创建出SurfaceControl，通过SurfaceControl.getSurface将ViewRootImpl.mSurface和SurfaceSession锁定的共享内存关联起来，使其拥有了native surface的地址。</p>
<p>开始绘制时，会调用Surface.lockCanvas，由SurfaceFlinger锁定一块共享内存传递给Canvas，内存共享的是设备显存，在上面绘制相当于在屏幕上绘画。绘制结束调用Surface.unlockCanvasAndPost，从Suface上detach掉canvas，释放Surface。</p>
<p>ViewRootImpl本身并不是View，但其实现了ViewParent接口，所以看起来像一个ViewGroup.</p>
<h4 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a>硬件加速</h4><p>不管是硬件加速还是软件绘制，绘制内存的分配都是类似的，都是需要请求SurfaceFlinger服务分配一块内存，两者的绘制都是在APP端，绘制完成之后同样需要通知SurfaceFlinger进行合成。</p>
<p>硬件加速和软件绘制的区别在于，软件绘制是利用CPU进行的，在遍历的过程中进行绘制。而硬件加速则是在遍历的过程中构建操作集合,通过GPU统一绘制渲染，因此效率会高很多。</p>
<p>硬件加速绘制流程会使用renderNode.start返回的DisplayListCanvas，软件绘制时则是mSurface.lockCanvas(dirty)返回的CompatibleCanvas.</p>
<h4 id="Touch事件的传递流程"><a href="#Touch事件的传递流程" class="headerlink" title="Touch事件的传递流程"></a>Touch事件的传递流程</h4><p>这里不谈Touch事件如何在View之间传递，只谈Touch事件是如何传递到View体系的。</p>
<p>我们在ViewRootImpl中可以看到在setView时，调用了mWindowSession.addToDisplay方法，这个方法传递了mInputChannel的参数到WMS，那么mInputChannel是什么呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * An input channel specifies the file descriptors used to send input events to</div><div class="line"> * a window in another process.  It is Parcelable so that it can be sent</div><div class="line"> * to the process that is to receive events.  Only one thread should be reading</div><div class="line"> * from an InputChannel at a time.</div><div class="line"> * @hide</div><div class="line"> */</div></pre></td></tr></table></figure></p>
<p>根据其注释了解到它可以将input event从另一个进程发送到本地来的管道。</p>
<p>看看在WMS中对其做了什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">win.openInputChannel(outInputChannel);</div></pre></td></tr></table></figure></p>
<p>再跟进去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mService.mInputManager.registerInputChannel(mInputChannel, mInputWindowHandle);</div></pre></td></tr></table></figure></p>
<p>发现最终调用了这句话，这里的mInputManager是InputManagerService，可以见的，所有input event都是通过InputManagerService分发下来的，具体细节先不深究了。</p>
<p>那么看看它在ViewRootImpl中的用途：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mInputEventReceiver = new WindowInputEventReceiver(mInputChannel,</div><div class="line">                            Looper.myLooper());</div></pre></td></tr></table></figure></p>
<p>发现在ViewRootImpl.setView中将其作为参数传入了WindowInputEventReceiver的构造方法中。</p>
<p>可以发现WindowInputEventReceiver是一个InputEvent的监听器，收到消息后会进行分发。</p>
<p>最终会分发到ViewPostImeInputStage.processPointerEvent方法中，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private int processPointerEvent(QueuedInputEvent q) &#123;</div><div class="line">            final MotionEvent event = (MotionEvent)q.mEvent;</div><div class="line">            boolean handled = eventTarget.dispatchPointerEvent(event);</div><div class="line">            return handled ? FINISH_HANDLED : FORWARD;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>这里的eventTarget一般来说是DecorView，从这里开始，事件开始正式传入了View体系中。</p>
<p>至于在View体系中的分发流程，这里不再赘述。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://blog.csdn.net/guoqifa29/article/details/46819377" target="_blank" rel="external">https://blog.csdn.net/guoqifa29/article/details/46819377</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以往对于View生命周期的认识停留在onMeasure，onLayout，onDraw等方法上，对Touch事件的传递停留在dispatchTouchEvent，onInterceptTouchEvent，OnTouchEvent等方法上，这样写写自定义控件什么的还是没问题的，不过究其原理，还是有些模糊不清，因为这样的认识还停留在应用层。因此看了下Framework层对于View的组织和管理，以及与Window，ViewRootImpl，WindowManagerService之间的关系。对于整个View体系的认识进一步加深。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://forevas.github.io/tags/Android/"/>
    
      <category term="ViewRootImpl" scheme="https://forevas.github.io/tags/ViewRootImpl/"/>
    
      <category term="Window" scheme="https://forevas.github.io/tags/Window/"/>
    
  </entry>
  
  <entry>
    <title>Android IPC机制</title>
    <link href="https://forevas.github.io/2018/01/23/Android-IPC%E6%9C%BA%E5%88%B6/"/>
    <id>https://forevas.github.io/2018/01/23/Android-IPC机制/</id>
    <published>2018-01-23T14:33:17.000Z</published>
    <updated>2018-05-22T14:46:43.902Z</updated>
    
    <content type="html"><![CDATA[<p>IPC(Inter-Process Communication),在日常开发中大多数场景下都用不到，而且我们在开发中就算用到了进程间通信，基本上都只是专注于通信双方接口的设计，对于底层实现的细节并不是很了解。稍微看下Android Framework层的源码，也会发现随处可见IPC的身影。所以，有必要稍稍了解下其底层实现的原理，有助于加深我们对进程间通信的认识。<br><a id="more"></a></p>
<h4 id="AndroidIPC概述"><a href="#AndroidIPC概述" class="headerlink" title="AndroidIPC概述"></a>AndroidIPC概述</h4><p>Android采用Binder作为IPC机制，Binder由于性能较高，采用了内存映射机制（mmap方法），内存拷贝只需一次，传统的linux进程间通信（管道、消息队列、共享内存、<br>信号量、Socket）最少也需要两次。</p>
<p>内存映射的实现过程主要是通过Linux系统下的系统调用函数：mmap（）<br>该函数的作用 = 创建虚拟内存区域 + 与共享对象建立映射关系</p>
<p>用户空间：进程间相互独立</p>
<p>内核空间：所有进程共享</p>
<p>所以一个用户想给另一个用户发送数据必须通过内核空间完成，一般是将用户空间的数据拷贝至内核空间，然后另一个用户再将数据从内核空间拷贝至用户空间</p>
<p>用户1-&gt;拷贝-&gt;内核-&gt;拷贝-&gt;用户</p>
<p>而内存映射只需要一次拷贝：<br>用户1-&gt;拷贝-&gt;内核-&gt;映射-&gt;用户2</p>
<p>暂且这么认为吧</p>
<h4 id="Binder跨进程模型整体架构："><a href="#Binder跨进程模型整体架构：" class="headerlink" title="Binder跨进程模型整体架构："></a>Binder跨进程模型整体架构：</h4><h5 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h5><p>客户端，服务的使用者</p>
<h5 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h5><p>服务端，服务的提供者</p>
<h5 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h5><p>相当于一个路由器，所有的Service都在ServiceManager处登记和查询，将字符串的Binder名字转化为Client中对该Binder的引用。</p>
<h5 id="Binder驱动"><a href="#Binder驱动" class="headerlink" title="Binder驱动"></a>Binder驱动</h5><p>一种虚拟设备驱动,连接client，server，ServiceManager的桥梁。</p>
<p>Binder驱动的作用：</p>
<ol>
<li>传递进程间的数据，通过内存映射</li>
<li>实现线程控制，采用Binder驱动本身的线程池，并由Binder驱动自身进行管理。</li>
</ol>
<p>Binder驱动持有每个Server进程在内核空间中的binder实体，并给client进程提供binder实体的引用。</p>
<h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p>client和server以及ServiceManager之间的交互都要通过Binder。Client和Server属于应用层，ServiceManager和Binder属于Android基础架构。</p>
<p>Binder请求的线程管理：</p>
<ol>
<li>注意server提供的服务方法并不是运行在主线程的。不过其本身的创建过程依旧在主线程。Server进程会创建很多线程来处理Binder请求。</li>
<li>Binder模型的线程管理 采用Binder驱动的线程池，并由Binder驱动自身进行管理</li>
<li>一个进程的Binder线程数默认最大是16，超过的请求会被阻塞等待空闲的Binder线程。</li>
</ol>
<h4 id="具体应用流程"><a href="#具体应用流程" class="headerlink" title="具体应用流程"></a>具体应用流程</h4><h5 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h5><p>server进程通过Binder驱动先在ServiceManager注册服务</p>
<h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><p>Server进程 创建 一个 Binder 对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">@Nullable</div><div class="line">    @Override</div><div class="line">    public IBinder onBind(Intent intent) &#123;</div><div class="line">        /*Stub是生成的代码，抽象类，也可以自己写，继承了Binder类以及实现了自己定义的服务接口*/</div><div class="line">        IMyAidlInterface.Stub stub = new IMyAidlInterface.Stub() &#123;</div><div class="line">            @Override</div><div class="line">            public int add(int a, int b) throws RemoteException &#123;</div><div class="line">                long id = Thread.currentThread().getId();</div><div class="line">                int sum = a + b;</div><div class="line">                return sum;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public int sub(int a, int b) throws RemoteException &#123;</div><div class="line">                int sub = a - b;</div><div class="line">                return sub;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        return stub;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h5 id="获取服务"><a href="#获取服务" class="headerlink" title="获取服务"></a>获取服务</h5><p><img src="https://note.youdao.com/yws/api/personal/file/BC01066A067F49798C9381C4E8E0E8FE?method=download&amp;shareKey=021dc86405e7611d9babd3f87132670a" alt="binder获取服务流程.png"><br>这里有一个querylocal的操作，如果client和server处于同一个进程，则直接返回server服务，不用跨进程。</p>
<h5 id="使用服务"><a href="#使用服务" class="headerlink" title="使用服务"></a>使用服务</h5><p>使用BinderProxy的代理方法，将方法code，方法参数写入parcel对象中，调用transact方法将数据发送到Binder驱动，Service端收到数据，解包后进行处理，写入返回结果，Binder驱动根据代理对象沿原路将结果返回，并通知Client进程获取返回结果，通过代理对象接收结果（之前被挂起的线程被唤醒）。</p>
<p>client端发起请求之后线程会被挂起，返回结果后会被唤醒。</p>
<p>具体过程可以查看aidl生成的代码。</p>
<h4 id="相关类和接口"><a href="#相关类和接口" class="headerlink" title="相关类和接口"></a>相关类和接口</h4><p>IBinder(定义了进程间通信的接口规范)，</p>
<p>Binder(实现了IBinder接口),</p>
<p>IInterface(自己定义的aidl接口生成的代码必须继承这个接口)，</p>
<p>Stub(生成的代码的静态内部类，继承于Binder和自己定义的接口，注意asInterface方法是核心，这个方法用来判断到底应该直接返回Binder还是BinderProxy，onTransact用于解包和执行服务的方法)，</p>
<p>Proxy(Stub的静态内部类，Client端使用，用于代理服务端的Binder实现类，使用代理方法时，写入所有参数后，最终会调用remote.transact方法进行提交，之后就等待返回结果，线程挂起)</p>
<h4 id="in-out-inout"><a href="#in-out-inout" class="headerlink" title="in,out,inout"></a>in,out,inout</h4><p>自定义参数类型时，需要指定数据流向，in代表从client到server,out代表从server到client，inout表示双向流动。</p>
<p>定向Tag为in时，server端会反序列化client传过来的参数，执行完方法后，不会将参数再次序列化传回client端。</p>
<p>定向Tag为out时，client端不会将参数序列化传给server，而是由server自己实例化一个初始状态的参数，方法执行完之后，server会将自己实例化的参数序列化之后传回client端，client端利用自己传入的参数接收server传回的序列化数据。这里，client端传入的参数只是起了一个接收器的作用。</p>
<p>定向tag为inout时，client会将参数序列化传给server，同时server执行完方法后，也会将参数序列化传给client，client端利用自己传入的参数接收server传回的序列化数据。所以这里的数据流动是双向的。</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>当使用RemoteCallback方式交互时，需要注意callback之前需要调用RemoteCallbackList.beginBroadcast(否则获取不到Callback对象)，callback结束后要调用RemoteCallbackList.finishBroadcast。client传给Server的callback对象实际上也是一个binder，所有服务端才能回调。</p>
<p>Binder会为每个参与通信的进程分配内存，跨进程传输的数据是存储在Binder分配的内存中的，每个进程只能访问自己的内存，内存不超过1M(非ServiceManager)，所以跨进程数据量不能太大。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IPC(Inter-Process Communication),在日常开发中大多数场景下都用不到，而且我们在开发中就算用到了进程间通信，基本上都只是专注于通信双方接口的设计，对于底层实现的细节并不是很了解。稍微看下Android Framework层的源码，也会发现随处可见IPC的身影。所以，有必要稍稍了解下其底层实现的原理，有助于加深我们对进程间通信的认识。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://forevas.github.io/tags/Android/"/>
    
      <category term="IPC" scheme="https://forevas.github.io/tags/IPC/"/>
    
      <category term="Binder" scheme="https://forevas.github.io/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>Android序列化</title>
    <link href="https://forevas.github.io/2018/01/05/Android%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://forevas.github.io/2018/01/05/Android序列化/</id>
    <published>2018-01-05T14:28:16.000Z</published>
    <updated>2018-05-22T14:29:54.663Z</updated>
    
    <content type="html"><![CDATA[<p>Android平台序列化接口有Serializable和Parcelable。<br><a id="more"></a></p>
<h4 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h4><p>Serializable翻译过来是“可串行的”，主要用于传统java的序列化，可以序列化类到磁盘、网络传输等等。使用方法也很简单，直接实现Serializable接口即可。</p>
<p>Serializable对象一般和ObjectInputStream/ObjectOutputStream配合使用，关键方法readObject和writeObject。</p>
<p>序列化的过程我们不用管，不过要注意，静态变量和声明了transient关键字的变量不会被序列化。</p>
<p>我们可以定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//只是一个sample，实际方法可以自己实现</div><div class="line">private void writeObject(ObjectOutputStream oos) throws IOException &#123;  </div><div class="line">        oos.defaultWriteObject();  </div><div class="line">        oos.writeInt(data);  </div><div class="line">        System.out.println(&quot;session serialized&quot;);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    private void readObject(ObjectInputStream ois) throws IOException,  </div><div class="line">            ClassNotFoundException &#123;  </div><div class="line">        ois.defaultReadObject();  </div><div class="line">        data = ois.readInt();  </div><div class="line">        activationTime = System.currentTimeMillis();  </div><div class="line">        System.out.println(&quot;session deserialized&quot;);  </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这两个方法可以自定义序列化和反序列化过程，ObjectInput/OutputStream会通过反射调用这两个方法，从而实现了自定义过程。</p>
<p>serialVersionUID是一个long型的static常量，序列化前后的UID声明要保持一致，否则会导致序列化失败。这个值可以自动生成也可以自己定义。</p>
<p>序列化到本地是二进制串，实际上是键值对。</p>
<h5 id="Externalizable"><a href="#Externalizable" class="headerlink" title="Externalizable"></a>Externalizable</h5><p>这个接口继承了Serializable接口，提供了writeExternal和readExternal方法，相当于上面的writeObject和readObject方法的功能。只不过将其标准化了而已。</p>
<h4 id="Parcelable"><a href="#Parcelable" class="headerlink" title="Parcelable"></a>Parcelable</h4><p>Parcelable对象的序列化在内存中进行。Parcelable对象是Android进程间通信的数据的载体。Parcelable接口比Serializable接口复杂了很多，开发者必须要实现接口定义的方法。并定义自己序列化的过程。</p>
<h5 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h5><p>Parcel是包裹的意思，所有的Parcelable对象最后都是通过Parcel来进行序列化的。</p>
<p>Parcel的实例化是在IPC的过程中进行的，可以看到AIDL文件编译后生成的代码中会有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">android.os.Parcel _data = android.os.Parcel.obtain();</div><div class="line">android.os.Parcel _reply = android.os.Parcel.obtain();</div></pre></td></tr></table></figure></p>
<p>这两句代码生成了两个Parcel，一个用于client向server传输数据的序列化，一个用于server向client传输数据的反序列化。</p>
<h5 id="writeToParcel-Parcel-dest-int-flags"><a href="#writeToParcel-Parcel-dest-int-flags" class="headerlink" title="writeToParcel(Parcel dest, int flags)"></a>writeToParcel(Parcel dest, int flags)</h5><p>我们在实现一个Parcelable对象时会复写这个方法，这个方法传入了一个Parcel实例，由Parcel序列化每一个成员变量。</p>
<h5 id="createFromParcel-Parcel-in"><a href="#createFromParcel-Parcel-in" class="headerlink" title="createFromParcel(Parcel in)"></a>createFromParcel(Parcel in)</h5><p>这个是CREATOR的一个方法，通过实现这个方法来定义反序列化的规则。实际上就是new了一个对象，然后初始化的过程。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Parcel传输数据是通过Binder驱动进行的，所以只会有一次数据拷贝(内存映射机制)。其整个过程是在内存中进行。序列化和反序列化由用户定义，避免了反射的过程。序列化的过程有序，不需要写入变量名，所以数据量也比较小。其整体性能要大大的优于Serializable的方式。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android平台序列化接口有Serializable和Parcelable。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://forevas.github.io/tags/Android/"/>
    
      <category term="Serializable" scheme="https://forevas.github.io/tags/Serializable/"/>
    
      <category term="Parcelable" scheme="https://forevas.github.io/tags/Parcelable/"/>
    
  </entry>
  
  <entry>
    <title>ActivityThread总结</title>
    <link href="https://forevas.github.io/2017/12/20/ActivityThread%E6%80%BB%E7%BB%93/"/>
    <id>https://forevas.github.io/2017/12/20/ActivityThread总结/</id>
    <published>2017-12-20T14:25:08.000Z</published>
    <updated>2018-05-22T14:27:17.028Z</updated>
    
    <content type="html"><![CDATA[<p>ActivityThread并不是Thread，只是一个工具类，不过这个类几乎完成了所有Android本地应用和AMS的交互逻辑，包括Application，Service，Activity和BroadcastReceiver的实例化，ContentProvider服务的获取，广播的接收，以及四大组件生命周期调度信息的分发。<br><a id="more"></a></p>
<h4 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h4><p>Android普通应用进程的起点就是ActivityThread的Main方法，在Main方法中，ActivityThread启动了一个主线程的消息队列，之后的操作都是通过消息队列进行消息分发来完成。</p>
<p>在attach方法中调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mgr.attachApplication(mAppThread);</div></pre></td></tr></table></figure></p>
<p>将ApplicationThread(Binder)传递给AMS。</p>
<p>普通应用进程初始化Application在HandleBindApplication方法中，attach到AMS后, AMS便可以通过Binder调用HandleBindApplication方法然后创建Application，这一点和SystemServer进程不同。</p>
<p>注意本地进程提供了ApplicationThread类供AMS调用，ApplicationThread继承于ApplicationThreadNative，ApplicationThreadNative继承Binder并实现了IApplicationThread接口。IApplicationThread接口定义了可被调用的方法接口。</p>
<h4 id="SystemMain"><a href="#SystemMain" class="headerlink" title="SystemMain"></a>SystemMain</h4><p>SystemServer进程调用，和Main方法不同的是，attach方法传了true，这这里实例化Application类，并回调onCreate方法。</p>
<p>Instrumentation也是在attach方法中进行初始化的，在Application创建之前。</p>
<p>要注意的一点是，这里并没有传递ApplicationThread给AMS，因为AMS就运行在SystemServer进程。SystemServer进程创建时，AMS等一系列服务还没有启动起来。SystemServer中运行的所有服务都是系统级别的，不受AMS等管控。这一点和普通进程有很大区别。</p>
<h4 id="AMS"><a href="#AMS" class="headerlink" title="AMS"></a>AMS</h4><p>AMS提供给本地的Binder类可通过ActivityManagerNative.getDefault()获取，通过getDefault方法可以看到，AMS提供的Binder在本地进程通过一个单例维护:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123;</div><div class="line">        protected IActivityManager create() &#123;</div><div class="line">            IBinder b = ServiceManager.getService(&quot;activity&quot;);</div><div class="line">            if (false) &#123;</div><div class="line">                Log.v(&quot;ActivityManager&quot;, &quot;default service binder = &quot; + b);</div><div class="line">            &#125;</div><div class="line">            IActivityManager am = asInterface(b);</div><div class="line">            if (false) &#123;</div><div class="line">                Log.v(&quot;ActivityManager&quot;, &quot;default service = &quot; + am);</div><div class="line">            &#125;</div><div class="line">            return am;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>AMS远程服务提供的接口定义在IActivityManager中。</p>
<h4 id="ApplicationThread"><a href="#ApplicationThread" class="headerlink" title="ApplicationThread"></a>ApplicationThread</h4><p>实现了IApplicationThread的接口,本质上是一个Binder,AMS通过ApplicationThread的代理跨进程向本地进程发送消息。</p>
<h4 id="H"><a href="#H" class="headerlink" title="H"></a>H</h4><p>H为继承于Handler，用于从ApplicationThread中接收并分发AMS发送过来的的消息到主线程。(因为Binder接收消息的线程不是主线程)</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>AMS才是控制中心，所有的操作都是AMS决定，然后通过Binder发送到应用进程，ActivityThread收到消息然后分发</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ActivityThread并不是Thread，只是一个工具类，不过这个类几乎完成了所有Android本地应用和AMS的交互逻辑，包括Application，Service，Activity和BroadcastReceiver的实例化，ContentProvider服务的获取，广播的接收，以及四大组件生命周期调度信息的分发。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://forevas.github.io/tags/Android/"/>
    
      <category term="ActivityThread" scheme="https://forevas.github.io/tags/ActivityThread/"/>
    
  </entry>
  
  <entry>
    <title>Context总结</title>
    <link href="https://forevas.github.io/2017/12/05/Context%E6%80%BB%E7%BB%93/"/>
    <id>https://forevas.github.io/2017/12/05/Context总结/</id>
    <published>2017-12-05T14:10:57.000Z</published>
    <updated>2018-05-22T14:27:14.448Z</updated>
    
    <content type="html"><![CDATA[<p>在Android开发中，随处可见Context的身影，包括Activity，Service，Application等都是Context的子类，在很多情况下，例如show一个Dialog，获取资源文件，启动一个Activity等等，我们都需要通过Context来完成。这里，对Context体系做一个简单的总结。<br><a id="more"></a></p>
<h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>Context是一个抽象类，字面意思是环境，上下文等等，定义了一些基础抽象方法。</p>
<h4 id="ContextImpl"><a href="#ContextImpl" class="headerlink" title="ContextImpl"></a>ContextImpl</h4><p>Context的实现类，实现了大量的基础方法，ContextImpl持有对ActivityThread的引用，有许多方法要通过ActivityThread的帮助来实现。ContextImpl针对不同的组件创建不同的实例，例如为Activity创建实例时，需要Token作为参数，而这个Token则是和WindowManagerService交互的通行证，所有只有Activity的context才能进行弹窗等操作。</p>
<h4 id="ReceiverRestrictedContext"><a href="#ReceiverRestrictedContext" class="headerlink" title="ReceiverRestrictedContext"></a>ReceiverRestrictedContext</h4><p>和ContextImpl定义在同一个文件中，这个类继承于ContextWrapper，起到禁止绑定Service和注册广播的功能。</p>
<p>当定义静态广播时，不管是应用内还是全局广播，onReceived方法返回的context是ReceiverRestrictedContext。</p>
<p>对于全局广播的动态注册，回调onReceive中的context是：Activity Context。</p>
<p>顺便说说BroadcastReceiver：</p>
<p>LocalBroadcastManager可以用于创建应用内广播，或者export设为false。</p>
<p>应用内广播的动态注册（LocalBroadcastManager方式），context是Application context</p>
<p>应用内广播的动态注册（非LocalBroadcastManager方式），context是Activity context</p>
<p>有序广播按照Priority从大到小排序，相同的Priority，动态广播优先</p>
<p>粘性广播5.0以后已被废弃，不多加讨论。</p>
<h4 id="ContextWrapper"><a href="#ContextWrapper" class="headerlink" title="ContextWrapper"></a>ContextWrapper</h4><p>ContextImpl的装饰类，持有对ContextImpl的引用，只是对ContextImpl的方法做了下代理，没有多余的装饰动作</p>
<h4 id="ContextThemeWrapper"><a href="#ContextThemeWrapper" class="headerlink" title="ContextThemeWrapper"></a>ContextThemeWrapper</h4><p>ContextWrapper的子类，增加了一些装饰动作，getResource被修饰了</p>
<h4 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h4><p>继承于ContextThemeWrapper，四大组件之一，不仅仅有Context定义的基础功能，还实现了对window进行监听的接口</p>
<h4 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h4><p>Application继承于ContextWrapper，是应用中生命周期最长的一个类，我们平时调用context.getApplicationContext返回的实际就是Application本身.Application被ActivityThread所引用，而ActivityThread又被ContextImpl所引用，所以我们可以获取到。</p>
<h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p>Service也是继承于ContextWrapper，并且也实现了ComponentCallbacks2接口，这点和Application一致</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Context为我们提供了很多方便和系统进行交互的接口，正如其字面意思，它是一种环境，通过它我们能拿到资源文件，启动Activity，启动或绑定Service，获取ContentProvider服务，动态注册广播等等，是一个很强大的工具类。几乎所有Context都是在ActivityThread中进行实例化的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Android开发中，随处可见Context的身影，包括Activity，Service，Application等都是Context的子类，在很多情况下，例如show一个Dialog，获取资源文件，启动一个Activity等等，我们都需要通过Context来完成。这里，对Context体系做一个简单的总结。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://forevas.github.io/tags/Android/"/>
    
      <category term="Context" scheme="https://forevas.github.io/tags/Context/"/>
    
  </entry>
  
  <entry>
    <title>ANR机制</title>
    <link href="https://forevas.github.io/2017/11/12/ANR%E6%9C%BA%E5%88%B6/"/>
    <id>https://forevas.github.io/2017/11/12/ANR机制/</id>
    <published>2017-11-12T14:03:55.000Z</published>
    <updated>2018-05-22T14:09:01.295Z</updated>
    
    <content type="html"><![CDATA[<p>对ANR实现原理的探究和总结<br><a id="more"></a></p>
<h4 id="ANR-Application-Not-Responding"><a href="#ANR-Application-Not-Responding" class="headerlink" title="ANR(Application Not Responding)"></a>ANR(Application Not Responding)</h4><p>ANR是由于主线程阻塞引起的，不过主线程阻塞不一定引起ANR，尝试在Activity的onCreate中进行无限循环，界面卡住了，主线程被成功阻塞，不过并没有ANR。这说明ANR是在一定的场景下才能出现的。</p>
<h5 id="ANR出现的场景"><a href="#ANR出现的场景" class="headerlink" title="ANR出现的场景"></a>ANR出现的场景</h5><p><strong>Service ANR</strong>：Service Timeout是位于”ActivityManager”线程中的AMS.MainHandler收到SERVICE_TIMEOUT_MSG消息时触发。</p>
<p>对于Service有两类:</p>
<p>对于前台服务，则超时为SERVICE_TIMEOUT = 20s；<br>对于后台服务，则超时为SERVICE_BACKGROUND_TIMEOUT = 200s</p>
<p><strong>BroadcastQueue  ANR</strong>:BroadcastReceiver Timeout是位于”ActivityManager”线程中的BroadcastQueue.BroadcastHandler收到BROADCAST_TIMEOUT_MSG消息时触发。<br>对于广播队列有两个: foreground队列和background队列:</p>
<p>对于前台广播，则超时为BROADCAST_FG_TIMEOUT = 10s；<br>对于后台广播，则超时为BROADCAST_BG_TIMEOUT = 60s</p>
<p><strong>ContentProvider ANR</strong>:ContentProvider Timeout是位于”ActivityManager”线程中的AMS.MainHandler收到CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG消息时触发。ContentProvider 超时为CONTENT_PROVIDER_PUBLISH_TIMEOUT = 10s. 这个跟前面的Service和BroadcastQueue完全不同, 由Provider进程启动过程相关.</p>
<p><strong>InputDispatching  ANR</strong>:输入事件必须在5秒内处理完毕。在派发一个输入事件时，会判断当前输入事件是否需要等待，如果需要等待，则判断是否等待已经超时，超时就说明发生了ANR.</p>
<h5 id="ANR的报告机制"><a href="#ANR的报告机制" class="headerlink" title="ANR的报告机制"></a>ANR的报告机制</h5><p>对于Service, Broadcast, Input发生ANR之后,最终都会调用AMS.appNotResponding;<br>这个方法的职能就是向用户或开发者报告ANR发生了。 最终的表现形式是：弹出一个对话框，告诉用户当前某个程序无响应;输入一大堆与ANR相关的日志，便于开发者解决问题。</p>
<p>对于provider,在其进程启动时publish过程可能会出现ANR, 则会直接杀进程以及清理相应信息,而不会弹出ANR的对话框. appNotRespondingViaProvider()过程会走appNotResponding(), 这个就不介绍了，很少使用，由用户自定义超时时间.</p>
<p>Service，BroadcastQueue都是在AMS中埋炸弹的，然后客户端执行完生命周期之后，再向AMS中发送消息拆炸弹。如果超时没拆，那就beng，ANR了。原理其实就是Handler发一个延时消息，然后到时间还没remove掉就ANR。</p>
<p>参考链接：</p>
<p><a href="http://gityuan.com/2016/07/02/android-anr/" target="_blank" rel="external">http://gityuan.com/2016/07/02/android-anr/</a></p>
<p><a href="http://duanqz.github.io/2015-10-12-ANR-Analysis" target="_blank" rel="external">http://duanqz.github.io/2015-10-12-ANR-Analysis</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对ANR实现原理的探究和总结&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://forevas.github.io/tags/Android/"/>
    
      <category term="ANR" scheme="https://forevas.github.io/tags/ANR/"/>
    
  </entry>
  
  <entry>
    <title>RxJava学习总结</title>
    <link href="https://forevas.github.io/2017/11/03/RxJava%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://forevas.github.io/2017/11/03/RxJava学习总结/</id>
    <published>2017-11-03T15:09:51.000Z</published>
    <updated>2018-05-21T15:25:08.156Z</updated>
    
    <content type="html"><![CDATA[<p>RxJava+Retrofit+OkHttp是最佳的网络请求实践，之前的项目中一直是使用Callback的方式进行网络请求，最近得空，引入了RxJava和Retrofit，重新封装了下项目的网络请求模块，不得不说，使用RxJava的响应式编程思想，面向数据流的编程方式，写出来的代码十分优美。<br><a id="more"></a></p>
<h2 id="编程范式概述"><a href="#编程范式概述" class="headerlink" title="编程范式概述"></a>编程范式概述</h2><p>响应式编程: 响应式编程是一种面向数据流和变化传播的编程范式。实践:Rxjava</p>
<p>函数式编程: 或称函数程序设计，又称泛函编程，是一种编程典范，它将电脑运算视为数学上的函数计算，并且避免使用程序状态以及易变对象。函数编程语言最重要的基础是λ演算（lambda calculus）。而且λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。比起命令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。特征:函数作为基本单元,无状态,高阶函数等.</p>
<p>函数响应式编程:响应式编程思想为体，函数式编程思想为用。</p>
<p>命令式编程:是一种描述电脑所需作出的行为的编程典范。几乎所有电脑的硬件工作都是指令式的；几乎所有电脑的硬件都是设计来运行机器码，使用指令式的风格来写的。较高级的指令式编程语言使用变量和更复杂的语句，但仍依从相同的典范。菜谱和行动清单，虽非计算机程序，但与命令式编程有相似的风格：每步都是指令，有形的世界控制情况。因为命令式编程的基础观念，不但概念上比较熟悉，而且较容易具体表现于硬件，所以大部分的编程语言都是指令式的。实践:汇编和机器码.</p>
<p>面向对象编程:把构成问题的事物分解成一个个对象,建立对象的目的不是为了完成某一个步骤,而是为了描述某个事物在整个问题中的行为.</p>
<p>面向过程编程:分析出解决问题所需要的步骤,然后用函数把这些步骤一步步实现,使用的时候一个个依次调用就可以了.</p>
<p>以上编程范式并不互斥,可以相互结合使用,总而言之,编程范式本质就是为了更合理的解决问题而存在的.不要拘泥于概念而被已有的框架所束缚.</p>
<h2 id="RxJava基本概念"><a href="#RxJava基本概念" class="headerlink" title="RxJava基本概念"></a>RxJava基本概念</h2><p>Observable: 可被观察的对象<br>Observer: 观察者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123;</div><div class="line">                emitter.onNext(1);</div><div class="line">                emitter.onNext(2);</div><div class="line">                emitter.onNext(3);</div><div class="line">                emitter.onComplete();</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Observer&lt;Integer&gt;() &#123;//注意: 只有当上游和下游建立连接之后, 上游才会开始发送事件. 也就是调用了subscribe() 方法之后才开始发送事件.</div><div class="line">            @Override</div><div class="line">            public void onSubscribe(Disposable d) &#123;//注意Disposable在这里</div><div class="line">                Log.d(TAG, &quot;subscribe&quot;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onNext(Integer value) &#123;</div><div class="line">                Log.d(TAG, &quot;&quot; + value);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onError(Throwable e) &#123;</div><div class="line">                Log.d(TAG, &quot;error&quot;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onComplete() &#123;</div><div class="line">                Log.d(TAG, &quot;complete&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>ObservableEmitter： 数据发射器 onNext(T value)、onComplete()和onError(Throwable error)。</p>
<ul>
<li>上游可以发送无限个onNext, 下游也可以接收无限个onNext.</li>
<li>当上游发送了一个onComplete后, 上游onComplete之后的事件将会继续发送, 而下游收到onComplete事件之后将不再继续接收事件.</li>
<li>当上游发送了一个onError后, 上游onError之后的事件将继续发送, 而下游收到onError事件之后将不再继续接收事件.</li>
<li>上游可以不发送onComplete或onError.</li>
<li>最为关键的是onComplete和onError必须唯一并且互斥, 即不能发多个onComplete, 也不能发多个onError, 也不能先发一个onComplete, 然后再发一个onError, 反之亦然</li>
</ul>
<p>Disposable: 调用它的dispose()方法时, 它就会将两根管道切断, 从而导致下游收不到事件.</p>
<p>subscribe()有多个重载的方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public final Disposable subscribe() &#123;&#125;</div><div class="line">    public final Disposable subscribe(Consumer&lt;? super T&gt; onNext) &#123;&#125;</div><div class="line">    public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError) &#123;&#125;</div><div class="line">    public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete) &#123;&#125;</div><div class="line">    public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Consumer&lt;? super Disposable&gt; onSubscribe) &#123;&#125;</div><div class="line">    public final void subscribe(Observer&lt;? super T&gt; observer) &#123;&#125;</div></pre></td></tr></table></figure>
<p>不带任何参数的subscribe() 表示下游不关心任何事件,带有一个Consumer参数的方法表示下游只关心onNext事件.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123;</div><div class="line">                Log.d(TAG, &quot;emit 1&quot;);</div><div class="line">                emitter.onNext(1);</div><div class="line">                Log.d(TAG, &quot;emit 2&quot;);</div><div class="line">                emitter.onNext(2);</div><div class="line">                Log.d(TAG, &quot;emit 3&quot;);</div><div class="line">                emitter.onNext(3);</div><div class="line">                Log.d(TAG, &quot;emit complete&quot;);</div><div class="line">                emitter.onComplete();</div><div class="line">                Log.d(TAG, &quot;emit 4&quot;);</div><div class="line">                emitter.onNext(4);</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void accept(Integer integer) throws Exception &#123;</div><div class="line">                Log.d(TAG, &quot;onNext: &quot; + integer);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>Rxjava默认上下游在同一个线程。</p>
<h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p>subscribeOn：控制在哪个线程发送事件，只有第一次指定有用，后续的都忽视<br>observeOn：控制在哪个线程接收事件，每次指定后接下来的操作都会在指定的线程，可多次指定</p>
<p>Rxjava内置线程选择:</p>
<ul>
<li>Schedulers.io() 代表io操作的线程, 通常用于网络,读写文件等io密集型的操作</li>
<li>Schedulers.computation() 代表CPU计算密集型的操作, 例如需要大量计算的操作</li>
<li>Schedulers.newThread() 代表一个常规的新线程</li>
<li>AndroidSchedulers.mainThread() 代表Android的主线程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">observable.subscribeOn(Schedulers.newThread())</div><div class="line">                .subscribeOn(Schedulers.io())</div><div class="line">                .observeOn(AndroidSchedulers.mainThread())</div><div class="line">                .doOnNext(new Consumer&lt;Integer&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void accept(Integer integer) throws Exception &#123;</div><div class="line">                        Log.d(TAG, &quot;After observeOn(mainThread), current thread is: &quot; + Thread.currentThread().getName());</div><div class="line">                    &#125;</div><div class="line">                &#125;)</div><div class="line">                .observeOn(Schedulers.io())</div><div class="line">                .doOnNext(new Consumer&lt;Integer&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void accept(Integer integer) throws Exception &#123;</div><div class="line">                        Log.d(TAG, &quot;After observeOn(io), current thread is : &quot; + Thread.currentThread().getName());</div><div class="line">                    &#125;</div><div class="line">                &#125;)</div><div class="line">                .subscribe(consumer);</div></pre></td></tr></table></figure>
<h3 id="配合Retrofit"><a href="#配合Retrofit" class="headerlink" title="配合Retrofit"></a>配合Retrofit</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public interface Api &#123;</div><div class="line">    @GET</div><div class="line">    Observable&lt;LoginResponse&gt; login(@Body LoginRequest request);</div><div class="line"></div><div class="line">    @GET</div><div class="line">    Observable&lt;RegisterResponse&gt; register(@Body RegisterRequest request);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Api api = retrofit.create(Api.class);</div><div class="line">        api.login(request)</div><div class="line">             .subscribeOn(Schedulers.io())               //在IO线程进行网络请求</div><div class="line">             .observeOn(AndroidSchedulers.mainThread())  //回到主线程去处理请求结果</div><div class="line">            .subscribe(new Observer&lt;LoginResponse&gt;() &#123;</div><div class="line">                @Override</div><div class="line">                public void onSubscribe(Disposable d) &#123;&#125;</div><div class="line"></div><div class="line">                @Override</div><div class="line">                public void onNext(LoginResponse value) &#123;&#125;</div><div class="line"></div><div class="line">                @Override</div><div class="line">                public void onError(Throwable e) &#123;</div><div class="line">                    Toast.makeText(mContext, &quot;登录失败&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                @Override</div><div class="line">                public void onComplete() &#123;</div><div class="line">                    Toast.makeText(mContext, &quot;登录成功&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div></pre></td></tr></table></figure>
<p>CompositeDisposable: Disposable的容器,用于Activity或者Fragment退出时销毁所有Disposable</p>
<h2 id="变换操作符"><a href="#变换操作符" class="headerlink" title="变换操作符"></a>变换操作符</h2><p>map: 对上游发送的每一个事件应用一个函数, 使得每一个事件都按照指定的函数去变化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123;</div><div class="line">                emitter.onNext(1);</div><div class="line">                emitter.onNext(2);</div><div class="line">                emitter.onNext(3);</div><div class="line">            &#125;</div><div class="line">        &#125;).map(new Function&lt;Integer, String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public String apply(Integer integer) throws Exception &#123;</div><div class="line">                return &quot;This is result &quot; + integer;</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Consumer&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void accept(String s) throws Exception &#123;</div><div class="line">                Log.d(TAG, s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>flatMap: 将一个发送事件的上游Observable变换为多个发送事件的Observables，然后将它们发射的事件合并后放进一个单独的Observable里,flatMap并不保证事件的顺序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123;</div><div class="line">                emitter.onNext(1);</div><div class="line">                emitter.onNext(2);</div><div class="line">                emitter.onNext(3);</div><div class="line">            &#125;</div><div class="line">        &#125;).flatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public ObservableSource&lt;String&gt; apply(Integer integer) throws Exception &#123;</div><div class="line">                final List&lt;String&gt; list = new ArrayList&lt;&gt;();</div><div class="line">                for (int i = 0; i &lt; 3; i++) &#123;</div><div class="line">                    list.add(&quot;I am value &quot; + integer);</div><div class="line">                &#125;</div><div class="line">                return Observable.fromIterable(list).delay(10,TimeUnit.MILLISECONDS);</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(new Consumer&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void accept(String s) throws Exception &#123;</div><div class="line">                Log.d(TAG, s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<p>concatMap: 和flatMap一样,但是保证事件的先后顺序</p>
<p>多个网络请求嵌套:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">api.register(new RegisterRequest())            //发起注册请求</div><div class="line">                .subscribeOn(Schedulers.io())               //在IO线程进行网络请求</div><div class="line">                .observeOn(AndroidSchedulers.mainThread())  //回到主线程去处理请求注册结果</div><div class="line">                .doOnNext(new Consumer&lt;RegisterResponse&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void accept(RegisterResponse registerResponse) throws Exception &#123;</div><div class="line">                        //先根据注册的响应结果去做一些操作</div><div class="line">                    &#125;</div><div class="line">                &#125;)</div><div class="line">                .observeOn(Schedulers.io())                 //回到IO线程去发起登录请求</div><div class="line">                .flatMap(new Function&lt;RegisterResponse, ObservableSource&lt;LoginResponse&gt;&gt;() &#123;//这里用map也可以实现</div><div class="line">                    @Override</div><div class="line">                    public ObservableSource&lt;LoginResponse&gt; apply(RegisterResponse registerResponse) throws Exception &#123;</div><div class="line">                        return api.login(new LoginRequest());</div><div class="line">                    &#125;</div><div class="line">                &#125;)</div><div class="line">                .observeOn(AndroidSchedulers.mainThread())  //回到主线程去处理请求登录的结果</div><div class="line">                .subscribe(new Consumer&lt;LoginResponse&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void accept(LoginResponse loginResponse) throws Exception &#123;</div><div class="line">                        Toast.makeText(MainActivity.this, &quot;登录成功&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">                    &#125;</div><div class="line">                &#125;, new Consumer&lt;Throwable&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void accept(Throwable throwable) throws Exception &#123;</div><div class="line">                        Toast.makeText(MainActivity.this, &quot;登录失败&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div></pre></td></tr></table></figure></p>
<p>map和flatMap的区别在于,map是1对1关系,而flatmap是1对多关系</p>
<h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><p>zip操作符用于将多个Observable发送的事件进行合并,它按照严格的顺序应用这个函数,它只发射与发射数据项最少的那个Observable一样多的数据.</p>
<p>异步进行合并:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Integer&gt; observable1 = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;         </div><div class="line">    @Override                                                                                      </div><div class="line">    public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123;                   </div><div class="line">        Log.d(TAG, &quot;emit 1&quot;);                                                                      </div><div class="line">        emitter.onNext(1);                                                                         </div><div class="line">        Thread.sleep(1000);                                                                        </div><div class="line"></div><div class="line">        Log.d(TAG, &quot;emit 2&quot;);                                                                      </div><div class="line">        emitter.onNext(2);                                                                         </div><div class="line">        Thread.sleep(1000);                                                                        </div><div class="line"></div><div class="line">        Log.d(TAG, &quot;emit 3&quot;);                                                                      </div><div class="line">        emitter.onNext(3);                                                                         </div><div class="line">        Thread.sleep(1000);                                                                        </div><div class="line"></div><div class="line">        Log.d(TAG, &quot;emit 4&quot;);                                                                      </div><div class="line">        emitter.onNext(4);                                                                         </div><div class="line">        Thread.sleep(1000);                                                                        </div><div class="line"></div><div class="line">        Log.d(TAG, &quot;emit complete1&quot;);                                                              </div><div class="line">        emitter.onComplete();                                                                      </div><div class="line">    &#125;                                                                                              </div><div class="line">&#125;).subscribeOn(Schedulers.io());                                                                   </div><div class="line"></div><div class="line">Observable&lt;String&gt; observable2 = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;           </div><div class="line">    @Override                                                                                      </div><div class="line">    public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception &#123;                    </div><div class="line">        Log.d(TAG, &quot;emit A&quot;);                                                                      </div><div class="line">        emitter.onNext(&quot;A&quot;);                                                                       </div><div class="line">        Thread.sleep(1000);                                                                        </div><div class="line"></div><div class="line">        Log.d(TAG, &quot;emit B&quot;);                                                                      </div><div class="line">        emitter.onNext(&quot;B&quot;);                                                                       </div><div class="line">        Thread.sleep(1000);                                                                        </div><div class="line"></div><div class="line">        Log.d(TAG, &quot;emit C&quot;);                                                                      </div><div class="line">        emitter.onNext(&quot;C&quot;);                                                                       </div><div class="line">        Thread.sleep(1000);                                                                        </div><div class="line"></div><div class="line">        Log.d(TAG, &quot;emit complete2&quot;);                                                              </div><div class="line">        emitter.onComplete();                                                                      </div><div class="line">    &#125;                                                                                              </div><div class="line">&#125;).subscribeOn(Schedulers.io());                                                                   </div><div class="line"></div><div class="line">Observable.zip(observable1, observable2, new BiFunction&lt;Integer, String, String&gt;() &#123;               </div><div class="line">    @Override                                                                                      </div><div class="line">    public String apply(Integer integer, String s) throws Exception &#123;                              </div><div class="line">        return integer + s;                                                                        </div><div class="line">    &#125;                                                                                              </div><div class="line">&#125;).subscribe(new Observer&lt;String&gt;() &#123;                    </div><div class="line">    @Override                                                                                      </div><div class="line">    public void onSubscribe(Disposable d) &#123;                                                        </div><div class="line">        Log.d(TAG, &quot;onSubscribe&quot;);                                                                 </div><div class="line">    &#125;                                                                                              </div><div class="line"></div><div class="line">    @Override                                                                                      </div><div class="line">    public void onNext(String value) &#123;                                                             </div><div class="line">        Log.d(TAG, &quot;onNext: &quot; + value);                                                            </div><div class="line">    &#125;                                                                                              </div><div class="line"></div><div class="line">    @Override                                                                                      </div><div class="line">    public void onError(Throwable e) &#123;                                                             </div><div class="line">        Log.d(TAG, &quot;onError&quot;);                                                                     </div><div class="line">    &#125;                                                                                              </div><div class="line"></div><div class="line">    @Override                                                                                      </div><div class="line">    public void onComplete() &#123;                                                                     </div><div class="line">        Log.d(TAG, &quot;onComplete&quot;);                                                                  </div><div class="line">    &#125;                                                                                              </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>zip发送的事件数量跟上游中发送事件最少的那一根水管的事件数量是有关的, 在这个例子里我们第二根水管只发送了三个事件然后就发送了Complete, 这个时候尽管第一根水管还有事件4 和事件Complete 没有发送, 但是它们发不发送还有什么意义呢? 所以本着节约是美德的思想, 就不让它发了.</p>
<p>如果不发送Complete呢？ 答案是显然的, 上游会继续发送事件, 但是下游仍然收不到那些多余的事件.</p>
<p>如果在同一线程中,则不受这个条件约束,会发完一个Obervable的数据再去发另一个.</p>
<h2 id="Backpressure"><a href="#Backpressure" class="headerlink" title="Backpressure"></a>Backpressure</h2><p>Backpressure是1.0的概念,用于发送数据和接收数据速率不统一的问题,2.0之后是没有这个概念的,大数据流用Flowable+Subscriber，小数据流用Observable+Observer.</p>
<p>当上下游处于不同线程,且上游速度远大于下游,可能会OOM,可以采用filter,sample,或者降低发送速度来避免这个问题.当然这是在使用Observable+Observer时的情况.</p>
<h3 id="Flowable"><a href="#Flowable" class="headerlink" title="Flowable"></a>Flowable</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123;</div><div class="line">                Log.d(TAG, &quot;emit 1&quot;);</div><div class="line">                emitter.onNext(1);</div><div class="line">                Log.d(TAG, &quot;emit 2&quot;);</div><div class="line">                emitter.onNext(2);</div><div class="line">                Log.d(TAG, &quot;emit 3&quot;);</div><div class="line">                emitter.onNext(3);</div><div class="line">                Log.d(TAG, &quot;emit complete&quot;);</div><div class="line">                emitter.onComplete();</div><div class="line">            &#125;</div><div class="line">        &#125;, BackpressureStrategy.ERROR).subscribe(new Subscriber&lt;Integer&gt;() &#123;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onSubscribe(Subscription s) &#123;</div><div class="line">                s.request(Long.MAX_VALUE);  //注意这句代码,同一个线程中,不request会报MissingBackpressureException异常</div><div class="line">                Log.d(TAG, &quot;onSubscribe&quot;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onNext(Integer integer) &#123;</div><div class="line">                Log.d(TAG, &quot;onNext: &quot; + integer);</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onError(Throwable t) &#123;</div><div class="line">                Log.w(TAG, &quot;onError: &quot;, t);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onComplete() &#123;</div><div class="line">                Log.d(TAG, &quot;onComplete&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>使用Flowable时,下游的onSubscribe方法中传给我们的不再是Disposable了, 而是Subscription, 它俩有什么区别呢, 首先它们都是上下游中间的一个开关, 之前我们说调用Disposable.dispose()方法可以切断水管, 同样的调用Subscription.cancel()也可以切断水管, 不同的地方在于Subscription增加了一个void request(long n)方法,不管在不在同一个线程,只有调用request才能收到数据.</p>
<p>使用Flowable时,如果上下游在同一个线程中,那么必须要调用request,否则会报MissingBackpressureException异常</p>
<p>如果不在同一个线程,那么发送数据会有一个缓冲区,大小为128,若存满后继续发送数据</p>
<p>这个时候要看设置Backpressure的strategy:</p>
<ul>
<li>BackpressureStrategy.ERROR 直接报错MissingBackpressureException</li>
<li>BackpressureStrategy.BUFFER 和Observable表现一致,可能会OOM</li>
<li>BackpressureStrategy.DROP 存不下的数据都丢了</li>
<li>BackpressureStrategy.LATEST 存满之后,一直会刷新最新的一个的数据</li>
</ul>
<p>如果不是自己创建的Flowable,可以通过以下方法设置策略:<br>onBackpressureBuffer()<br>onBackpressureDrop()<br>onBackpressureLatest()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">Flowable.interval(1, TimeUnit.MICROSECONDS)</div><div class="line">                .onBackpressureDrop()  //加上背压策略</div><div class="line">                .observeOn(AndroidSchedulers.mainThread())</div><div class="line">                .subscribe(new Subscriber&lt;Long&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void onSubscribe(Subscription s) &#123;</div><div class="line">                        Log.d(TAG, &quot;onSubscribe&quot;);</div><div class="line">                        mSubscription = s;</div><div class="line">                        s.request(Long.MAX_VALUE);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    @Override</div><div class="line">                    public void onNext(Long aLong) &#123;</div><div class="line">                        Log.d(TAG, &quot;onNext: &quot; + aLong);</div><div class="line">                        try &#123;</div><div class="line">                            Thread.sleep(1000);</div><div class="line">                        &#125; catch (InterruptedException e) &#123;</div><div class="line">                            e.printStackTrace();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    @Override</div><div class="line">                    public void onError(Throwable t) &#123;</div><div class="line">                        Log.w(TAG, &quot;onError: &quot;, t);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    @Override</div><div class="line">                    public void onComplete() &#123;</div><div class="line">                        Log.d(TAG, &quot;onComplete&quot;);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div></pre></td></tr></table></figure></p>
<p>Flowable本质是为了响应式拉取,同一个线程中上游可以拿到下游request的数量,request的值可以累加,每次发送事件之后request数量自动减少,当为0时,说明下游没有消耗事件的能力了,这个时候就不要发了,<br>再发就要报MissingBackpressureException异常了.</p>
<p>而在不同线程中,不管下游request多少个,上游拿到的都是128,我们在上游做判断,如果拿到的request值等于0时,证明缓冲区满了不能发了,当下游消耗掉第96个数据后,上游又可以拿到request值了,等于96,然后继续发.<br>至于为什么是96,源码就是这样写的.</p>
<p>用于验证的demo:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">public static void request() &#123;</div><div class="line">        mSubscription.request(96); //请求96个事件</div><div class="line">    &#125;</div><div class="line"></div><div class="line">public static void demo4() &#123;</div><div class="line">        Flowable</div><div class="line">                .create(new FlowableOnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123;</div><div class="line">                        Log.d(TAG, &quot;First requested = &quot; + emitter.requested());</div><div class="line">                        boolean flag;</div><div class="line">                        for (int i = 0; ; i++) &#123;</div><div class="line">                            flag = false;</div><div class="line">                            while (emitter.requested() == 0) &#123;</div><div class="line">                                if (!flag) &#123;</div><div class="line">                                    Log.d(TAG, &quot;Oh no! I can&apos;t emit value!&quot;);</div><div class="line">                                    flag = true;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                            emitter.onNext(i);</div><div class="line">                            Log.d(TAG, &quot;emit &quot; + i + &quot; , requested = &quot; + emitter.requested());</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;, BackpressureStrategy.ERROR)</div><div class="line">                .subscribeOn(Schedulers.io())</div><div class="line">                .observeOn(AndroidSchedulers.mainThread())</div><div class="line">                .subscribe(new Subscriber&lt;Integer&gt;() &#123;</div><div class="line"></div><div class="line">                    @Override</div><div class="line">                    public void onSubscribe(Subscription s) &#123;</div><div class="line">                        Log.d(TAG, &quot;onSubscribe&quot;);</div><div class="line">                        mSubscription = s;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    @Override</div><div class="line">                    public void onNext(Integer integer) &#123;</div><div class="line">                        Log.d(TAG, &quot;onNext: &quot; + integer);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    @Override</div><div class="line">                    public void onError(Throwable t) &#123;</div><div class="line">                        Log.w(TAG, &quot;onError: &quot;, t);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    @Override</div><div class="line">                    public void onComplete() &#123;</div><div class="line">                        Log.d(TAG, &quot;onComplete&quot;);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="RxJava实践搭配"><a href="#RxJava实践搭配" class="headerlink" title="RxJava实践搭配"></a>RxJava实践搭配</h2><p>Rxlifecycle 可以避免不当的使用导致的内存泄漏,基础Activity和Fragment可以继承于Rxlifecycle组件</p>
<p>经过观察发现,Rxlifecycle只是在Activity等退出后,发消息阻断数据向下的传递,并不能解决内存泄漏问题,要解决这个,还是要从源头上解决,在退出后要停止发送数据,这样才能释放内存.</p>
<p>Rxlifecycle在View退出后,会回调onComplete.</p>
<p>内存泄漏本质上是因为长周期的组件引用了短周期的组件,在短周期的组件结束后还没有释放,就产生了内存泄漏,关键点在于引用,跟Rxjava关系不大,因为在创建Observer或者其它类时,经常会采用匿名内部类的方式创建,而匿名内部类默认持有对外部类的引用(所以我们才能在匿名内部类中访问外部类的成员变量(应该是在编译期自动生成了getter和setter方法)),所以会导致内存泄漏.而在MVP模式中,一般在Presenter中进行Rxjava的使用,但是MVP也会持有Activity的引用,所以在Activity退出时一定要与Presenter解绑,这个时候引用就被切断了,但是Presenter本身也会内存泄漏啊,不要以为内存泄漏只存在于Activity等组件中,所以这个时候还是要切断发送数据源,这样才可以,而Rxlifecycle的作用仅仅只是在Activity退出后让发送出的数据不往下传递了而已,功能仅限于此(这样我们就不用手动View判空了,因为View被回收后这边消息已经传递不下来了,哈哈).</p>
<p>总结,什么是内存泄漏?一切对象该被回收的时候,由于各种意外状况导致该对象仍然被引用,就是内存泄漏.多么精辟的一句话啊!</p>
<p>并不是每一个订阅都要手动解除,当onComplete或onError时会自动解除订阅关系,说是解除订阅关系,其实只是消息阻断而已,中间加了判断,确定要不要继续将消息传递下去</p>
<p>Rxbinding帮助我们将View的行为转化为Observable数据源</p>
<p>ReplaySubject （释放接收到的所有数据）<br>BehaviorSubject （释放订阅前最后一个数据和订阅后接收到的所有数据）<br>PublishSubject （释放订阅后接收到的数据）<br>AsyncSubject （仅释放接收到的最后一个数据）<br>SerializedSubject（串行Subject）<br>UnicastSubject (仅支持订阅一次的Subject)<br>TestSubject（已废弃，在2.x中被TestScheduler和TestObserver替代）</p>
<p>takeUntil操作符:当第二个Observable发射了一项数据或者终止时，丢弃原Observable发射的任何数据。</p>
<p>takeUntil本质上第二个Observable发送了数据之后,会调用第一个Observable中的dispose和onComplete方法.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RxJava+Retrofit+OkHttp是最佳的网络请求实践，之前的项目中一直是使用Callback的方式进行网络请求，最近得空，引入了RxJava和Retrofit，重新封装了下项目的网络请求模块，不得不说，使用RxJava的响应式编程思想，面向数据流的编程方式，写出来的代码十分优美。&lt;br&gt;
    
    </summary>
    
    
      <category term="RxJava" scheme="https://forevas.github.io/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="https://forevas.github.io/2017/10/21/ThreadLocal/"/>
    <id>https://forevas.github.io/2017/10/21/ThreadLocal/</id>
    <published>2017-10-21T15:06:50.000Z</published>
    <updated>2018-05-21T15:14:01.312Z</updated>
    
    <content type="html"><![CDATA[<p>ThreadLocal实际上相当于一个工具类，我们使用ThreadLocal类就是和它打交道，本身并不存储什么，真正起作用的是内部类ThreadLocalMap。<br>ThreadLocal类作为Key存储在ThreadLocalMap中，通过ThreadLocal可以拿到存储的value值。<br><a id="more"></a></p>
<h4 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h4><p>ThreadLocal的静态内部类，每个Thread内部都有ThreadLocalMap的成员变量，我们在调用ThreadLocal.set()方法时，实际上会拿到当前线程的ThreadLocalMap成员变量，如果为空则去创建，不为空则进行变量保存。</p>
<p>ThreadLocalMap才是真正用来存储的工具，内部维持一个使用<strong>线性探测法</strong>实现的<strong>哈希表</strong>(不是拉链法)，初始数组长度为16，当数据达到2/3时进行扩容，每次增加一倍。</p>
<p>ThreadLocal的hash值在生成的过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private final int threadLocalHashCode = nextHashCode();</div><div class="line"></div><div class="line">/**</div><div class="line"> * The next hash code to be given out. Updated atomically. Starts at</div><div class="line"> * zero.</div><div class="line"> */</div><div class="line">private static AtomicInteger nextHashCode = new AtomicInteger();</div><div class="line"></div><div class="line">/**</div><div class="line"> * The difference between successively generated hash codes - turns</div><div class="line"> * implicit sequential thread-local IDs into near-optimally spread</div><div class="line"> * multiplicative hash values for power-of-two-sized tables.</div><div class="line"> */</div><div class="line">private static final int HASH_INCREMENT = 0x61c88647;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Returns the next hash code.</div><div class="line"> */</div><div class="line">private static int nextHashCode() &#123;</div><div class="line">    return nextHashCode.getAndAdd(HASH_INCREMENT);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述算法中使用0x61c88647可以让hash的结果在2的n次方内尽可能均匀分布，减少冲突的概率。</p>
<p>ThreadLocalMap的作用域是单个线程内，所以不存在线程间共享数据的问题，也不用考虑线程同步。</p>
<p>不要拿synchronized和ThreadLocal比，两者没有可比性，因为原理和用途完全不一致。</p>
<h4 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h4><p>存储的实体类，继承于WeakReference，对ThreadLocal进行弱引用，同时存储value。Entry实例被存在哈希表中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ThreadLocal实际上相当于一个工具类，我们使用ThreadLocal类就是和它打交道，本身并不存储什么，真正起作用的是内部类ThreadLocalMap。&lt;br&gt;ThreadLocal类作为Key存储在ThreadLocalMap中，通过ThreadLocal可以拿到存储的value值。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://forevas.github.io/tags/Java/"/>
    
      <category term="ThreadLocal" scheme="https://forevas.github.io/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>String原理解析</title>
    <link href="https://forevas.github.io/2017/10/15/String%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>https://forevas.github.io/2017/10/15/String原理解析/</id>
    <published>2017-10-15T15:03:42.000Z</published>
    <updated>2018-05-21T15:13:57.463Z</updated>
    
    <content type="html"><![CDATA[<p>String并不属于基本类型之一，其本质是字符数组。<br>String在java1.7之前底层是java的字符数组，1.8开始在native层进行处理。<br>String不可变，对外提供的方法最后会创建新的String对象，不会对原来的String本身造成影响。1.7以前可以通过反射修改String本身，1.8之后不可以。<br><a id="more"></a></p>
<h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p>为了减少在JVM中创建的字符串的数量，字符串类维护了一个字符串常量池，每当以字面值形式创建一个字符串时，JVM会首先检查字符串常量池：如果字符串已经存在池中，就返回池中的实例引用；如果字符串不在池中，就会实例化一个字符串并放到池中。Java能够进行这样的优化是因为字符串是不可 变的，可以不用担心数据冲突进行共享。</p>
<h5 id="手动入池"><a href="#手动入池" class="headerlink" title="手动入池"></a>手动入池</h5><p>使用intern方法可以进行手动入池操作，当调用 intern 方法时，如果池已经包含一个等于此 String 对象的字符串（用 equals(Object) 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并返回此 String 对象的引用。</p>
<p>对于任意两个字符串 s 和 t ，当且仅当 s.equals(t) 为 true 时，s.intern() == t.intern() 才为 true 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">String str1 = &quot;abc&quot;;</div><div class="line">String str2 = new String(&quot;abc&quot;);</div><div class="line">String str3 = s2.intern();</div><div class="line"></div><div class="line">System.out.println( str1 == str2 );   //false</div><div class="line">System.out.println( str1 == str3 );   //true</div></pre></td></tr></table></figure></p>
<h4 id="String创建方式的区别"><a href="#String创建方式的区别" class="headerlink" title="String创建方式的区别"></a>String创建方式的区别</h4><h5 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h5><p>以字面值方式创建一个String时，会先检查字符串常量池中是否有这个String，如有，则直接返回引用，如果没有，就实例化一个字符串放入池中。</p>
<h5 id="new-String-“”"><a href="#new-String-“”" class="headerlink" title="new String(“”)"></a>new String(“”)</h5><p>通过 new String(“…”) 来创建字符串时，在该构造函数的参数值为字符串字面值的前提下，若该字面值不在字符串常量池中，那么会创建两个对象：一个在字符串常量池中，一个在堆中；否则，只会在堆中创建一个对象。</p>
<h5 id="连接符-“-”"><a href="#连接符-“-”" class="headerlink" title="连接符 “+”"></a>连接符 “+”</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String str2 = &quot;ab&quot;;  //1个对象  </div><div class="line">String str3 = &quot;cd&quot;;  //1个对象                                         </div><div class="line">String str4 = str2+str3;                                        </div><div class="line">String str5 = &quot;abcd&quot;;    </div><div class="line">System.out.println(&quot;str4 = str5 : &quot; + (str4==str5)); // false</div></pre></td></tr></table></figure>
<p>在运行时，第三行代码(str2+str3)实质上会被分解成五个步骤，分别是：</p>
<p>　(1). 调用 String 类的静态方法 String.valueOf() 将 str2 转换为字符串表示；</p>
<p>　(2). JVM 在堆中创建一个 StringBuilder对象，同时用str2指向转换后的字符串对象进行初始化；　</p>
<p>　(3). 调用StringBuilder对象的append方法完成与str3所指向的字符串对象的合并；</p>
<p>　(4). 调用 StringBuilder 的 toString() 方法在堆中创建一个 String对象；</p>
<p>　(5). 将刚刚生成的String对象的堆地址存赋给局部变量引用str4。</p>
<p>使用连接符 “+” 循环连接大量字符串时，因为会默认创建大量的StringBuilder和String对象，所以会导致性能大幅度下降。</p>
<h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public boolean equals(Object anObject) &#123;</div><div class="line">        if (this == anObject) &#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        if (anObject instanceof String) &#123;</div><div class="line">            String anotherString = (String) anObject;</div><div class="line">            int n = length();</div><div class="line">            if (n == anotherString.length()) &#123;</div><div class="line">                int i = 0;</div><div class="line">                while (n-- != 0) &#123;</div><div class="line">                    if (charAt(i) != anotherString.charAt(i))</div><div class="line">                            return false;</div><div class="line">                    i++;</div><div class="line">                &#125;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h4><p>这两者区别在于StringBuffer默认线程同步，StringBuilder不是。</p>
<p>StringBuilder在创建时会创建一个字符数组，append方法会对数组进行扩容，然后将要append的String字符拷贝至数组的末尾，因此不会大量创建String方法，性能较高。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public AbstractStringBuilder append(String str) &#123;</div><div class="line">    if (str == null)</div><div class="line">        return appendNull();</div><div class="line">    int len = str.length();</div><div class="line">    ensureCapacityInternal(count + len);</div><div class="line">    str.getChars(0, len, value, count);</div><div class="line">    count += len;</div><div class="line">    return this;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="String与克隆"><a href="#String与克隆" class="headerlink" title="String与克隆"></a>String与克隆</h4><p>在克隆一个类时，其成员变量若是有String，则将String作为基本数据类型看待就好了，因为String本身是不可变的。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol>
<li>使用字面值形式创建的字符串与通过 new 创建的字符串一定是不同的，因为二者的存储位置不同：前者在方法区，后者在堆；</li>
<li>Java 编译器对 “常量+字面值” 的组合 是当成常量表达式直接求值来优化的；对于含有“String引用”的组合，其在编译期不能被确定，会在运行期创建新对象。</li>
<li>字符串常量池的理念是 《享元模式》；</li>
<li>Java 编译器对于类似“常量+字面值”的组合，其值在编译的时候就能够被确定了。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;String并不属于基本类型之一，其本质是字符数组。&lt;br&gt;String在java1.7之前底层是java的字符数组，1.8开始在native层进行处理。&lt;br&gt;String不可变，对外提供的方法最后会创建新的String对象，不会对原来的String本身造成影响。1.7以前可以通过反射修改String本身，1.8之后不可以。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://forevas.github.io/tags/Java/"/>
    
      <category term="String" scheme="https://forevas.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Java垃圾回收机制</title>
    <link href="https://forevas.github.io/2017/10/07/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>https://forevas.github.io/2017/10/07/Java垃圾回收机制/</id>
    <published>2017-10-07T14:55:45.000Z</published>
    <updated>2018-05-21T15:02:44.229Z</updated>
    
    <content type="html"><![CDATA[<p>Java相比于C++，其最显著的特点就是不需要我们手动去回收内存，一切交给GC线程在后台自动完成，我们可以专心于代码的逻辑设计，而不用在意内存回收的细节。那么Java是如何进行内存回收的？下面对于堆内存结构和垃圾回收的算法进行总结。<br><a id="more"></a></p>
<h3 id="Stop-the-world"><a href="#Stop-the-world" class="headerlink" title="Stop-the-world"></a>Stop-the-world</h3><p>除了GC线程之外的其它线程都停止执行，直到GC完成。GC优化很多时候就是指减少Stop-the-world发生的时间，从而使系统具有 高吞吐 、低停顿 的特点。</p>
<h3 id="如何判断对象是否可以回收"><a href="#如何判断对象是否可以回收" class="headerlink" title="如何判断对象是否可以回收"></a>如何判断对象是否可以回收</h3><h4 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1.引用计数法"></a>1.引用计数法</h4><p>通过判断一个对象的引用数量来决定对象是否可以被回收。</p>
<p>引用计数法很难解决对象之间循环引用问题。</p>
<h4 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2.可达性分析算法"></a>2.可达性分析算法</h4><p>通过判断对象的引用链是否可达来判断对象是否可以被回收。</p>
<p>当一个对象到GC Roots没有任何引用链相连(从GC Roots出发到这个对象不可达)，则说明这个对象是不可用的。</p>
<p>可作为GC Roots的对象有以下几种：</p>
<ol>
<li>虚拟机栈(栈帧中的局部变量表)中引用的对象；</li>
<li>方法区中类静态属性引用的对象；</li>
<li>方法区中常量引用的对象；</li>
<li>本地方法栈中Native方法引用的对象；</li>
</ol>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>从根集合进行扫描，将存活的对象标记，标记完毕后，扫描整个空间中未标记的对象进行清除。</p>
<p>缺点：</p>
<ol>
<li>效率低下：标记和清除两个过程效率都不高。</li>
<li>空间问题：不进行对象移动，产生大量不连续的内存碎片，空间利用率低。</li>
</ol>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>将内存划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p>这种算法适用于对象存活率低的场景，现在商用的虚拟机都使用这种方法来回收新生代，因为研究发现，新生代每次回收之后基本只有10%的对象存活。</p>
<p>实践中，新生代区域一般分为 <strong>eden</strong> 和两块 <strong>survivor(s0和s1)</strong> 区域。</p>
<p>每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。</p>
<p>Eden和s0,s1的比例为：8：1：1.</p>
<h4 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h4><p>老年代对象存活率较高，使用复制算法效率比较低，而且还浪费空间，因此需要使用标记整理算法。</p>
<p>标记整理算法第一阶段和标记清除算法类似，第二阶段则不同，标记整理算法会将存活的对象向内存的一端移动，然后清除掉边界以外的所有内存，类似于磁盘整理。</p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>不通对象的生命周期是不一样的，而不同生命周期的对象位于堆中不同的区域，对于不同区域采用不同的回收策略可以提高JVM的执行效率。</p>
<h5 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h5><p>新生代的目标就是尽可能快速的收集掉那些生命周期短的对象，一般情况下，所有新生成的对象首先都是放在新生代的，而且大部分对象在Eden区中生成。</p>
<p>新生代分为eden，s0,s1,比例为8:1:1，采用复制算法。每次GC，eden和一个survivor区域生存的对象会进入另一个survivor区域，当survivor区域满了之后，存活的对象会进入老年代。</p>
<p>如果老年代也满了，就会触发一次FullGC，也就是新生代、老年代都进行回收。注意，新生代发生的GC也叫做MinorGC，MinorGC发生频率比较高，不一定等Eden区满了才触发。</p>
<h5 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h5><p>老年代存放的都是一些生命周期较长的对象，在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。此外，老年代的内存也比新生代大很多(大概比例是1:2)，当老年代满时会触发Major GC(Full GC)，老年代对象存活时间比较长，因此FullGC发生的频率比较低。</p>
<p>老年代采用标记整理算法。</p>
<p>由于Full GC需要对整个堆进行回收，所以比Minor GC要慢，因此应该尽可能减少Full GC的次数，导致Full GC的原因包括：老年代被写满、永久代（Perm）被写满和System.gc()被显式调用等。</p>
<h5 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h5><p>永久代主要用于存放静态文件，如Java类、方法等。永久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如使用反射、动态代理、CGLib等bytecode框架时，在这种时候需要设置一个比较大的永久代空间来存放这些运行过程中新增的类。</p>
<p>永久代是Hotspot虚拟机特有的概念，是方法区的一种实现，别的JVM都没有这个东西。</p>
<p>在Java 8中，永久代被彻底移除，取而代之的是另一块与堆不相连的本地内存——元空间（Metaspace）,‑XX:MaxPermSize参数失去了意义，取而代之的是-XX:MaxMetaspaceSize。</p>
<p>方法区（method area）只是JVM规范中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，具体放在哪里，不同的实现可以放在不同的地方。</p>
<h4 id="垃圾处理器"><a href="#垃圾处理器" class="headerlink" title="垃圾处理器"></a>垃圾处理器</h4><p>Serial收集器（复制算法): 新生代单线程收集器</p>
<p>Serial Old收集器 (标记-整理算法): 老年代单线程收集器</p>
<p>ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</p>
<p>Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量</p>
<p>Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先</p>
<p>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</p>
<p>G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</p>
<h4 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h4><ol>
<li><p>对象优先在Eden分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC</p>
</li>
<li><p>大对象直接进入老年代</p>
</li>
<li><p>长期存活的对象将进入老年代</p>
</li>
<li><p>动态对象年龄判定</p>
</li>
</ol>
<h4 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h4><p>方法区的内存回收目标主要是针对 常量池的回收 和 对类型的卸载。</p>
<p>回收废弃常量与回收Java堆中的对象非常类似，通过引用判定即可。</p>
<p>判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”：</p>
<ul>
<li><p>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；</p>
</li>
<li><p>加载该类的ClassLoader已经被回收；</p>
</li>
<li><p>该类对应的 java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
</li>
</ul>
<p>虚拟机可以对满足上述3个条件的无用类进行回收(卸载)，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java相比于C++，其最显著的特点就是不需要我们手动去回收内存，一切交给GC线程在后台自动完成，我们可以专心于代码的逻辑设计，而不用在意内存回收的细节。那么Java是如何进行内存回收的？下面对于堆内存结构和垃圾回收的算法进行总结。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://forevas.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://forevas.github.io/tags/JVM/"/>
    
      <category term="GC" scheme="https://forevas.github.io/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存模型</title>
    <link href="https://forevas.github.io/2017/09/29/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://forevas.github.io/2017/09/29/JVM内存模型/</id>
    <published>2017-09-29T12:10:31.000Z</published>
    <updated>2018-05-21T14:56:17.957Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来，对于JVM的内部结构不是很清楚，最近看了一篇博客，写的很好，这里简单总结下。<br><a id="more"></a></p>
<h3 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h3><p>JVM内存可以划分为线程共享的区域和线程私有的区域。</p>
<p>共享区域有 <strong>方法区</strong> 和 <strong>堆</strong> ，私有区域有 <strong>虚拟机栈</strong> 、<strong>本地方法栈</strong> 和 <strong>程序计数器</strong>。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/852D185478C24971B0D3A17D930F399F?method=download&amp;shareKey=0dd3183138a5773fd7d8065c2eaec3b3" alt="JVM内存模型"></p>
<h4 id="线程私有的数据区"><a href="#线程私有的数据区" class="headerlink" title="线程私有的数据区"></a>线程私有的数据区</h4><h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h5><p>为解决线程切换后能恢复到正确的执行位置的问题，每条线程都需要一个独立的程序计数器去记录正在执行的字节码指令地址。</p>
<p>程序计数器是线程私有的一块较小的内存空间，可以看做当前线程所执行的字节码的行号指示器。</p>
<p>如果正在执行java代码，则记录的是正在执行的字节码指令的地址，如果是Native方法，计数器的值为空。</p>
<p>程序计数器是唯一一个没有规定任何 OutOfMemoryError 的区域。</p>
<h5 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h5><p>虚拟机栈描述的是Java方法执行的内存模型，每个方法在执行的时候都会创建一个栈帧，栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p>
<p>每个方法从调用直至完成的过程，对应一个栈帧在虚拟机栈中入栈到出栈的过程。其中，局部变量表主要存放一些基本类型的变量（int, short, long, byte, float, double, boolean, char）和 对象句柄，它们可以是方法参数，也可以是方法的局部变量。</p>
<h6 id="StackOverflowError"><a href="#StackOverflowError" class="headerlink" title="StackOverflowError"></a>StackOverflowError</h6><p>一个线程拥有一个自己的栈，这个栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法，-Xss参数可以设置虚拟机栈大小），若线程请求的栈深度大于虚拟机允许的深度，则抛出 StackOverFlowError 异常。</p>
<h6 id="OutofMemoryError"><a href="#OutofMemoryError" class="headerlink" title="OutofMemoryError"></a>OutofMemoryError</h6><p>栈的大小可以是固定的，也可以是动态扩展的，若虚拟机栈可以动态扩展（大多数虚拟机都可以），但扩展时无法申请到足够的内存(比如没有足够的内存为一个新创建的线程分配栈空间时)，则抛出 OutofMemoryError 异常。下图为栈帧结构图：<br><img src="https://note.youdao.com/yws/api/personal/file/9915DABBF48E4016A2C20B8D00279548?method=download&amp;shareKey=5a6407200b93ab521ea17f2681a83b2b" alt="栈帧"></p>
<h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h5><p>本地方法栈与Java虚拟机栈非常相似，也是线程私有的，区别是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈为虚拟机执行Native方法服务。与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常。</p>
<h4 id="线程共享的数据区"><a href="#线程共享的数据区" class="headerlink" title="线程共享的数据区"></a>线程共享的数据区</h4><h5 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h5><p>也可以称为GC堆，我们new的对象都在这个区域，所有线程共享此区域。<br><img src="https://note.youdao.com/yws/api/personal/file/09EFE46F567C4E08B56863700FB4D1EE?method=download&amp;shareKey=5975b0e2070e3bd7cbf993dda98beb3f" alt="堆结构"></p>
<p>Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。而且，Java堆在实现时，既可以是固定大小的，也可以是可拓展的，并且主流虚拟机都是按可扩展来实现的（通过-Xmx(最大堆容量) 和 -Xms(最小堆容量)控制）。如果在堆中没有内存完成实例分配，并且堆也无法再拓展时，将会抛出 OutOfMemoryError 异常。</p>
<h6 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h6><p>TLAB可以提升内存分配效率，每个线程都要一块独立的空间TLAB，在TLAB上分配对象时不需要加锁(相对于CAS配上失败重试方式)，因此JVM在给线程的对象分配内存时会尽量的在TLAB上分配，在这种情况下JVM中分配对象内存的性能和C基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配。</p>
<p>虚拟机为新生对象分配内存时，需要考虑修改指针(该指针用于划分内存使用空间和空闲空间)时的线程安全问题，因为存在可能出现正在给对象A分配内存，指针还未修改，对象B又同时使用原来的指针分配内存的情况。TLAB的存在就是为了解决这个问题：每个线程在Java堆中预先分配一小块内存TLAB，哪个线程需要分配内存就在自己的TLAB上进行分配，若TLAB用完并分配新的TLAB时，再加同步锁定，这样就大大提升了对象内存分配的效率。</p>
<h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><p>方法区与Java堆一样，也是线程共享的并且不需要连续的内存，其用于存储已被虚拟机加载的 类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<h6 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h6><p>运行时常量池（RuntimeConstantPool）是方法区的一部分，用于存放编译期生成的各种 字面量 和 符号引用。</p>
<h5 id="Java堆-与-方法区的区别"><a href="#Java堆-与-方法区的区别" class="headerlink" title="Java堆 与 方法区的区别"></a>Java堆 与 方法区的区别</h5><p>Java堆是 Java代码可及的内存，是留给开发人员使用的；而非堆（Non-Heap）是JVM留给自己用的。</p>
<p>方法区、JVM内部处理或优化所需的内存 (如JIT编译后的代码缓存)、每个类结构 (如运行时常量池、字段和方法数据)以及方法和构造方法的代码都在非堆内存中。</p>
<h5 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h5><p>常量池的回收 和 对类型的卸载。</p>
<h4 id="对象在虚拟机中的创建过程"><a href="#对象在虚拟机中的创建过程" class="headerlink" title="对象在虚拟机中的创建过程"></a>对象在虚拟机中的创建过程</h4><h5 id="1-检查虚拟机是否加载了所要new的类，若没加载，则首先执行相应的类加载过程"><a href="#1-检查虚拟机是否加载了所要new的类，若没加载，则首先执行相应的类加载过程" class="headerlink" title="1.检查虚拟机是否加载了所要new的类，若没加载，则首先执行相应的类加载过程"></a>1.检查虚拟机是否加载了所要new的类，若没加载，则首先执行相应的类加载过程</h5><h5 id="2-在类加载检查通过后，对象所需内存的大小在类加载完成后便可完全确定，虚拟机就会为新生对象分配内存。"><a href="#2-在类加载检查通过后，对象所需内存的大小在类加载完成后便可完全确定，虚拟机就会为新生对象分配内存。" class="headerlink" title="2.在类加载检查通过后，对象所需内存的大小在类加载完成后便可完全确定，虚拟机就会为新生对象分配内存。"></a>2.在类加载检查通过后，对象所需内存的大小在类加载完成后便可完全确定，虚拟机就会为新生对象分配内存。</h5><p>内存的分配有两种方式：</p>
<ul>
<li>指针碰撞：如果Java堆中内存绝对规整</li>
<li>空闲列表：如果Java堆中内存并不规整</li>
</ul>
<p>修改指针 (该指针用于划分内存使用空间和空闲空间)时的线程安全问题：</p>
<ul>
<li>对分配内存空间的动作进行同步处理：采用CAS+失败重试的方式保证更新操作的原子性；</li>
<li>把内存分配的动作按照线程划分的不同的空间中：每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），哪个线程要分配内存，就在自己的TLAB上分配，如果TLAB用完并分配新的TLAB时，再加同步锁定。</li>
</ul>
<h5 id="3-内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值"><a href="#3-内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值" class="headerlink" title="3.内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值"></a>3.内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值</h5><h5 id="4-在上面的工作完成之后，从虚拟机的角度来看，一个新的对象已经产生了，但从Java程序的视角来看，对象的创建才刚刚开始，此时会执行方法把对象按照程序员的意愿进行初始化，从而产生一个真正可用的对象。"><a href="#4-在上面的工作完成之后，从虚拟机的角度来看，一个新的对象已经产生了，但从Java程序的视角来看，对象的创建才刚刚开始，此时会执行方法把对象按照程序员的意愿进行初始化，从而产生一个真正可用的对象。" class="headerlink" title="4.在上面的工作完成之后，从虚拟机的角度来看，一个新的对象已经产生了，但从Java程序的视角来看，对象的创建才刚刚开始，此时会执行方法把对象按照程序员的意愿进行初始化，从而产生一个真正可用的对象。"></a>4.在上面的工作完成之后，从虚拟机的角度来看，一个新的对象已经产生了，但从Java程序的视角来看，对象的创建才刚刚开始，此时会执行<init>方法把对象按照程序员的意愿进行初始化，从而产生一个真正可用的对象。</init></h5><h4 id="对象在虚拟机中的访问定位"><a href="#对象在虚拟机中的访问定位" class="headerlink" title="对象在虚拟机中的访问定位"></a>对象在虚拟机中的访问定位</h4><p>句柄访问和直接指针访问</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://blog.csdn.net/justloveyou_/article/details/71189093" target="_blank" rel="external">https://blog.csdn.net/justloveyou_/article/details/71189093</a><br>——文中图片引用自CSDN</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直以来，对于JVM的内部结构不是很清楚，最近看了一篇博客，写的很好，这里简单总结下。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://forevas.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://forevas.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java Throwable体系</title>
    <link href="https://forevas.github.io/2017/09/23/Java-Throwable%E4%BD%93%E7%B3%BB/"/>
    <id>https://forevas.github.io/2017/09/23/Java-Throwable体系/</id>
    <published>2017-09-23T13:15:32.000Z</published>
    <updated>2018-05-21T14:45:54.110Z</updated>
    
    <content type="html"><![CDATA[<p>本篇对Java Throwable体系进行梳理，同时讨论下try-catch和return的执行顺序。<br><a id="more"></a></p>
<h4 id="Throwable体系"><a href="#Throwable体系" class="headerlink" title="Throwable体系"></a>Throwable体系</h4><p><img src="https://note.youdao.com/yws/api/personal/file/A443DD2D046B433A9DBCFDC58A9703F0?method=download&amp;shareKey=2aac7db38a07017748777c3be7bdccfe" alt="Throwable体系"></p>
<h4 id="Exception和Error"><a href="#Exception和Error" class="headerlink" title="Exception和Error"></a>Exception和Error</h4><p>因为在java中，能通过代码处理的我们叫做Exception，而我们不能处理的叫做Error。</p>
<p>Error指的是那些例如：JVM运行错误，栈空间用尽，类定义错误等等非常严重的问题。一旦出现错误，我们不能通过代码进行处理，所以编码要注意避免Error。</p>
<p>Exception我们是可以通过try-catch处理的，即使发生了Exception我们也可以通过适当的处理来保持程序正常的运行。</p>
<h4 id="运行时异常-RuntimeException-和非运行时异常"><a href="#运行时异常-RuntimeException-和非运行时异常" class="headerlink" title="运行时异常(RuntimeException)和非运行时异常"></a>运行时异常(RuntimeException)和非运行时异常</h4><p>运行时异常是没办法预料的，例如NullPointerException，IndexOutOfBoundsException,ClassCastException,OutOfMemoryException,IllegalArgumentException 等等，编译器发现不了也不会提醒，只有在运行期才会出现，不过我们可以主动try-catch来处理异常。</p>
<p>非运行时时显而易见可能会出错的，编译器会提前提醒我们要对非运行时异常进行处理，try-catch或者声明throws都可以，例如IOException，FileNotFoundExcetion，SQLException，NoSuchMethodException ，InvocationTargetException等等。</p>
<p>我们在throw Exception的时候，如果throw的是RuntimeExcepiton，那么编译器不会提醒我们进行任何处理，但若是非运行时异常则会提醒我们try-catch或者声明throws。</p>
<h4 id="try-catch和return"><a href="#try-catch和return" class="headerlink" title="try-catch和return"></a>try-catch和return</h4><p>不管是在try中return，还是在catch中return，都会在return之前执行finally的代码。</p>
<p>return要是返回一个表达式，则会在表达式运算完成之后才执行finally的代码。</p>
<p>若在finally之中有return，则直接return。</p>
<p>注意throw Exception的时候是直接返回，其它什么代码都不会执行的。</p>
<p>还有System.exit(0)也是什么都不执行的，虚拟机都退出了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇对Java Throwable体系进行梳理，同时讨论下try-catch和return的执行顺序。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://forevas.github.io/tags/Java/"/>
    
      <category term="Throwable" scheme="https://forevas.github.io/tags/Throwable/"/>
    
  </entry>
  
  <entry>
    <title>Java注解</title>
    <link href="https://forevas.github.io/2017/09/21/Java%E6%B3%A8%E8%A7%A3/"/>
    <id>https://forevas.github.io/2017/09/21/Java注解/</id>
    <published>2017-09-21T14:34:29.000Z</published>
    <updated>2018-05-21T14:44:17.079Z</updated>
    
    <content type="html"><![CDATA[<p>Java注解平时使用的较少，不过可以看到，很多三方库中大量的使用Java注解进行代码的解耦。这里总结下Java注解的用法，以后在代码中还是要多多使用，增加熟练度。<br><a id="more"></a></p>
<h3 id="元注解-meta-annotation"><a href="#元注解-meta-annotation" class="headerlink" title="元注解(meta-annotation)"></a>元注解(meta-annotation)</h3><p>注解的注解,可以用来注解普通注解,常用于自定义注解</p>
<h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p>这个元注解用于声明注解的适用范围,使用方法为@Target(ElementType.TYPE)<br>type共有七种:</p>
<ol>
<li>ElemenetType.CONSTRUCTOR 构造器声明</li>
<li>ElemenetType.FIELD 域声明(包括 enum 实例)</li>
<li>ElemenetType.LOCAL_VARIABLE 局部变量声明</li>
<li>ElemenetType.METHOD 方法声明</li>
<li>ElemenetType.PACKAGE 包声明</li>
<li>ElemenetType.PARAMETER 参数声明</li>
<li>ElemenetType.TYPE 类，接口(包括注解类型)或enum声明</li>
</ol>
<h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p>这个注解用来描述注解保留的时间,使用方法为@Retention(RetentionPolicy.RUNTIME)</p>
<ol>
<li>SOURCE:  Annotation只保留在原代码中，当编译器编译的时候就会抛弃它。（即源文件保留）</li>
<li>CLASS:   编译器将把Annotation记录在Class文件中，不过当java程序执行的时候，JVM将抛弃它。（即class保留）</li>
<li>RUNTIME: 在Retationpolicy.CLASS的基础上，JVM执行的时候也不会抛弃它，所以我们一般在程序中可以通过反射来获得这个注解，然后进行处理。</li>
</ol>
<h4 id="Document"><a href="#Document" class="headerlink" title="@Document"></a>@Document</h4><p>Document标记这个注解应该被javadoc工具记录。默认情况下，Javadoc是不包括注解的。</p>
<h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>Inherited译为可继承的，如果一个使用了@Inherited 修饰的 annotation类型 被用于一个 class，则这个 annotation 将被用于该class的子类。</p>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>注解不能继承或者实现其它注解或者接口.<br>@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法名称为参数名称,返回值类型就是参数类型.可使用default指定参数的默认值.</p>
<p>注解可以定义多个方法,传入多个参数时可以这样,例如:</p>
<p>@Field(value = “tags”,encoded = false)</p>
<h5 id="Retention-SOURCE"><a href="#Retention-SOURCE" class="headerlink" title="@Retention(SOURCE)"></a>@Retention(SOURCE)</h5><p>源码注解(RetentionPolicy.SOURCE)的生命周期只存在Java源文件这一阶段，是3种生命周期中最短的注解。基本无需刻意去做处理，如@InDef、@StringDef等</p>
<h5 id="Retention-Class"><a href="#Retention-Class" class="headerlink" title="@Retention(Class)"></a>@Retention(Class)</h5><p>使用APT去处理注解</p>
<h5 id="Retention-RunTime"><a href="#Retention-RunTime" class="headerlink" title="@Retention(RunTime)"></a>@Retention(RunTime)</h5><p>生命周期最长通常可以使用反射，也可以使用自定义注解器</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java注解平时使用的较少，不过可以看到，很多三方库中大量的使用Java注解进行代码的解耦。这里总结下Java注解的用法，以后在代码中还是要多多使用，增加熟练度。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://forevas.github.io/tags/Java/"/>
    
      <category term="Annotation" scheme="https://forevas.github.io/tags/Annotation/"/>
    
  </entry>
  
  <entry>
    <title>开发技巧</title>
    <link href="https://forevas.github.io/2017/09/15/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"/>
    <id>https://forevas.github.io/2017/09/15/开发技巧/</id>
    <published>2017-09-15T14:29:06.000Z</published>
    <updated>2018-05-21T14:31:16.824Z</updated>
    
    <content type="html"><![CDATA[<p>在Android开发的过程中，有很多开源库或者小工具很实用，能大大的提高开发效率，这里总结下。<br><a id="more"></a></p>
<h4 id="接口调试"><a href="#接口调试" class="headerlink" title="接口调试"></a>接口调试</h4><h5 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h5><p>可以使用Postman工具测试接口，模拟发送请求，灵活度很高，缺点是要手动配置参数，不太方便。</p>
<h5 id="stetho"><a href="#stetho" class="headerlink" title="stetho"></a>stetho</h5><p>也可以使用OkHttp+stetho+Chrome调试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">compile &apos;com.facebook.stetho:stetho:1.5.0&apos;</div><div class="line">compile &apos;com.facebook.stetho:stetho-okhttp3:1.5.0&apos;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stetho.initializeWithDefaults(this);//在Application中配置</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.addNetworkInterceptor(new StethoInterceptor()) //在OkHttpClient初始化的时候配置</div></pre></td></tr></table></figure>
<p>然后在Chrome中打开<strong>chrome://inspect</strong>即可监听到所有的网络请求。</p>
<p>这种方式比较便捷，但是暂时只能用于监听，且必须连接USB，上线的时候要去掉这些配置。</p>
<h5 id="fidder"><a href="#fidder" class="headerlink" title="fidder"></a>fidder</h5><p>还有一种就是通过电脑端的fidder进行代理，然后抓包查看数据，fidder可以模拟弱网环境。</p>
<h4 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h4><p>findViewById，setOnClickListener这种操作可用ButterKnife一键完成<br>JavaBean，序列化，getter，setter，toString等操作都可通过android studio自带的工具一键生成</p>
<h4 id="Json格式化"><a href="#Json格式化" class="headerlink" title="Json格式化"></a>Json格式化</h4><p>chrome插件JSON-handle很好用</p>
<h4 id="性能优化工具"><a href="#性能优化工具" class="headerlink" title="性能优化工具"></a>性能优化工具</h4><p>打开android studio-&gt;tools-&gt;android-&gt;android device monitor<br>可使用:dumpsys、Systrace、TraceView、Update Threads（更新线程）、Update Heap（更新堆）、Allocation Tracker（分配跟踪器）等工具</p>
<p>关于Systrace,TraceView</p>
<p>参考链接:<a href="http://blog.csdn.net/xiyangyang8/article/details/50545707" target="_blank" rel="external">http://blog.csdn.net/xiyangyang8/article/details/50545707</a></p>
<p>android device monitor:<br>Update Heap 查看堆分配信息</p>
<p>Dump HPROF file和Allocation Tracker的功能可直接在android studio的Android Monitor中使用,分别是Dump Java Heap和Start Allocation Tracing.</p>
<p>Update Thread 查看所有线程的状态</p>
<p>Start Method Profiling 点击开始,再次点击结束,查看分析结果(TraceView)</p>
<p>dump View Hierarchy for UI automator 可查看界面的布局层次结构(连第三方应用也可查看,很叼)</p>
<p>Capture system wide trace using android systrace 生成分析结果,通过chrome查看(Systrace)</p>
<p>Trace OpenGL calls:暂未清楚用途</p>
<p>lint工具可以进行代码的扫描和分析,帮助我们发现代码结构/质量问题.</p>
<p>Lint 会根据预先配置的检测标准检查我们 Android 项目的源文件，发现潜在的 bug 或者可以优化的地方，优化的内容主要包括以下几方面：</p>
<p>Correctness：不够完美的编码，比如硬编码、使用过时 API 等</p>
<p>Performance：对性能有影响的编码，比如：静态引用，循环引用等</p>
<p>Internationalization：国际化，直接使用汉字，没有使用资源引用等</p>
<p>Security：不安全的编码，比如在 WebView 中允许使用 JavaScriptInterface 等<br>…</p>
<p>查找无用的资源文件,android studio在Analyze栏下使用lint工具.</p>
<p>例如常用的查找无用的资源文件可通过,Analyze-&gt;Run Inspection by Name-&gt;unused resources.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Android开发的过程中，有很多开源库或者小工具很实用，能大大的提高开发效率，这里总结下。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="https://forevas.github.io/tags/Android/"/>
    
      <category term="小技巧" scheme="https://forevas.github.io/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>模块化,组件化,插件化</title>
    <link href="https://forevas.github.io/2017/09/01/%E6%A8%A1%E5%9D%97%E5%8C%96-%E7%BB%84%E4%BB%B6%E5%8C%96-%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    <id>https://forevas.github.io/2017/09/01/模块化-组件化-插件化/</id>
    <published>2017-09-01T14:19:06.000Z</published>
    <updated>2018-05-21T14:27:36.861Z</updated>
    
    <content type="html"><![CDATA[<p>在编程之初，相信每个人都有按照功能分包的意识，这就是最简单的模块化，而随着项目越来越大，代码逻辑越来越复杂，维护起来十分麻烦。因而组件化，插件化等技术慢慢的发展了起来，本文主要总结下自己对于模块化、组件化、插件化等概念的认识。<br><a id="more"></a></p>
<h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>根据功能或者业务进行划分模块,例如网络请求模块,图片加载模块,登录模块，模块化相互之间存在依赖关系</p>
<h4 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h4><p>根据业务逻辑划分,多个module,debug时可编译为多个apk,release时可编译为多个Library,可在gradle中配置debug和release的相关参数.组件间需要采用隐式通信</p>
<p>解决问题:</p>
<ol>
<li>用于项目过大，每次编译时间长</li>
<li>用于团队多个人分工开发不同的模块</li>
<li>解耦,便于维护</li>
</ol>
<p>在进行组件化开发时，首先需要进行基础模块和业务模块的划分，基础功能包括基础网络请求，图片加载，播放器等等，这些功能模块是所有业务模块的通用基础库。而我们进行的组件化开发，则是针对业务模块进行的。将业务拆分成一个个独立的模块，在开发时以独立app进行，整合时则作为lib进行。业务模块之间的页面跳转可以通过Route等开源框架实现，或者自己实现也可以。业务模块之间的数据通信，主要是通过Intent传值，ContentProvider，广播等形式进行。</p>
<h4 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h4><p>将各个功能拆分成独立的插件,可下载插件扩展功能,主要技术难点是动态加载</p>
<p>解决问题</p>
<ol>
<li>解决方法数超过65536问题</li>
<li>按照需要下载模块，减小项目apk的大小</li>
</ol>
<h4 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h4><p>主要原理和插件化差不多,都是动态加载,区别热更新是要做到bug类的替换和修复<br>常用操作为:资源替换,类替换,So库替换</p>
<p>Tinker,AndFix…</p>
<p>解决问题:</p>
<ol>
<li>线上修复bug,一般不用于新功能的上线</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在编程之初，相信每个人都有按照功能分包的意识，这就是最简单的模块化，而随着项目越来越大，代码逻辑越来越复杂，维护起来十分麻烦。因而组件化，插件化等技术慢慢的发展了起来，本文主要总结下自己对于模块化、组件化、插件化等概念的认识。&lt;br&gt;
    
    </summary>
    
    
      <category term="模块化" scheme="https://forevas.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
      <category term="组件化" scheme="https://forevas.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
      <category term="插件化" scheme="https://forevas.github.io/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
</feed>
